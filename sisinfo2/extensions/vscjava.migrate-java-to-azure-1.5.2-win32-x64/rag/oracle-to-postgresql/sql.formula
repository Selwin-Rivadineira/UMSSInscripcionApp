name: 'Migrate SQL scripts from Oracle to PostgreSQL'
description: 'Update SQL files for Oracle to PostgreSQL migration'

codeLocation:
  type: textsearch
  filePattern: "**/*.sql"
  codePattern: >-
    (?i)VARCHAR2|CLOB|BLOB|SYSDATE|ROWNUM|ROWID|NOCOPY|TABLE|PROCEDURE|CONNECT BY\s+|START WITH|BULK COLLECT|FORALL|PL/SQL|NOCACHE|DUAL|PRAGMA|JOIN\s+|CREATE\s+|ALTER\s+|SELECT\s+|INSERT\s+|UPDATE\s+

steps:
  - description: "Update SQL scripts for Oracle to PostgreSQL migration"
    type: "instruction"
    content: |

      Your task is to migrate SQL scripts from Oracle syntax to PostgreSQL compatibility.

      Follow these steps:
      1. Review the checklist items below in sequence
      2. Apply each relevant modification to the SQL file
      3. For each change you make, add a comment in the migrated code that includes the check item information. Example:
        ```sql
        -- Migrated from Oracle to PostgreSQL according to SQL check item 1: Use lowercase for identifiers (like table and column names) and data type (like varchar), use uppercase for SQL keywords (like SELECT, FROM, WHERE).
        ```

      # Check list

      SQL check item 0: Don't modify the content if it's obviously not related to Oracle. For example: File named mysql-schema.sql, file with path mysql/schema.sql. However, also scan the file content for Oracle-specific keywords (e.g., VARCHAR2, NUMBER, etc.) to ensure it does not contain Oracle-related syntax before excluding it.

      SQL check item 1: Use lowercase for identifiers (like table and column names) and data type (like varchar), use uppercase for SQL keywords (like SELECT, FROM, WHERE).
        ```sql
        -- Before migration (Oracle)
        CREATE TABLE EMPLOYEES (
            EMPLOYEE_ID NUMBER(6) PRIMARY KEY,
            FIRST_NAME VARCHAR2(20),
            LAST_NAME VARCHAR2(25) NOT NULL,
            EMAIL VARCHAR2(25) UNIQUE,
            SALARY NUMBER(8,2)
        );
        ALTER TABLE QRTZ_SIMPROP_TRIGGERS
            ADD CONSTRAINT FK_QRTZ_SIMPROP_TRIGGERS_QRTZ_TRIGGERS FOREIGN KEY (
                SCHED_NAME,
                TRIGGER_NAME,
                TRIGGER_GROUP
            ) REFERENCES QRTZ_TRIGGERS (
                SCHED_NAME,
                TRIGGER_NAME,
                TRIGGER_GROUP
            ) ON DELETE CASCADE;


        -- After migration (PostgreSQL)
        CREATE TABLE employees (
            employee_id INTEGER PRIMARY KEY,
            first_name varchar(20),
            last_name varchar(25) NOT NULL,
            email varchar(25) UNIQUE,
            salary numeric(8,2)
        );
        ALTER TABLE qrtz_simprop_triggers
            ADD CONSTRAINT fk_qrtz_simprop_triggers_qrtz_triggers FOREIGN KEY (
                sched_name,
                trigger_name,
                trigger_group
            ) REFERENCES qrtz_triggers (
                sched_name,
                trigger_name,
                trigger_group
            ) ON DELETE CASCADE;
        ```

      SQL check item 2: Replace Oracle-specific data types with PostgreSQL equivalents (NUMBER→INTEGER, VARCHAR2→VARCHAR, etc).
        ```sql
        -- Before migration (Oracle)
        CREATE TABLE PRODUCTS (
            PRODUCT_ID NUMBER PRIMARY KEY,
            NAME VARCHAR2(100),
            DESCRIPTION CLOB,
            IMAGE BLOB,
            CREATED_DATE DATE,
            MODIFIED_TIMESTAMP TIMESTAMP
        );

        -- After migration (PostgreSQL)
        CREATE TABLE products (
            product_id SERIAL PRIMARY KEY,
            name varchar(100),
            description text,
            image bytea,
            created_date date,
            modified_timestamp timestamp
        );
        ```

      SQL check item 3: Remove FROM DUAL in SELECT statements that only return values.
        ```sql
        -- Before migration (Oracle)
        SELECT SYSDATE FROM DUAL;

        -- After migration (PostgreSQL)
        SELECT CURRENT_DATE;
        ```

      SQL check item 4: Convert Oracle's TO_DATE format to PostgreSQL ISO date literals.
        ```sql
        -- Before migration (Oracle)
        INSERT INTO EMPLOYEES (HIRE_DATE)
        VALUES (TO_DATE('17-JUN-2003', 'DD-MON-YYYY'));

        -- After migration (PostgreSQL)
        INSERT INTO employees (hire_date)
        VALUES ('2003-06-17');
        ```

      SQL check item 5: Replace Oracle MERGE with PostgreSQL alternatives
        ```sql
        -- Case 1: For upsert operations (INSERT + UPDATE)
        -- Before migration (Oracle)
        MERGE INTO DEPARTMENTS d
        USING (SELECT 70 AS dept_id, 'Public Relations' AS dept_name FROM dual) src
        ON (d.DEPARTMENT_ID = src.dept_id)
        WHEN MATCHED THEN
            UPDATE SET d.DEPARTMENT_NAME = src.dept_name
        WHEN NOT MATCHED THEN
            INSERT (DEPARTMENT_ID, DEPARTMENT_NAME)
            VALUES (src.dept_id, src.dept_name);

        -- After migration (PostgreSQL)
        INSERT INTO departments (department_id, department_name)
        VALUES (70, 'Public Relations')
        ON CONFLICT (department_id)
        DO UPDATE SET
            department_name = EXCLUDED.department_name;

        -- Case 2: For update-only operations with joined data
        -- Before migration (Oracle)
        merge into DIALOG d
        using ID_MAPPINGER@VEILARBAKTIVITET idm on (d.ARENA_ID = idm.EKSTERN_REFERANSE_ID)
        when matched then
        update set d.AKTIVITET_ID = idm.AKTIVITET_ID;

        -- After migration (PostgreSQL)
        UPDATE dialog d
        SET aktivitet_id = idm.aktivitet_id
        FROM id_mappinger idm
        WHERE d.arena_id = idm.ekstern_referanse_id;
        ```

      SQL check item 6: Replace CONNECT BY hierarchical queries with recursive CTEs.
        ```sql
        -- Before migration (Oracle)
        SELECT
            employee_id,
            last_name,
            LEVEL as hierarchy_level
        FROM EMPLOYEES
        START WITH manager_id IS NULL
        CONNECT BY PRIOR employee_id = manager_id;

        -- After migration (PostgreSQL)
        WITH RECURSIVE emp_hierarchy AS (
            -- Base case
            SELECT
                employee_id,
                last_name,
                1 as hierarchy_level
            FROM employees
            WHERE manager_id IS NULL

            UNION ALL

            -- Recursive case
            SELECT
                e.employee_id,
                e.last_name,
                eh.hierarchy_level + 1
            FROM
                employees e
            JOIN
                emp_hierarchy eh ON e.manager_id = eh.employee_id
        )
        SELECT
            employee_id,
            last_name,
            hierarchy_level
        FROM emp_hierarchy;
        ```

      SQL check item 7: Replace ROWNUM-based pagination with LIMIT/OFFSET.
        ```sql
        -- Before migration (Oracle)
        SELECT * FROM EMPLOYEES
        WHERE ROWNUM <= 10
        ORDER BY SALARY DESC;

        -- After migration (PostgreSQL)
        SELECT * FROM employees
        ORDER BY salary DESC
        LIMIT 10;
        ```

      SQL check item 8: Convert Oracle sequences to PostgreSQL sequences and update usage syntax.
        ```sql
        -- Before migration (Oracle)
        CREATE SEQUENCE EMPLOYEES_SEQ
        START WITH 1000
        INCREMENT BY 1
        NOCACHE
        NOCYCLE;

        -- Oracle sequence usage
        INSERT INTO EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME)
        VALUES (EMPLOYEES_SEQ.NEXTVAL, 'John', 'Doe');

        -- After migration (PostgreSQL)
        CREATE SEQUENCE employees_seq
        START WITH 1000
        INCREMENT BY 1;

        -- PostgreSQL sequence usage
        INSERT INTO employees (employee_id, first_name, last_name)
        VALUES (nextval('employees_seq'), 'John', 'Doe');
        ```

      SQL check item 9: Replace DATABASE LINK with postgres_fdw Foreign Data Wrapper.
        ```sql
        -- Before migration (Oracle)
        CREATE DATABASE LINK remote_db
          CONNECT TO remote_user IDENTIFIED BY remote_password
          USING 'remote_tns_entry';

        SELECT * FROM items@remote_db;

        -- After migration (PostgreSQL)
        CREATE EXTENSION postgres_fdw;

        CREATE SERVER remote_server
        FOREIGN DATA WRAPPER postgres_fdw
        OPTIONS (host 'remote_host', dbname 'remote_db', port '5432');

        CREATE USER MAPPING FOR local_user
        SERVER remote_server
        OPTIONS (user 'remote_user', password 'remote_password');

        CREATE FOREIGN TABLE remote_items (
            item_id integer,
            item_name varchar(100)
        )
        SERVER remote_server
        OPTIONS (schema_name 'public', table_name 'items');

        SELECT * FROM remote_items;
        ```

      SQL check item 10: Replace GENERATED ALWAYS AS IDENTITY with SERIAL for auto-incrementing keys.
        ```sql
        -- Before migration (Oracle)
        CREATE TABLE log_entries (
            LOG_ID NUMBER GENERATED ALWAYS AS IDENTITY,
            LOG_MESSAGE VARCHAR2(200),
            LOG_TIMESTAMP TIMESTAMP DEFAULT SYSTIMESTAMP,
            PARENT_LOG_ID NUMBER
        );

        -- After migration (PostgreSQL)
        CREATE TABLE log_entries (
            log_id serial PRIMARY KEY,
            log_message varchar(200),
            log_timestamp timestamp DEFAULT CURRENT_TIMESTAMP,
            parent_log_id integer
        );
        ```

      SQL check item 11: Convert Oracle NOCACHE to PostgreSQL (omit or use CACHE 1)
        ```sql
        -- Case 1: Using default behavior (omitting CACHE directive)
        -- Before migration (Oracle)
        CREATE SEQUENCE items_seq
            START WITH 1000
            INCREMENT BY 1
            NOCACHE
            NOCYCLE;

        -- After migration (PostgreSQL)
        CREATE SEQUENCE items_seq
            START WITH 1000
            INCREMENT BY 1
            NO CYCLE;

        -- Case 2: Explicitly setting CACHE 1
        -- Before migration (Oracle)
        CREATE SEQUENCE order_seq
            START WITH 5000
            INCREMENT BY 1
            NOCACHE
            NOCYCLE;

        -- After migration (PostgreSQL)
        CREATE SEQUENCE order_seq
            START WITH 5000
            INCREMENT BY 1
            CACHE 1
            NO CYCLE;
        ```

      SQL check item 12: Convert procedure syntax from PL/SQL to PL/pgSQL with dollar-quoted bodies.
        ```sql
        -- Before migration (Oracle)
        CREATE OR REPLACE PROCEDURE update_item_value(
            p_item_id IN ITEMS.ITEM_ID%TYPE,
            p_percent IN NUMBER
        ) IS
        BEGIN
            UPDATE ITEMS
            SET VALUE = VALUE * (1 + p_percent/100)
            WHERE ITEM_ID = p_item_id;
            COMMIT;
        EXCEPTION
            WHEN OTHERS THEN
                ROLLBACK;
                RAISE;
        END update_item_value;
        /

        -- After migration (PostgreSQL)
        CREATE OR REPLACE PROCEDURE update_item_value(
            p_item_id bigint,
            p_percent numeric
        ) AS $$
        BEGIN
            UPDATE items
            SET value = value * (1 + p_percent/100)
            WHERE item_id = p_item_id;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE;
        END;
        $$ LANGUAGE plpgsql;
        ```

      SQL check item 13: Convert function syntax from PL/SQL to PL/pgSQL with dollar quotes and explicit RETURNS.
        ```sql
        -- Before migration (Oracle)
        CREATE OR REPLACE FUNCTION calculate_total(
            p_value IN ITEMS.VALUE%TYPE,
            p_tax_pct IN NUMBER
        ) RETURN NUMBER IS
            v_total NUMBER;
        BEGIN
            v_total := p_value * (1 + p_tax_pct/100);
            RETURN v_total;
        END calculate_total;
        /

        -- After migration (PostgreSQL)
        CREATE OR REPLACE FUNCTION calculate_total(
            p_value numeric,
            p_tax_pct numeric
        ) RETURNS numeric AS $$
        DECLARE
            v_total numeric;
        BEGIN
            v_total := p_value * (1 + p_tax_pct/100);
            RETURN v_total;
        END;
        $$ LANGUAGE plpgsql;
        ```

      SQL check item 14: Split packages into separate standalone functions and procedures.
        ```sql
        -- Before migration (Oracle)
        CREATE OR REPLACE PACKAGE item_manager AS
            PROCEDURE get_item_info(
                p_item_id IN NUMBER,
                p_result OUT SYS_REFCURSOR
            );

            FUNCTION calculate_discount(
                p_item_id IN NUMBER,
                p_percent IN NUMBER
            ) RETURN NUMBER;
        END item_manager;
        /

        -- After migration (PostgreSQL)
        -- Create separate procedure
        CREATE OR REPLACE PROCEDURE get_item_info(
            p_item_id integer,
            INOUT p_result refcursor
        ) AS $$
        BEGIN
            p_result := 'item_cursor';
            OPEN p_result FOR
            SELECT i.*, c.category_name
            FROM items i
            JOIN categories c ON i.category_id = c.category_id
            WHERE i.item_id = p_item_id;
        END;
        $$ LANGUAGE plpgsql;

        -- Create separate function
        CREATE OR REPLACE FUNCTION calculate_discount(
            p_item_id integer,
            p_percent integer
        ) RETURNS numeric AS $$
        DECLARE
            v_price items.price%TYPE;
            v_discount numeric;
        BEGIN
            SELECT price INTO v_price FROM items WHERE item_id = p_item_id;
            v_discount := v_price * (p_percent::numeric / 100);
            RETURN v_discount;
        END;
        $$ LANGUAGE plpgsql;
        ```

      SQL check item 15: Convert package body functions to standalone PL/pgSQL functions.
        ```sql
        -- Before migration (Oracle)
        CREATE OR REPLACE PACKAGE HR AS
            FUNCTION CALCULATE_BONUS(
                p_employee_id IN NUMBER,
                p_percent IN NUMBER
            ) RETURN NUMBER;
        END HR;
        /

        CREATE OR REPLACE PACKAGE BODY HR AS
            FUNCTION CALCULATE_BONUS(
                p_employee_id IN NUMBER,
                p_percent IN NUMBER
            ) RETURN NUMBER
            IS
                v_salary NUMBER;
                v_bonus NUMBER;
            BEGIN
                SELECT SALARY INTO v_salary
                FROM EMPLOYEES
                WHERE EMPLOYEE_ID = p_employee_id;

                v_bonus := v_salary * (p_percent/100);
                RETURN v_bonus;
            END CALCULATE_BONUS;
        END HR;
        /

        -- After migration (PostgreSQL)
        CREATE OR REPLACE FUNCTION calculate_bonus(
            p_employee_id integer,
            p_percent integer
        ) RETURNS numeric AS $$
        DECLARE
            v_salary numeric;
            v_bonus numeric;
        BEGIN
            SELECT salary INTO v_salary
            FROM employees
            WHERE employee_id = p_employee_id;

            v_bonus := v_salary * (p_percent::numeric / 100);
            RETURN v_bonus;
        END;
        $$ LANGUAGE plpgsql;
        ```

      SQL check item 16: Remove Oracle-specific features that have no direct PostgreSQL equivalent, including storage clauses, tablespace specifications, and other Oracle-specific optimizations that have no easy PostgreSQL counterpart.
        ```sql
        -- Before migration (Oracle)
        ALTER TABLE users
            ADD CONSTRAINT users_pk PRIMARY KEY (user_id)
                USING INDEX PCTFREE 10 INITRANS 2 TABLESPACE users LOGGING
                    STORAGE (
                        INITIAL 65536
                        NEXT 1048576
                        PCTINCREASE 0
                        MINEXTENTS 1
                        MAXEXTENTS 2147483645
                        FREELISTS 1
                        FREELIST GROUPS 1
                        BUFFER_POOL DEFAULT
                    );

        -- After migration (PostgreSQL)
        ALTER TABLE users
            ADD CONSTRAINT users_pk PRIMARY KEY (user_id);
        ```

      SQL check item 9999: Migrate all other Oracle-specific content to PostgreSQL. For each line, carefully verify whether it uses Oracle-only features.
