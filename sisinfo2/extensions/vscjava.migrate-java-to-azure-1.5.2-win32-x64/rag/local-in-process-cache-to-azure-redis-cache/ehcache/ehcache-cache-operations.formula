name: 'Migrate Ehcache cache operations to Azure Cache for Redis'
description: "Converts Ehcache cache operations (get, put, remove) to Azure Cache for Redis operations"
codeLocation:
  type: textsearch
  filePattern: '**/*.java'
  codePattern: >-
    cache.get|cache.put|cache.remove|ehcache.get|ehcache.put|ehcache.remove|Element\(|new Element\(

steps:
  - description: "Migrate Ehcache cache operations to Azure Cache for Redis operations"
    type: "instruction"
    content: |
      Your task is to migrate Java code that performs Ehcache operations (get, put, remove) to use Azure Cache for Redis operations instead.
      Pay attention that you should only update the specific cache operation code and keep the rest of the file - you cannot replace the whole file. What you return must be a valid, complete Java file.

      Below are examples of Ehcache operations and their Azure Redis equivalents:

      Ehcache operations examples:
      ```java
      // Using Ehcache directly
      Cache userCache = cacheManager.getCache("userCache");
      
      // Put operation
      Element element = new Element("user:123", user);
      userCache.put(element);
      
      // Get operation
      Element userElement = userCache.get("user:123");
      User user = (User) userElement.getObjectValue();
      
      // Check if key exists
      boolean exists = userCache.isKeyInCache("user:123");
      
      // Remove operation
      userCache.remove("user:123");
      
      // Clear cache
      userCache.removeAll();
      
      // Ehcache with TTL for specific entry
      Element element = new Element("user:123", user);
      element.setTimeToLive(3600); // 1 hour in seconds
      userCache.put(element);
      ```

      Azure Cache for Redis operations using Lettuce (recommended):
      ```java
      // Using Lettuce directly
      RedisClient redisClient = RedisClient.create("redis://password@host:6380?ssl=true");
      try (StatefulRedisConnection<String, String> connection = redisClient.connect()) {
          RedisCommands<String, String> commands = connection.sync();
          
          // Put operation (String)
          commands.set("user:123", userJson);
          
          // Put with expiration (TTL)
          commands.setex("user:123", 3600, userJson); // 1 hour in seconds
          
          // Get operation
          String userJson = commands.get("user:123");
          User user = objectMapper.readValue(userJson, User.class);
          
          // Check if key exists
          boolean exists = commands.exists("user:123") > 0;
          
          // Remove operation
          commands.del("user:123");
          
          // Clear cache (pattern)
          List<String> keys = commands.keys("user:*");
          if (!keys.isEmpty()) {
              commands.del(keys.toArray(new String[0]));
          }
      }
      ```

      JSON Serialization with Jackson for Redis:
      ```java
      // Using Jackson for JSON serialization (with Lettuce)
      ObjectMapper objectMapper = new ObjectMapper();
      
      // Serializing objects to JSON for Redis storage
      User user = new User("123", "John Doe", "john@example.com");
      String userJson = objectMapper.writeValueAsString(user);
      commands.set("user:123", userJson);
      
      // Deserializing JSON from Redis to objects
      String retrievedJson = commands.get("user:123");
      User retrievedUser = objectMapper.readValue(retrievedJson, User.class);
      
      // For collections or complex types
      List<User> users = Arrays.asList(user1, user2, user3);
      String usersJson = objectMapper.writeValueAsString(users);
      commands.set("users:department:hr", usersJson);
      
      String retrievedUsersJson = commands.get("users:department:hr");
      List<User> retrievedUsers = objectMapper.readValue(retrievedUsersJson, 
          new TypeReference<List<User>>(){});
      
    
      ```
      
      // Option 2: Using Spring's built-in serialization with Jackson (with RedisTemplate)
      // Configure the RedisTemplate with appropriate serializers
      @Bean
      public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
          RedisTemplate<String, Object> template = new RedisTemplate<>();
          template.setConnectionFactory(factory);
          
          // Option A: Using Jackson2JsonRedisSerializer (preferred for objects)
          Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = 
              new Jackson2JsonRedisSerializer<>(Object.class);
          
          // Configure ObjectMapper for Jackson serializer
          ObjectMapper om = new ObjectMapper();
          om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
          om.activateDefaultTyping(
              om.getPolymorphicTypeValidator(), 
              ObjectMapper.DefaultTyping.NON_FINAL,
              JsonTypeInfo.As.PROPERTY);
          jackson2JsonRedisSerializer.setObjectMapper(om);
          
          // Set serializers on template
          template.setKeySerializer(new StringRedisSerializer());
          template.setValueSerializer(jackson2JsonRedisSerializer);
          template.setHashKeySerializer(new StringRedisSerializer());
          template.setHashValueSerializer(jackson2JsonRedisSerializer);
          
          return template;
      }
      
      // Then use the RedisTemplate as normal - serialization happens automatically
      redisTemplate.opsForValue().set("user:123", user);
      User retrievedUser = (User) redisTemplate.opsForValue().get("user:123");
      
      Using Spring Data Redis with RedisTemplate (preferred approach for Spring applications):
      ```java
      // Using RedisTemplate (make sure it's properly configured in your Spring config)
      @Autowired
      private RedisTemplate<String, Object> redisTemplate;
      
      // Put operation
      redisTemplate.opsForValue().set("user:123", user);
      
      // Put with expiration (TTL)
      redisTemplate.opsForValue().set("user:123", user, Duration.ofSeconds(3600));
      
      // Get operation
      User user = (User) redisTemplate.opsForValue().get("user:123");
      
      // Check if key exists
      boolean exists = Boolean.TRUE.equals(redisTemplate.hasKey("user:123"));
      
      // Remove operation
      redisTemplate.delete("user:123");
      
      // Clear cache (pattern)
      Set<String> keys = redisTemplate.keys("user:*");
      if (keys != null && !keys.isEmpty()) {
          redisTemplate.delete(keys);
      }
      
      // Hash operations (useful when storing object fields)
      Map<String, Object> userMap = new HashMap<>();
      userMap.put("name", user.getName());
      userMap.put("email", user.getEmail());
      redisTemplate.opsForHash().putAll("user:123", userMap);
      
      // Get hash entry
      String name = (String) redisTemplate.opsForHash().get("user:123", "name");
      
      // Get all hash entries
      Map<Object, Object> entries = redisTemplate.opsForHash().entries("user:123");
      ```

      Using Spring Cache abstraction with Redis (simplest approach with annotations):
      ```java
      // Configure RedisCacheManager in your Spring config
      
      // Then in your service classes, use standard Spring Cache annotations
      @Cacheable(value = "userCache", key = "'user:' + #id")
      public User getUserById(String id) {
          // Method will only execute if result not in cache
          return userRepository.findById(id);
      }
      
      @CachePut(value = "userCache", key = "'user:' + #user.id")
      public User updateUser(User user) {
          // Method always executes but updates cache with result
          return userRepository.save(user);
      }
      
      @CacheEvict(value = "userCache", key = "'user:' + #id")
      public void deleteUser(String id) {
          // Removes the entry from cache
          userRepository.deleteById(id);
      }
      
      @CacheEvict(value = "userCache", allEntries = true)
      public void clearUserCache() {
          // Clears all entries from the cache
      }
      
      // For manual cache operations
      @Autowired
      private CacheManager cacheManager;
      
      public void manualCacheOperations() {
          org.springframework.cache.Cache userCache = cacheManager.getCache("userCache");
          
          // Put operation
          userCache.put("user:123", user);
          
          // Get operation
          User user = userCache.get("user:123", User.class);
          
          // Evict (remove) operation
          userCache.evict("user:123");
          
          // Clear cache
          userCache.clear();
      }
      ```

      Implementation notes:
      1. Replace Ehcache Element objects with direct key-value usage in Redis
      2. Convert Ehcache's get/getObjectValue pattern to Redis direct get operations
      3. For TTL settings on individual entries, use Redis expiration methods
      4. Use RedisTemplate for Spring applications as it provides a high-level abstraction
      5. Use Spring Cache annotations for the cleanest, most maintainable implementation
      6. When working directly with Redis (without Spring), use the Lettuce client
      7. For complex objects, consider using Hash structures in Redis for field-level access
      8. Remember to properly configure your RedisTemplate with appropriate serializers in your Spring configuration
      9. Ensure proper connection resource management, especially when using clients directly
      10. Spring Data Redis already uses Lettuce as the default client
      11. Use Jackson for JSON serialization of complex objects when storing in Redis
      12. Consider creating helper methods for consistent serialization/deserialization with Jackson
