"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatDateWithSeconds = exports.MCPOutput = exports.Mutex = exports.isJest = exports.not = exports.unique = exports.notEmpty = exports.toMap = exports.groupBy = exports.Filters = exports.kbToMarkdown = exports.detectBuildToolInRepo = exports.detectBuildEnvInRepo = exports.defaultEnvService = void 0;
exports.hashString = hashString;
exports.dedup = dedup;
exports.pick = pick;
exports.omit = omit;
exports.getConfig = getConfig;
exports.getToolsConfig = getToolsConfig;
exports.toForwardSlash = toForwardSlash;
exports.joinToForwardSlash = joinToForwardSlash;
exports.split = split;
exports.relative = relative;
exports.pathEquals = pathEquals;
exports.findFileInteratively = findFileInteratively;
exports.detectPackageJson = detectPackageJson;
exports.getAppCatInstallPath = getAppCatInstallPath;
exports.isInternal = isInternal;
exports.getFormattedTimestamp = getFormattedTimestamp;
exports.sanitizeString = sanitizeString;
exports.camelToTitleWithSpace = camelToTitleWithSpace;
exports.findParamByTypeWithIndex = findParamByTypeWithIndex;
exports.loadIgnoreFile = loadIgnoreFile;
exports.extendIfEmpty = extendIfEmpty;
exports.listDirSortedByMtime = listDirSortedByMtime;
exports.parseArg = parseArg;
exports.toMarkdown = toMarkdown;
const child_process_1 = require("child_process");
const crypto = __importStar(require("crypto"));
const fs = __importStar(require("fs"));
const os = __importStar(require("os"));
const path_1 = __importDefault(require("path"));
const which_1 = __importDefault(require("which"));
var environmentService_1 = require("./environmentService");
Object.defineProperty(exports, "defaultEnvService", { enumerable: true, get: function () { return environmentService_1.defaultEnvService; } });
var javaBuild_1 = require("./javaBuild");
Object.defineProperty(exports, "detectBuildEnvInRepo", { enumerable: true, get: function () { return javaBuild_1.detectBuildEnvInRepo; } });
Object.defineProperty(exports, "detectBuildToolInRepo", { enumerable: true, get: function () { return javaBuild_1.detectBuildToolInRepo; } });
var validationUtils_1 = require("./validationUtils");
Object.defineProperty(exports, "kbToMarkdown", { enumerable: true, get: function () { return validationUtils_1.kbToMarkdown; } });
/**
 * A utility class for combining and negating filter functions.
 */
class Filters {
    /**
     * Combines multiple filter functions using a logical AND operation.
     *
     * @template T - The type of the items to be filtered.
     * @param {...Array<(item: T) => boolean>} filters - The filter functions to combine.
     * @returns {(item: T) => boolean} A function that returns true if all the provided filters return true for the given item.
     */
    static and(...filters) {
        return (item) => filters.every((filter) => filter(item));
    }
    /**
     * Combines multiple filter functions using a logical OR operation.
     *
     * @template T - The type of the items to be filtered.
     * @param {...Array<(item: T) => boolean>} filters - The filter functions to combine.
     * @returns {(item: T) => boolean} A function that returns true if any of the provided filters return true for the given item.
     */
    static or(...filters) {
        return (item) => filters.some((filter) => filter(item));
    }
    /**
     * Negates a filter function.
     *
     * @template T - The type of the items to be filtered.
     * @param {(item: T) => boolean} filter - The filter function to negate.
     * @returns {(item: T) => boolean} A function that returns true if the provided filter returns false for the given item.
     */
    static not(filter) {
        return (item) => !filter(item);
    }
}
exports.Filters = Filters;
/**
 * Generates a hash of the given input string using the specified algorithm.
 *
 * @param {string} input - The input string to hash.
 * @param {string} [algorithm='sha256'] - The hash algorithm to use (default is 'sha256').
 * @returns {string} The resulting hash as a hexadecimal string.
 */
function hashString(input, algorithm = 'sha256') {
    // Create a hash object
    const hash = crypto.createHash(algorithm);
    // Update the hash with the input string
    hash.update(input, 'utf-8');
    // Get the hash as a hexadecimal string
    return hash.digest('hex');
}
/**
 * Groups the elements of an array by a specified key.
 *
 * @template T - The type of the elements in the array.
 * @template K - The type of the key.
 * @param {T[]} array - The array to group.
 * @param {(item: T) => K} key - A function that returns the key for each element.
 * @returns {Record<K, T[]>} An object where the keys are the group keys and the values are arrays of elements.
 */
const groupBy = (array, key) => {
    if (!array || array.length === 0) {
        return {};
    }
    return array.reduce((result, currentItem) => {
        const groupKey = key(currentItem);
        if (!result[groupKey]) {
            result[groupKey] = [];
        }
        result[groupKey].push(currentItem);
        return result;
    }, {});
};
exports.groupBy = groupBy;
/**
 * Converts an array of elements into an object where the keys are derived from a specified key function.
 *
 * @template T - The type of the elements in the array.
 * @template K - The type of the key.
 * @param {T[]} array - The array to convert.
 * @param {(item: T) => K} key - A function that returns the key for each element.
 * @returns {Record<K, T>} An object where the keys are derived from the key function and the values are the elements.
 */
const toMap = (array, key) => {
    if (!array || array.length === 0) {
        return {};
    }
    return array.reduce((result, currentItem) => {
        const groupKey = key(currentItem);
        result[groupKey] = currentItem;
        return result;
    }, {});
};
exports.toMap = toMap;
/**
 * Checks if a string is not empty.
 *
 * @param {string} [content] - The string to check.
 * @returns {boolean} True if the string is not empty, false otherwise.
 */
const notEmpty = (content) => {
    if (!content) {
        return false;
    }
    return content.length > 0;
};
exports.notEmpty = notEmpty;
/**
 * Checks if a value is unique in an array.
 *
 * @param {any} v - The value to check.
 * @param {number} i - The index of the value in the array.
 * @param {any[]} a - The array to check.
 * @returns {boolean} True if the value is unique, false otherwise.
 */
const unique = (v, i, a) => a.indexOf(v) === i;
exports.unique = unique;
/**
 * Creates a deduplication function that can be used to filter out duplicate elements from an array.
 *
 * @template T - The type of elements in the array.
 * @param compare - A comparison function that takes two elements of type T and returns a boolean indicating whether they are considered equal.
 * @returns A function that takes an element, its index, and the array, and returns a boolean indicating whether the element is unique in the array.
 */
function dedup(compare) {
    return (find, i, arr) => {
        for (let index = 0; index < arr.length; index++) {
            if (compare(find, arr[index])) {
                return index === i;
            }
        }
        return false;
    };
}
/**
 * Picks specified keys from an object.
 *
 * @template T - The type of the object.
 * @template K - The type of the keys.
 * @param {T} obj - The object to pick keys from.
 * @param {K[]} keys - The keys to pick.
 * @returns {Pick<T, K>} An object with only the picked keys.
 */
function pick(obj, keys) {
    const result = {};
    keys.forEach((key) => {
        if (key in obj) {
            result[key] = obj[key];
        }
    });
    return result;
}
/**
 * Creates a shallow copy of the given object, omitting the specified keys.
 *
 * @typeParam T - The type of the source object.
 * @typeParam K - The keys of the source object to omit.
 * @param obj - The source object from which to omit properties.
 * @param keys - An array of keys to omit from the resulting object.
 * @returns A new object with the specified keys omitted.
 */
function omit(obj, keys) {
    const result = { ...obj };
    keys.forEach((key) => {
        if (key in result) {
            delete result[key];
        }
    });
    return result;
}
/**
 * Retrieves a configuration value from the environment or a configuration file.
 *
 * @template T - The type of the configuration value.
 * @param {string} key - The key of the configuration value.
 * @param {T} defaultValue - The default value to return if the configuration value is not found.
 * @returns {T} The configuration value.
 */
function getConfig(key, defaultValue) {
    function convertValue(value) {
        if (typeof defaultValue === 'boolean') {
            if (typeof value === 'string') {
                return (value.toLowerCase() === 'true');
            }
            return Boolean(value);
        }
        if (typeof defaultValue === 'number') {
            const num = Number(value);
            return (isNaN(num) ? defaultValue : num);
        }
        return value;
    }
    if (process.env[key] !== undefined) {
        return convertValue(process.env[key]);
    }
    const configPath = path_1.default.join(__dirname, '..', 'config.json');
    if (!fs.existsSync(configPath)) {
        return defaultValue;
    }
    const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    if (config[key] === undefined) {
        return defaultValue;
    }
    return convertValue(config[key]);
}
/**
 * Loads and returns the tools configuration from the `tools.json` file.
 *
 * The configuration is expected to be a JSON object where each key is a tool name
 * and the value is a boolean indicating whether the tool is enabled.
 *
 * @returns {Record<string, boolean>} An object mapping tool names to their enabled status.
 * If the configuration file does not exist, returns an empty object.
 */
function getToolsConfig(currentPath, serverType) {
    const parsed = path_1.default.parse(currentPath);
    if (!fs.lstatSync(currentPath).isDirectory()) {
        return getToolsConfig(parsed.dir, serverType);
    }
    const pattern = /^tools(\.[^.]+)?\.json$/;
    const files = fs.readdirSync(currentPath);
    const configFiles = files.filter((file) => pattern.test(file));
    if (!configFiles || configFiles.length === 0) {
        return getToolsConfig(parsed.dir, serverType); // Recursively search in the parent directory
    }
    let fileToFind = 'tools.json';
    switch (serverType) {
        case 'dotnetMigration':
            fileToFind = 'tools.dotnet.json';
            break;
    }
    const configFile = configFiles.find((file) => file === fileToFind);
    if (!configFile) {
        throw new Error(`Could not find config file ${fileToFind} for ${serverType}`);
    }
    const config = JSON.parse(fs.readFileSync(path_1.default.join(currentPath, configFile), 'utf8'));
    return config;
}
/**
 * Negates the result of a function.
 *
 * @param {(arg: any) => boolean} fn - The function to negate.
 * @returns {(arg: any) => boolean} A function that returns the negated result of the original function.
 */
const not = (fn) => (arg) => !fn(arg);
exports.not = not;
/**
 * Converts a given path to use Linux-style separators.
 * @param inputPath The path to be converted.
 * @returns The converted path with Linux-style separators.
 */
function toForwardSlash(inputPath) {
    return inputPath.replace(/\\/g, '/');
}
/**
 * Joins multiple path segments and converts the result to use Linux-style separators.
 * @param segments The path segments to be joined.
 * @returns The joined path with Linux-style separators.
 */
function joinToForwardSlash(...segments) {
    const joinedPath = path_1.default.join(...segments);
    return toForwardSlash(joinedPath);
}
/**
 * Splits path to segments no matter it uses Linux-style or Windows-style separators.
 * @param inputPath The path to split.
 * @returns The split segments
 */
function split(inputPath) {
    return inputPath.split(/[/\\]+/).filter((segment) => segment !== '');
}
function relative(basePath, targetPath) {
    return toForwardSlash(path_1.default.relative(toForwardSlash(basePath), toForwardSlash(targetPath)));
}
function pathEquals(path1, path2) {
    return toForwardSlash(path1).toLocaleLowerCase() === toForwardSlash(path2).toLocaleLowerCase();
}
const isJest = () => !!process.env.JEST_WORKER_ID;
exports.isJest = isJest;
class Mutex {
    constructor() {
        this.mutex = Promise.resolve();
    }
    lock() {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        let begin = (unlock) => { };
        this.mutex = this.mutex.then(() => {
            return new Promise(begin);
        });
        return new Promise((res) => {
            begin = res;
        });
    }
}
exports.Mutex = Mutex;
exports.MCPOutput = {
    success: (...messages) => {
        return {
            content: [
                ...messages.map((message) => ({ type: 'text', text: message })),
                { type: 'text', text: 'remember to update the progress tracking' },
            ],
        };
    },
    structured: (structuredContent) => {
        return {
            content: [{ type: 'text', text: 'remember to update the progress tracking' }],
            structuredContent,
        };
    },
    error: (...messages) => {
        return {
            content: [
                ...messages.map((message) => ({ type: 'text', text: message })),
                { type: 'text', text: 'remember to update the progress tracking' },
            ],
            isError: true,
        };
    },
};
function findFileInteratively(currentPath, fileName) {
    if (currentPath === '/' || currentPath === '') {
        return undefined;
    }
    const filePath = path_1.default.join(currentPath, fileName);
    if (fs.existsSync(filePath)) {
        return filePath;
    }
    const parsed = path_1.default.parse(currentPath);
    if (!fs.lstatSync(currentPath).isDirectory()) {
        return findFileInteratively(parsed.dir, fileName);
    }
    return findFileInteratively(parsed.dir, fileName);
}
function detectPackageJson(currentPath) {
    const packageJsonFile = findFileInteratively(currentPath, 'package.json');
    if (!packageJsonFile) {
        return undefined;
    }
    return JSON.parse(fs.readFileSync(packageJsonFile, 'utf8'));
}
/**
 * Gets the installation path for the AppCAT CLI.
 * If the AppCAT CLI is installed, it returns the directory containing the executable.
 * If not installed, it returns a default user home path for AppCAT.
 *
 * @returns {string} The installation path for AppCAT CLI.
 */
function getAppCatInstallPath() {
    const appcatUserHomePath = path_1.default.join(os.homedir(), '.appcat');
    try {
        (0, child_process_1.execSync)('appcat version --disable-telemetry', { stdio: 'ignore' });
        const appcatEnvPath = which_1.default.sync('appcat', { nothrow: true });
        const appcatPath = appcatEnvPath ? path_1.default.dirname(appcatEnvPath) : appcatUserHomePath;
        return appcatPath;
    }
    catch (_a) {
        return appcatUserHomePath;
    }
}
function isInternal() {
    const userDomain = process.env.USERDNSDOMAIN;
    return typeof userDomain === 'string' && userDomain.endsWith('.corp.microsoft.com');
}
/**
 * Pads a number with a leading zero if it is less than 10.
 *
 * @param {number} num - The number to pad.
 * @returns {string} The padded number as a string.
 */
const padZero = (num) => (num < 10 ? `0${num}` : `${num}`);
function getFormattedTimestamp() {
    const date = new Date();
    const year = date.getFullYear();
    const month = padZero(date.getMonth() + 1);
    const day = padZero(date.getDate());
    const hours = padZero(date.getHours());
    const minutes = padZero(date.getMinutes());
    const seconds = padZero(date.getSeconds());
    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
}
/**
 * Formats a date as a simple string in the format YYYYMMDDHHMMSS.
 *
 * @param {Date} date - The date to format.
 * @returns {string} The formatted date string including seconds.
 */
const formatDateWithSeconds = (date) => {
    const year = date.getFullYear();
    const month = padZero(date.getMonth() + 1);
    const day = padZero(date.getDate());
    const hours = padZero(date.getHours());
    const minutes = padZero(date.getMinutes());
    const seconds = padZero(date.getSeconds());
    return `${year}${month}${day}${hours}${minutes}${seconds}`;
};
exports.formatDateWithSeconds = formatDateWithSeconds;
function sanitizeString(input) {
    // Replace any characters that are not alphanumeric, hyphen, or underscore with a hyphen
    return input.replace(/[^a-zA-Z0-9-_]/g, '_').toLowerCase();
}
function camelToTitleWithSpace(str) {
    // Insert a space before each capital letter (except the first)
    const withSpaces = str.replace(/([a-z])([A-Z])/g, '$1 $2');
    // Capitalize each word
    return withSpaces.replace(/\b\w/g, (c) => c.toUpperCase());
}
function findParamByTypeWithIndex(args, filter) {
    return args.map((value, index) => ({ index, value })).find((item) => filter(item.value));
}
function loadIgnoreFile(filePath) {
    if (fs.existsSync(filePath)) {
        return fs
            .readFileSync(filePath, 'utf8')
            .split(/\r?\n/)
            .filter((line) => line.trim() && !line.startsWith('#'));
    }
    return [];
}
function extendIfEmpty(child, parent, keys) {
    if (!child || !parent) {
        return child;
    }
    keys.forEach((key) => {
        // Only assign from parent if child[key] is nullish (null or undefined or empty string)
        if (child[key] === undefined ||
            child[key] === null ||
            (typeof child[key] === 'string' && child[key].trim() === '')) {
            child[key] = parent[key];
        }
    });
    return child;
}
/**
 * List files in a directory sorted by modification time (newest first)
 * Works on Linux, macOS, and Windows
 */
function listDirSortedByMtime(dirPath) {
    if (!fs.existsSync(dirPath)) {
        return [];
    }
    // Read directory entries
    const files = fs.readdirSync(dirPath, { withFileTypes: true });
    // Map to objects with mtime
    const fileStats = files
        .filter((file) => file.isDirectory())
        .map((file) => {
        const fullPath = path_1.default.join(dirPath, file.name);
        const stats = fs.statSync(fullPath);
        return {
            name: file.name,
            mtime: stats.mtime,
        };
    });
    // Sort by mtime descending (newest first)
    fileStats.sort((a, b) => b.mtime.getTime() - a.mtime.getTime());
    return fileStats;
}
function parseArg(argKey) {
    const args = process.argv.slice(2);
    const index = args.indexOf(argKey);
    return index !== -1 && index + 1 < args.length ? args[index + 1] : undefined;
}
function toMarkdown(error) {
    var _a;
    if (!error.raw) {
        return escapeMarkdown(error.errorMessage).replace(/\n/g, ' ');
    }
    return `
${escapeMarkdown((_a = error.errorMessage) !== null && _a !== void 0 ? _a : error.raw.split('\n')[0] + '...').replace(/\n/g, ' ')}
  \`\`\`
${addIndent(escapeMarkdown(error.raw), '  ')}
  \`\`\``.trim();
}
function addIndent(text, indent) {
    if (!text) {
        return '';
    }
    const lines = text.split('\n');
    const indentedLines = lines.map((line) => `${indent}${line}`);
    return indentedLines.join('\n');
}
function escapeMarkdown(text) {
    if (!text) {
        return '';
    }
    // escape special characters
    return text.replace(/([*_`~<>])/g, '\\$1');
}
//# sourceMappingURL=index.js.map