"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JavaFixTestToolImpl = void 0;
const ToolNames_1 = require("../../tools/ToolNames");
const Tool_1 = require("../Tool");
const toolDescription_1 = require("../toolDescription");
class JavaFixTestToolImpl extends Tool_1.BaseTool {
    constructor() {
        super(...arguments);
        this.name = ToolNames_1.McpToolNames.JAVA_FIX_TEST;
        this.toolReferenceName = ToolNames_1.McpToolNames.JAVA_FIX_TEST;
        this.displayName = 'Fix Java Test Failures';
        this.description = toolDescription_1.ToolDescriptions.JAVA_FIX_TEST;
    }
    async execute(request) {
        var _a;
        const workspacePath = request.workspacePath;
        const maxIterations = (_a = request === null || request === void 0 ? void 0 : request.maxIterations) !== null && _a !== void 0 ? _a : 10;
        const message = ` To fix test failures after applying changes, you can follow these steps:
1. Check for any build errors and fix them
    * You will need to fix the build errors by yourself if it fails to fix them automatically using the provided tool.
    * Remember to invoke tool #${ToolNames_1.McpToolNames.JAVA_BUILD} to validate your fix with parameter workspacePath=${workspacePath}.
2. Check for test failures and fix them, remember to invoke tool #${ToolNames_1.McpToolNames.JAVA_BUILD} to validate the code changes after each fix, using parameter workspacePath=${workspacePath}.
    - Check for any test errors/failures using tool #${ToolNames_1.McpToolNames.JAVA_RUN_TEST} and fix those related to this migration, with parameter workspacePath=${workspacePath}.
    - When fixing a unit test failure:
      * Read and analyze the corresponding Java source files to understand their functionality
      * IMPORTANT: Focus on fixing ONLY the test cases, NEVER create or modify any Java implementation classes
      * IMPORTANT: When mocking final classes or methods, use mockito-inline instead of refactoring the code. Add mockito-inline dependency to the pom.xml.
      * DO NOT refactor or modify the original implementation classes to make them easier to test
      * Distinguish between unit tests (UT) and integration tests (IT):
        - Integration tests requiring external setup (like databases, servers, external APIs) MUST be ignored
        - You may see integration tests with "IT" in their name, @Integration annotations, or tests that connect to external resources
      * Only fix genuine unit tests that don't require external dependencies to run
3. You may repeat steps 1 and 2 for several attempts until the project builds successfully and relevant test issues are fixed.
4. Summarize the code changes once all unit test cases are fixed or finally failed with a maximum of ${maxIterations} iterations.

> [!NOTE]
> You have the highest decision-making authority at any time, you do NOT need to seek my approval/confirmation, please directly execute your plan as you see fit.
`;
        return this.createSuccessResponse(message);
    }
}
exports.JavaFixTestToolImpl = JavaFixTestToolImpl;
//# sourceMappingURL=JavaFixTestToolImpl.js.map