"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstallAppCatToolImpl = void 0;
const fs = __importStar(require("fs"));
const fs_extra_1 = require("fs-extra");
const node_stream_zip_1 = __importDefault(require("node-stream-zip"));
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const stream_1 = require("stream");
const tar = __importStar(require("tar"));
const tsyringe_1 = require("tsyringe");
const util_1 = require("util");
const ToolNames_1 = require("../../tools/ToolNames");
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const Tool_1 = require("../Tool");
const toolDescription_1 = require("../toolDescription");
class InstallAppCatToolImpl extends Tool_1.BaseTool {
    constructor() {
        super(...arguments);
        this.name = ToolNames_1.McpToolNames.INSTALL_APPCAT;
        this.toolReferenceName = ToolNames_1.McpToolNames.INSTALL_APPCAT;
        this.displayName = 'Install AppCAT';
        this.description = toolDescription_1.ToolDescriptions.INSTALL_APPCAT;
    }
    async execute(request, context) {
        var _a;
        const start = Date.now();
        const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
        const appcatInstallPath = (0, utils_1.getAppCatInstallPath)();
        const platform = os.platform() === 'win32' ? 'windows' : os.platform() === 'darwin' ? 'macos' : 'linux';
        const arch = os.arch() === 'x64' ? 'amd64' : 'arm64';
        const ext = platform === 'windows' ? 'zip' : 'tar.gz';
        const downloadUrl = `https://aka.ms/appcat/azure-migrate-appcat-for-java-cli-${platform}-${arch}.${ext}`;
        const randomSuffix = Math.random().toString(36).substring(2, 15);
        const tempPath = path.join(os.tmpdir(), `appcat-compressed-${randomSuffix}`);
        const maxRetries = 5;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            if ((_a = context === null || context === void 0 ? void 0 : context.signal) === null || _a === void 0 ? void 0 : _a.aborted) {
                logger.warn('Install AppCAT: Operation aborted by context signal');
                return this.createErrorResponse('Operation aborted');
            }
            try {
                await (0, fs_extra_1.ensureDir)(tempPath);
                logger.info(`Install AppCAT: Downloading AppCAT from ${downloadUrl} to ${tempPath}`);
                await downloadFile(downloadUrl, path.join(tempPath, `appcat.${ext}`));
                logger.info(`Install AppCAT: Extracting AppCAT to ${appcatInstallPath}`);
                await extractFile(path.join(tempPath, `appcat.${ext}`), appcatInstallPath, ext);
                logger.info(`Install AppCAT: AppCAT installation completed.`);
                await sendTelemetryWhenAppCatInstall('success', undefined, Date.now() - start);
                return this.createSuccessResponse(`Install latest version of AppCAT successfully!\n\nNext Step: proceed to initialize the Java application assessment process for Azure migration readiness using tool #${ToolNames_1.McpToolNames.PRECHECK_ASSESSMENT}. No user confirmation is required - proceed to automatically call the tool directly.`);
            }
            catch (error) {
                logger.error(`Install AppCAT: Error during installation: ${error}`);
                if (error.message) {
                    logger.error(`Error message: ${error.message}`);
                }
                if (error.cause) {
                    logger.error(`Error cause: ${error.cause}`);
                }
                if (error.stack) {
                    logger.error(`Error stack: ${error.stack}`);
                }
                if (attempt < maxRetries) {
                    logger.warn(`Install AppCAT: Retrying attempt ${attempt}...`);
                    await new Promise((r) => setTimeout(r, attempt * 200));
                }
                else {
                    await sendTelemetryWhenAppCatInstall('fail', error, Date.now() - start);
                    return this.createErrorResponse(`Error during installing AppCAT: ${error.message}`);
                }
            }
            finally {
                logger.info(`Install AppCAT: Cleaning up temporary files`);
                await (0, fs_extra_1.remove)(tempPath);
            }
        }
        return this.createErrorResponse('Install AppCAT: Installation failed after all retry attempts');
    }
}
exports.InstallAppCatToolImpl = InstallAppCatToolImpl;
const streamPipeline = (0, util_1.promisify)(stream_1.pipeline);
async function downloadFile(url, dest) {
    const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
    const res = await fetch(url);
    if (!res.ok) {
        const errorMessage = `Failed to download AppCAT from ${url}. Status: ${res.status}, Error: ${res.statusText}`;
        throw new Error(errorMessage);
    }
    const contentLength = res.headers.get('content-length');
    const total = contentLength ? parseInt(contentLength, 10) : 0;
    let loaded = 0;
    let nodeStream = null;
    if (res.body && typeof res.body.getReader === 'function') {
        // Web stream, convert to Node.js Readable
        nodeStream = stream_1.Readable.fromWeb(res.body);
    }
    else if (res.body) {
        // Node.js Readable
        nodeStream = res.body;
    }
    if (!nodeStream) {
        throw new Error('Response body is null or not a readable stream');
    }
    const passThrough = new stream_1.PassThrough();
    nodeStream.on('data', (chunk) => {
        loaded += chunk.length;
        const mb = (loaded / 1024 / 1024).toFixed(2);
        if (total > 0) {
            const percent = (loaded / total) * 100;
            logger.debug(`Downloading AppCAT for Java ${mb} MB (${Math.floor(percent)}%)`);
        }
        else {
            logger.debug(`Downloading AppCAT for Java ${mb} MB`);
        }
    });
    nodeStream.pipe(passThrough);
    await streamPipeline(passThrough, fs.createWriteStream(dest));
}
async function extractFile(src, dest, ext) {
    const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
    // avoid extracting into an existing folder
    if (await (0, fs_extra_1.exists)(dest)) {
        logger.info(`Install AppCAT: Removing existing directory at ${dest}`);
        await (0, fs_extra_1.remove)(dest);
    }
    // make sure dest directory exists
    await (0, fs_extra_1.mkdir)(dest);
    if (ext === 'tar.gz') {
        await extractTarGz(src, dest);
    }
    else if (ext === 'zip') {
        await extractZip(src, dest);
    }
    else {
        logger.error(`Install AppCAT: Unsupported file extension: ${ext}`);
    }
    // defensive validation: check appcat binary
    const binaryName = os.platform() === 'win32' ? 'appcat.exe' : 'appcat';
    const binaryPath = path.join(dest, binaryName);
    try {
        await (0, fs_extra_1.access)(binaryPath);
        logger.info(`Install AppCAT: Verified binary exists at ${binaryPath}`);
    }
    catch (_a) {
        throw new Error(`Install AppCAT: Expected binary ${binaryName} not found in ${dest}`);
    }
}
async function extractTarGz(src, dest) {
    await tar.x({ file: src, C: dest, strip: 2 });
}
async function extractZip(src, dest) {
    const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
    const zip = new node_stream_zip_1.default.async({ file: src, storeEntries: true });
    try {
        const entries = await zip.entries();
        const entryNames = Object.keys(entries)
            .filter((name) => entries[name].isDirectory)
            .sort((a, b) => a.length - b.length);
        // shortest directory entry is the top-level directory
        const topLevelEntry = entryNames[0];
        logger.info(`Install AppCAT: Extracting zip entry ${topLevelEntry} to ${dest}`);
        await zip.extract(topLevelEntry, dest);
    }
    finally {
        await zip.close();
    }
}
async function sendTelemetryWhenAppCatInstall(result, error, duration) {
    const eventEmitter = tsyringe_1.container.resolve(types_1.Beans.McpEventEmitter);
    if (result === 'success') {
        eventEmitter.emit('appcat_install_success', { duration: duration || 0 });
    }
    else {
        eventEmitter.emit('appcat_install_fail', {
            error: error || new Error('Unknown error'),
            duration: duration || 0,
        });
    }
}
//# sourceMappingURL=InstallAppCatToolImpl.js.map