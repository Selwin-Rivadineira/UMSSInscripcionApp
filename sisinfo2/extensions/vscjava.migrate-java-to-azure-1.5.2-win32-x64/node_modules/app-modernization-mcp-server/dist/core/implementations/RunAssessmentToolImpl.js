"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunAssessmentToolImpl = void 0;
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const fs_extra_1 = require("fs-extra");
const path_1 = __importDefault(require("path"));
const tsyringe_1 = require("tsyringe");
const ToolNames_1 = require("../../tools/ToolNames");
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const Tool_1 = require("../Tool");
const toolDescription_1 = require("../toolDescription");
const PrecheckAssessmentToolImpl_1 = require("./PrecheckAssessmentToolImpl");
const enableKbAssessment = false;
const cancelCode = '130';
class RunAssessmentToolImpl extends Tool_1.BaseTool {
    constructor() {
        super(...arguments);
        this.name = ToolNames_1.McpToolNames.RUN_ASSESSMENT;
        this.toolReferenceName = ToolNames_1.McpToolNames.RUN_ASSESSMENT;
        this.displayName = 'Run Assessment';
        this.description = toolDescription_1.ToolDescriptions.RUN_ASSESSMENT;
    }
    async execute(request, context) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const start = Date.now();
        const abortSignal = context === null || context === void 0 ? void 0 : context.signal;
        try {
            const workspacePath = request.workspacePath;
            const configPath = path_1.default.join(workspacePath, PrecheckAssessmentToolImpl_1.APPCAT_DIR, PrecheckAssessmentToolImpl_1.ASSESSMENT_CONFIG);
            const assessmentConfig = await (0, PrecheckAssessmentToolImpl_1.loadAssessmentConfig)(configPath);
            // Validate AppCAT configuration with dry-run
            const validationResult = await validateAppCatConfig(workspacePath, assessmentConfig, abortSignal);
            if (!validationResult.success) {
                let logOutput = '';
                const logFilePath = path_1.default.join(workspacePath, PrecheckAssessmentToolImpl_1.APPCAT_DIR, PrecheckAssessmentToolImpl_1.APPCAT_LOG);
                if (await (0, fs_extra_1.exists)(logFilePath)) {
                    logOutput = await (0, fs_extra_1.readFile)(logFilePath, 'utf8');
                }
                await sendTelemetryWhenAppCatScan('fail', new Error(`Assessment command validation failed:\n\n${logOutput}.`), ((_a = validationResult.error) === null || _a === void 0 ? void 0 : _a.exitCode) || '', Date.now() - start);
                return this.createErrorResponse(`Assessment command validation failed with exit code ${(_b = validationResult.error) === null || _b === void 0 ? void 0 : _b.exitCode}:\n\n${logOutput}\n\n${(_c = validationResult.error) === null || _c === void 0 ? void 0 : _c.errorMessage}.`);
            }
            // Run AppCAT assessment
            const assessmentResult = await runAppCatAssessment(workspacePath, assessmentConfig, abortSignal, context);
            if (!assessmentResult.success) {
                await sendTelemetryWhenAppCatScan('fail', new Error(((_d = assessmentResult.error) === null || _d === void 0 ? void 0 : _d.errorMessage) ||
                    'Assessment command execution failed.'), ((_e = assessmentResult.error) === null || _e === void 0 ? void 0 : _e.exitCode) || '', Date.now() - start);
                return this.createErrorResponse(`Assessment command execution failed with exit code ${(_f = assessmentResult.error) === null || _f === void 0 ? void 0 : _f.exitCode}:\n\n${(_g = assessmentResult.error) === null || _g === void 0 ? void 0 : _g.errorMessage}`);
            }
            await ((_h = context === null || context === void 0 ? void 0 : context.reportProgress) === null || _h === void 0 ? void 0 : _h.call(context, 'Assessment completed successfully!', 100));
            await sendTelemetryWhenAppCatScan('success', undefined, '', Date.now() - start);
            const responseMessage = enableKbAssessment
                ? `AppCAT Assessment completed successfully!\n\nNext Step: use tool \`#${ToolNames_1.McpToolNames.KB_ASSESSMENT}\` to proceed to the next assessment stage.`
                : `Assessment completed successfully!\n\nNext Step: Automatically use tool \`#${ToolNames_1.VscodeToolNames.OpenAssessmentReport}\` to open the assessment report webview interface to display detailed migration assessment results, including identified issues, recommendations, and Azure readiness analysis. No user confirmation is required - proceed to open the report directly.`;
            return this.createSuccessResponse(responseMessage);
        }
        catch (error) {
            const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
            logger.error(`Error during migration assessment: ${error}`);
            await sendTelemetryWhenAppCatScan('fail', new Error(`Error during run assessment: ${error.message}`), error.status || '', Date.now() - start);
            return this.createErrorResponse(`Error during assessment: ${error.message}`);
        }
    }
}
exports.RunAssessmentToolImpl = RunAssessmentToolImpl;
async function validateAppCatConfig(workspacePath, config, abortSignal) {
    return await executeAppCatCommand(workspacePath, config, true, abortSignal);
}
async function runAppCatAssessment(workspacePath, config, abortSignal, context) {
    return await executeAppCatCommand(workspacePath, config, false, abortSignal, context);
}
async function executeAppCatCommand(workspacePath, config, dryRun, abortSignal, context) {
    const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
    const settings = tsyringe_1.container.resolve(types_1.Beans.Settings);
    const target = config.appcat[0].target.join(',');
    const mode = config.appcat[0].mode;
    const logPath = path_1.default.join(workspacePath, PrecheckAssessmentToolImpl_1.APPCAT_DIR, 'appcat.log');
    const outputPath = path_1.default.join(workspacePath, PrecheckAssessmentToolImpl_1.APPCAT_DIR, 'result');
    // Ensure output directory exists
    if (!(await (0, fs_extra_1.exists)(outputPath))) {
        await (0, fs_extra_1.mkdir)(outputPath, { recursive: true });
    }
    const appcatInstallPath = (0, utils_1.getAppCatInstallPath)();
    const appcatAbsolutionPathCommand = path_1.default.join(appcatInstallPath, 'appcat');
    // Build arguments array for spawn
    const args = [
        'analyze',
        '--input',
        workspacePath,
        '--output',
        outputPath,
        '--target',
        target,
        '--mode',
        mode,
        '--overwrite',
        '--exclude-paths',
        path_1.default.join(workspacePath, PrecheckAssessmentToolImpl_1.APPMOD_DIR),
        '--output-format',
        'json',
        '--skip-static-report',
        '--code-snips-number',
        '-1',
        ...(settings.isTelemetryDisabled() ? ['--disable-telemetry'] : []),
        ...(settings.getCallerMachineId()
            ? ['--vscode-machine-id', settings.getCallerMachineId()]
            : []),
        ...(settings.getCallerSessionId() ? ['--session-id', settings.getCallerSessionId()] : []),
        ...(settings.getCallerId() ? ['--caller-id', settings.getCallerId()] : []),
        ...(dryRun ? ['--dry-run'] : []),
    ];
    logger.info(`Executing AppCAT command: ${appcatAbsolutionPathCommand} ${args.join(' ')}`);
    return new Promise((resolve) => {
        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
            resolve(createCancelledResult());
            return;
        }
        try {
            const child = (0, child_process_1.spawn)(appcatAbsolutionPathCommand, args, {
                stdio: ['pipe', 'pipe', 'pipe'],
            });
            logger.info(`AppCAT process started with PID: ${child.pid}`);
            const processState = {
                stdout: '',
                stderr: '',
                wasManuallyTerminated: false,
                logStream: fs.createWriteStream(logPath, { flags: 'w' }),
                progressReporter: context === undefined ? undefined : new ProgressReporter(context),
            };
            setupProcessStreams(child, processState);
            const abortHandler = createAbortHandler(child, logger, processState);
            manageAbortHandling(abortSignal, abortHandler, 'setup');
            child.on('close', (code, signal) => {
                handleProcessClose(code, signal, processState, abortSignal, abortHandler, resolve);
            });
            child.on('error', (error) => {
                handleProcessError(error, processState, abortSignal, abortHandler, resolve);
            });
        }
        catch (error) {
            resolve({
                success: false,
                error: {
                    errorMessage: `AppCAT run failed: ${error.message}`,
                    exitCode: error.status || 'ERROR',
                },
            });
        }
    });
}
// Progress tracking for AppCAT assessment
class ProgressReporter {
    constructor(context) {
        this.isCompleted = false;
        this.context = context;
    }
    async processOutput(output) {
        var _a;
        if (!((_a = this.context) === null || _a === void 0 ? void 0 : _a.reportProgress) || this.isCompleted) {
            return;
        }
        try {
            // Parse AppCAT output for progress indicators
            const lines = output.split('\n');
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (!trimmedLine)
                    continue;
                await this.analyzeProgressFromLine(trimmedLine);
            }
        }
        catch (_b) {
            // Silently ignore progress parsing errors to not interfere with main execution
        }
    }
    async analyzeProgressFromLine(line) {
        var _a, _b;
        const progressPattern = /\[(\d+)\/(\d+)\]/;
        const progressMessage = 'Running Assessment: ';
        const hint = 'This may take a while to complete.';
        const match = line.match(progressPattern);
        if (match) {
            const current = Number(match[1]);
            const total = Number(match[2]);
            const percentage = total > 0 ? (current / total) * 100 : 0;
            const formattedPercentage = `${percentage.toFixed(2)}%`;
            await ((_b = (_a = this.context) === null || _a === void 0 ? void 0 : _a.reportProgress) === null || _b === void 0 ? void 0 : _b.call(_a, `${progressMessage}${formattedPercentage}. ${hint}`, percentage));
        }
    }
    async markCompleted() {
        var _a;
        if (((_a = this.context) === null || _a === void 0 ? void 0 : _a.reportProgress) && !this.isCompleted) {
            this.isCompleted = true;
            await this.context.reportProgress('Assessment processing completed!', 99.99);
        }
    }
}
// Helper functions for process management
function createCancelledResult() {
    return {
        success: false,
        error: {
            errorMessage: 'Operation was cancelled before appcat could start',
            exitCode: cancelCode,
        },
    };
}
function setupProcessStreams(child, processState) {
    var _a, _b;
    (_a = child.stdout) === null || _a === void 0 ? void 0 : _a.on('data', async (data) => {
        const output = data.toString('utf-8');
        processState.stdout += output;
        processState.logStream.write(output);
        if (processState.progressReporter) {
            await processState.progressReporter.processOutput(output);
        }
    });
    (_b = child.stderr) === null || _b === void 0 ? void 0 : _b.on('data', async (data) => {
        const output = data.toString('utf-8');
        processState.stderr += output;
        processState.logStream.write(output);
        if (processState.progressReporter) {
            await processState.progressReporter.processOutput(output);
        }
    });
}
function terminateProcessOnWindows(child, logger) {
    logger.info('Windows detected: Using taskkill to terminate process tree');
    try {
        // /T terminates process tree, /F forces termination
        (0, child_process_1.execSync)(`taskkill /PID ${child.pid} /T /F`, { stdio: 'ignore' });
        logger.info('Process tree terminated successfully');
    }
    catch (error) {
        logger.info(`taskkill failed, using SIGKILL: ${error}`);
        child.kill('SIGKILL');
    }
}
function terminateProcessOnUnix(child, logger) {
    // On Unix, send two SIGINT signals as AppCAT CLI expects (equivalent to two Ctrl+C)
    logger.info('Unix detected: Sending first SIGINT (first Ctrl+C)');
    child.kill('SIGINT');
    setTimeout(() => {
        if (child.exitCode === null && child.signalCode === null) {
            logger.info('Sending second SIGINT (second Ctrl+C to force AppCAT exit)');
            child.kill('SIGINT');
        }
    }, 500);
}
function createAbortHandler(child, logger, processState) {
    return () => {
        logger.info('AppCAT command cancelled by user');
        processState.wasManuallyTerminated = true;
        const isWindows = process.platform === 'win32';
        if (isWindows) {
            terminateProcessOnWindows(child, logger);
        }
        else {
            terminateProcessOnUnix(child, logger);
        }
    };
}
function manageAbortHandling(abortSignal, abortHandler, action) {
    if (!abortSignal) {
        return;
    }
    if (typeof abortSignal.addEventListener === 'function') {
        if (action === 'setup') {
            abortSignal.addEventListener('abort', abortHandler);
        }
        else {
            abortSignal.removeEventListener('abort', abortHandler);
        }
    }
    else if ('onabort' in abortSignal) {
        abortSignal.onabort = action === 'setup' ? abortHandler : null;
    }
}
function handleProcessClose(code, signal, processState, abortSignal, abortHandler, resolve) {
    const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
    logger.info(`AppCAT process closed with code: ${code}, signal: ${signal}, wasManuallyTerminated: ${processState.wasManuallyTerminated}`);
    if (processState.progressReporter) {
        processState.progressReporter.markCompleted();
    }
    // Close log stream and cleanup
    processState.logStream.end();
    manageAbortHandling(abortSignal, abortHandler, 'cleanup');
    if (code === 0) {
        resolve({
            success: true,
            error: null,
        });
        return;
    }
    // Handle error cases
    const exitCode = (code === null || code === void 0 ? void 0 : code.toString()) || 'Unknown';
    const isCancelled = processState.wasManuallyTerminated || (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted);
    // For telemetry purposes, if it was manually terminated, use '130' as exit code
    const telemetryExitCode = processState.wasManuallyTerminated ? cancelCode : exitCode;
    const errorMessage = isCancelled
        ? `AppCAT command was cancelled by user (exit code ${telemetryExitCode})`
        : `AppCAT run failed with exit code ${telemetryExitCode}: ${processState.stderr || processState.stdout}`;
    resolve({
        success: false,
        error: {
            errorMessage,
            exitCode: telemetryExitCode,
        },
    });
}
function handleProcessError(error, processState, abortSignal, abortHandler, resolve) {
    // Close log stream and cleanup
    processState.logStream.end();
    manageAbortHandling(abortSignal, abortHandler, 'cleanup');
    resolve({
        success: false,
        error: {
            errorMessage: `AppCAT run failed: ${error.message}`,
            exitCode: 'ERROR',
        },
    });
}
async function sendTelemetryWhenAppCatScan(result, error, exitCode, duration) {
    const eventEmitter = tsyringe_1.container.resolve(types_1.Beans.McpEventEmitter);
    if (result === 'success') {
        eventEmitter.emit('appcat_scan_success', {
            duration: duration || 0,
        });
    }
    else {
        eventEmitter.emit('appcat_scan_fail', {
            error: error || new Error('Unknown error'),
            duration: duration || 0,
            exitCode: exitCode || '',
        });
    }
}
//# sourceMappingURL=RunAssessmentToolImpl.js.map