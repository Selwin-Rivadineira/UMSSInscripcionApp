"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrecheckAssessmentToolImpl = exports.ASSESSMENT_PLAN = exports.ASSESSMENT_CONFIG = exports.APPCAT_LOG = exports.APPCAT_DIR = exports.APPMOD_DIR = exports.APPCAT_MINIMAL_VERSION = void 0;
exports.loadAssessmentConfig = loadAssessmentConfig;
exports.saveAssessmentConfig = saveAssessmentConfig;
exports.sendTelemetryWhenAppCatCheck = sendTelemetryWhenAppCatCheck;
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const fs_extra_1 = require("fs-extra");
const glob_1 = require("glob");
const yaml = __importStar(require("js-yaml"));
const path_1 = __importDefault(require("path"));
const tsyringe_1 = require("tsyringe");
const ToolNames_1 = require("../../tools/ToolNames");
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const Tool_1 = require("../Tool");
const toolDescription_1 = require("../toolDescription");
exports.APPCAT_MINIMAL_VERSION = '7.7.0.2';
exports.APPMOD_DIR = path_1.default.join('.github', 'appmod-java');
exports.APPCAT_DIR = path_1.default.join(exports.APPMOD_DIR, 'appcat');
exports.APPCAT_LOG = 'appcat.log';
exports.ASSESSMENT_CONFIG = 'assessment-config.yaml';
exports.ASSESSMENT_PLAN = 'assessment-plan.md';
// Global variables to track state for telemetry
let workspacePathExists = 'N/A';
let isJavaProject = 'N/A';
let projectLanguages = 'N/A';
let appCatVersion = 'N/A';
class PrecheckAssessmentToolImpl extends Tool_1.BaseTool {
    constructor() {
        super(...arguments);
        this.name = ToolNames_1.McpToolNames.PRECHECK_ASSESSMENT;
        this.toolReferenceName = ToolNames_1.McpToolNames.PRECHECK_ASSESSMENT;
        this.displayName = 'Precheck Assessment';
        this.description = toolDescription_1.ToolDescriptions.PRECHECK_ASSESSMENT;
    }
    async execute(request, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    context) {
        try {
            const workspacePath = request.workspacePath;
            // Validate workspace exists
            if (!fs.existsSync(workspacePath)) {
                workspacePathExists = 'false';
                await sendTelemetryWhenAppCatCheck('fail', new Error(`Workspace path does not exist: ${workspacePath}`), workspacePathExists);
                return this.createErrorResponse(`Workspace path does not exist: ${workspacePath}`);
            }
            workspacePathExists = 'true';
            // Check prerequisites
            const prerequisiteCheck = await checkPrerequisites(workspacePath);
            if (!prerequisiteCheck.valid) {
                return this.createErrorResponse(prerequisiteCheck.message);
            }
            // Install AppCAT if not found or too low version
            const appCatCheck = await checkOrInstallAppCat();
            if (!appCatCheck.valid) {
                // return success with message to install AppCAT
                return this.createSuccessResponse(appCatCheck.message);
            }
            await sendTelemetryWhenAppCatCheck('success', undefined, workspacePathExists, isJavaProject, projectLanguages, appCatVersion);
            await createGitIgnoreFile(path_1.default.join(workspacePath, exports.APPCAT_DIR));
            const configPath = path_1.default.join(workspacePath, exports.APPCAT_DIR, exports.ASSESSMENT_CONFIG);
            const assessmentConfig = await loadAssessmentConfig(configPath);
            await saveAssessmentConfig(configPath, assessmentConfig);
            const planPath = path_1.default.join(workspacePath, exports.APPCAT_DIR, exports.ASSESSMENT_PLAN);
            await displayAssessmentPlan(workspacePath, planPath, assessmentConfig);
            // Delete existing appcat.log file if it exists
            const appCatLogFile = path_1.default.join(workspacePath, exports.APPCAT_DIR, exports.APPCAT_LOG);
            if (fs.existsSync(appCatLogFile)) {
                fs.unlinkSync(appCatLogFile);
            }
            const message = getResponseMessage(workspacePath);
            return this.createSuccessResponse(message);
        }
        catch (error) {
            const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
            logger.error(`Error during precheck assessment: ${error}`);
            await sendTelemetryWhenAppCatCheck('fail', new Error(`Error during precheck assessment: ${error.message}`), workspacePathExists, isJavaProject, projectLanguages, appCatVersion);
            return this.createErrorResponse(`Error during precheck assessment: ${error.message}`);
        }
    }
}
exports.PrecheckAssessmentToolImpl = PrecheckAssessmentToolImpl;
function getResponseMessage(workspacePath) {
    return `
You are tasked with assessing this Java project for Azure migration readiness using the AppCAT CLI. The objective is to identify modernization opportunities, detect migration blockers, and generate actionable recommendations for transitioning the application to Azure services such as Azure Kubernetes Service (AKS), Azure App Service, or Azure Container Apps.

## Execution Process (Strict Order Required)

You must execute the following steps in the exact sequence listed below without reordering, skipping, or combining them:

1. **Open and display the Markdown Preview of the Assessment Plan** located at: ${path_1.default.join(workspacePath, exports.APPCAT_DIR, exports.ASSESSMENT_PLAN)}.
    - Render the file in full **Markdown Preview** mode, preserving formatting exactly as written.
    - Open it using \`#${ToolNames_1.VscodeToolNames.PreviewMarkdown}\` to ensure proper formatting and readability.
    - It must appear in your response verbatim with no changes, additions, or omissions.

2. **Create and open the log file** named ${exports.APPCAT_LOG} at: ${path_1.default.join(workspacePath, exports.APPCAT_DIR)}.
    - Create the file with empty content.
    - Immediately open and display the file content (showing it as empty).
    - This file must be visible to the user before Step 3 begins.

3. **Run the AppCAT CLI assessment** by invoking the tool \`#${ToolNames_1.McpToolNames.RUN_ASSESSMENT}\`.
    - This performs static analysis on the Java application to assess migration readiness.
    - Do not start this tool until Step 2 has been completed and shown to the user.

4. **Open the assessment report** by invoking the tool \`#${ToolNames_1.VscodeToolNames.OpenAssessmentReport}\`.
    - This must occur immediately after Step 3 completes.
    - Its purpose is to refresh the assessment view and display the generated report to the user.
    - Do not run this tool before Step 3 has fully finished.

## Success Criteria

To consider this execution successful, the following must occur:

- The **Markdown Preview** of the assessment plan is shown verbatim.
- The appcat.log file is created, then immediately opened and displayed with empty content.
- \`#${ToolNames_1.McpToolNames.RUN_ASSESSMENT}\` runs only after Step 2 is complete.
- \`#${ToolNames_1.VscodeToolNames.OpenAssessmentReport}\` runs only after Step 3 has completed.
- All steps are executed in the above order without skipping, reordering, or combining.

## Execution Behavior Requirement

- The entire process must run in a **single, uninterrupted execution**.
- Treat the process as **non-interactive**, with tools invoked only in the strict order defined above.
`;
}
async function checkPrerequisites(workspacePath) {
    let valid = true;
    let message = '';
    // Check if it's a Java project
    const { isJava, languages } = await checkIfJavaProject(workspacePath);
    isJavaProject = isJava ? 'true' : 'false';
    projectLanguages = languages.join(', ');
    if (!isJava) {
        message += `The current workspace is not a Java project. Detected languages: ${languages.join(', ')}. Please open a Java project to run the assessment.\n\n`;
        valid = false;
        await sendTelemetryWhenAppCatCheck('fail', new Error(`The current workspace is not a Java project. Detected languages: ${languages.join(', ')}.`), workspacePathExists, isJavaProject, projectLanguages);
    }
    return { valid, message };
}
async function checkIfJavaProject(workspacePath) {
    const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
    try {
        const options = {
            cwd: workspacePath,
            absolute: true,
            ignore: [
                '**/node_modules/**',
                '**/target/**',
                '**/build/**',
                '**/out/**',
                '**/dist/**',
                '**/bin/**',
                '**/__pycache__/**',
                '**/obj/**',
                '**/Debug/**',
                '**/Release/**',
                '**/vendor/**',
                '**/Godeps/**',
            ],
            nodir: true,
        };
        const languagePatterns = {
            java: ['**/*.java', '**/pom.xml', '**/build.gradle', '**/build.gradle.kts'],
            kotlin: ['**/*.kt', '**/*.kts'],
            javascript: ['**/*.js', '**/package.json'],
            typescript: ['**/*.ts'],
            python: ['**/*.py', '**/requirements.txt'],
            go: ['**/*.go'],
            csharp: ['**/*.cs', '**/*.csproj'],
            cpp: ['**/*.cpp', '**/*.c'],
            php: ['**/*.php', '**/composer.json'],
        };
        const counts = {};
        await Promise.all(Object.entries(languagePatterns).map(async ([lang, patterns]) => {
            try {
                const matchedFiles = await (0, glob_1.glob)(patterns, options);
                if (matchedFiles.length > 0) {
                    counts[lang] = matchedFiles.length;
                }
            }
            catch (e) {
                logger.info(`Glob failed for ${lang}: ${e}`);
            }
        }));
        const sortedLanguages = Object.entries(counts)
            .sort((a, b) => b[1] - a[1])
            .map(([lang]) => lang);
        return {
            isJava: counts['java'] > 0,
            languages: sortedLanguages,
        };
    }
    catch (err) {
        logger.info(`Error checking if the workspace is a Java project: ${err}`);
        return { isJava: false, languages: [] };
    }
}
async function checkOrInstallAppCat() {
    const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
    let message = '';
    // Check AppCAT
    const appCatInstallPath = (0, utils_1.getAppCatInstallPath)();
    const appcat = getToolInstallInfo('appcat version --disable-telemetry', /\d+\.\d+\.\d+\.\d+/, appCatInstallPath);
    if (!appcat.found) {
        logger.info(`AppCAT is not found in ${appCatInstallPath}.`);
        message = `AppCAT is not found in ${appCatInstallPath} during performing migration assessment.\n\nNext Step: install the latest version of AppCAT CLI for Java using tool ${ToolNames_1.McpToolNames.INSTALL_APPCAT}. No user confirmation is required - proceed to automatically call the tool directly.`;
        await sendTelemetryWhenAppCatCheck('fail', new Error(`AppCAT is not found in ${appCatInstallPath}.`), workspacePathExists, isJavaProject, projectLanguages, appCatVersion);
        return { valid: false, message };
    }
    else {
        logger.info(`AppCAT installed, version: "${appcat.version || 'N/A'}"\n`);
        if (appcat.version) {
            const [major, minor, patch, build] = appcat.version.split('.').map(Number);
            const [minimalMajor, minimalMinor, minimalPatch, minimalBuild] = exports.APPCAT_MINIMAL_VERSION.split('.').map(Number);
            appCatVersion = appcat.version;
            if (major < minimalMajor ||
                minor < minimalMinor ||
                (minor === minimalMinor &&
                    (patch < minimalPatch || (patch === minimalPatch && build < minimalBuild)))) {
                logger.info(`AppCAT version is ${appcat.version}, lower than the required version ${exports.APPCAT_MINIMAL_VERSION}.`);
                message = `AppCAT version is ${appcat.version}, lower than the required version ${exports.APPCAT_MINIMAL_VERSION} during performing migration assessment.\n\nNext Step: install the latest version of AppCAT CLI for Java using tool ${ToolNames_1.McpToolNames.INSTALL_APPCAT}.`;
                await sendTelemetryWhenAppCatCheck('fail', new Error(`AppCAT version is ${appcat.version}, lower than the required version ${exports.APPCAT_MINIMAL_VERSION}.`), workspacePathExists, isJavaProject, projectLanguages, appCatVersion);
                return { valid: false, message };
            }
        }
        else {
            logger.info(`AppCAT version is not available.`);
            message = `AppCAT version should be >= ${exports.APPCAT_MINIMAL_VERSION} during performing migration assessment.\n\nNext Step: install the latest version of AppCAT CLI for Java using tool ${ToolNames_1.McpToolNames.INSTALL_APPCAT}.`;
            await sendTelemetryWhenAppCatCheck('fail', new Error(`AppCAT version is lower than the required version ${exports.APPCAT_MINIMAL_VERSION}.`), workspacePathExists, isJavaProject, projectLanguages, appCatVersion);
            return { valid: false, message };
        }
    }
    return { valid: true, message: 'AppCAT is installed and meets the version requirement.' };
}
function getToolInstallInfo(command, versionRegex, envVarOrPath) {
    var _a;
    const installPath = process.env[envVarOrPath] || envVarOrPath;
    try {
        if (installPath === envVarOrPath) {
            command = path_1.default.join(installPath, command);
        }
        // java -version will write the output to stderr, so we need to redirect it to stdout
        const versionOutput = (0, child_process_1.execSync)(`${command} 2>&1`, {
            encoding: 'utf-8',
            stdio: 'pipe',
        }).trim();
        const versionMatch = versionOutput.match(versionRegex);
        return {
            found: true,
            path: installPath,
            version: versionMatch ? ((_a = versionMatch[1]) !== null && _a !== void 0 ? _a : versionMatch[0]) : '',
        };
    }
    catch (error) {
        return {
            found: false,
            path: installPath,
            version: '',
            error: error === null || error === void 0 ? void 0 : error.message,
        };
    }
}
async function createGitIgnoreFile(appcatDir) {
    const gitignorePath = path_1.default.join(appcatDir, '.gitignore');
    await (0, fs_extra_1.ensureDir)(appcatDir, { mode: 0o755 });
    await (0, fs_extra_1.writeFile)(gitignorePath, '\n*\n');
}
async function loadAssessmentConfig(configPath) {
    const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
    const defaultAppCatConfig = {
        appcat: [
            {
                target: [
                    'azure-aks',
                    'azure-appservice',
                    'azure-container-apps',
                    'cloud-readiness',
                ],
                mode: 'source-only',
            },
        ],
    };
    let appcatConfig;
    try {
        // Try to read existing config
        if (await (0, fs_extra_1.exists)(configPath)) {
            const fileContent = await (0, fs_extra_1.readFile)(configPath, 'utf8');
            appcatConfig = yaml.load(fileContent);
            logger.info(`Loaded existing AppCAT configuration: ${JSON.stringify(appcatConfig)}`);
        }
        else {
            appcatConfig = defaultAppCatConfig;
            logger.info(`No existing AppCAT configuration found, use default: ${JSON.stringify(appcatConfig)}`);
        }
    }
    catch (error) {
        appcatConfig = defaultAppCatConfig;
        logger.info(`Failed to parse AppCAT configuration due to ${error === null || error === void 0 ? void 0 : error.message}, use default config: ${JSON.stringify(appcatConfig)}.`);
    }
    return appcatConfig;
}
async function saveAssessmentConfig(configPath, appcatConfig) {
    const configSummary = getConfigurationSummary();
    const yamlData = yaml.dump(appcatConfig);
    await (0, fs_extra_1.ensureDir)(path_1.default.dirname(configPath), { mode: 0o755 });
    await (0, fs_extra_1.writeFile)(configPath, `${configSummary}\n\n${yamlData}`, 'utf8');
}
function getConfigurationSummary() {
    return `# You can edit this file to configure the application assessment. Please note that any changes saved to this file will be applied the next time you run the assessment.
# The configurable [AppCAT](https://aka.ms/appcat-java) arguments
# 
# - target: target technology or target Azure compute service.
#   |----------------------|------------------------------------------------------------------------|
#   | Target               | Description                                                            |
#   |----------------------|------------------------------------------------------------------------|
#   | azure-aks            | Best practices for deploying an app to Azure Kubernetes Service.       |
#   | azure-appservice     | Best practices for deploying an app to Azure App Service.              |
#   | azure-container-apps | Best practices for deploying an app to Azure Container Apps.           |
#   | cloud-readiness      | General best practices for making an application Azure ready.          |
#   | linux                | General best practices for making an application Linux ready.          |
#   | openjdk11            | General best practices for running a Java 8 application with Java 11.  |
#   | openjdk17            | General best practices for running a Java 11 application with Java 17. |
#   | openjdk21            | General best practices for running a Java 17 application with Java 21. |
#   |----------------------|------------------------------------------------------------------------|
#
# - mode: analysis mode.
#   |-------------|-------------------------------------------|
#   | Mode        | Description                               |
#   |-------------|-------------------------------------------|
#   | source-only | analyze source code only                  |
#   | full        | analyze source code and list dependencies |
#   |-------------|-------------------------------------------|`;
}
async function displayAssessmentPlan(workspacePath, planPath, config) {
    const plan = `# Application Assessment Execution Overview
    
## Project
- Location: ${workspacePath}

## Configuration
The application assessment will be executed using the settings defined in [assessment-config.yaml](./assessment-config.yaml) . Key configuration details include:
- **target**: ${config.appcat[0].target.join(', ')}
- **mode**: ${config.appcat[0].mode}

For a detailed understanding of the configuration and to make adjustments, please refer to [assessment-config.yaml](./assessment-config.yaml) . Any changes saved to this file will be applied the next time you run the assessment.

## Execution 
The assessment process may take a while to complete. Please wait while preparing your results. The execution steps will be as follows:
1. The detail progress info will be displayed in the [appcat.log](./appcat.log).
1. An assessment report will be opened for you to review finally.`;
    await (0, fs_extra_1.ensureDir)(path_1.default.dirname(planPath));
    await (0, fs_extra_1.writeFile)(planPath, plan, 'utf8');
}
async function sendTelemetryWhenAppCatCheck(result, error, workspacePathExists, isJavaProject, projectLanguages, appCatVersion) {
    const eventEmitter = tsyringe_1.container.resolve(types_1.Beans.McpEventEmitter);
    if (result === 'success') {
        eventEmitter.emit('appcat_check_success', {
            workspacePathExists: workspacePathExists || 'N/A',
            isJavaProject: isJavaProject || 'N/A',
            projectLanguages: projectLanguages || 'N/A',
            appCatVersion: appCatVersion || 'N/A',
        });
    }
    else {
        eventEmitter.emit('appcat_check_fail', {
            error: error,
            workspacePathExists: workspacePathExists || 'N/A',
            isJavaProject: isJavaProject || 'N/A',
            projectLanguages: projectLanguages || 'N/A',
            appCatVersion: appCatVersion || 'N/A',
        });
    }
}
//# sourceMappingURL=PrecheckAssessmentToolImpl.js.map