"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchFileToolImpl = void 0;
const promises_1 = __importDefault(require("fs/promises"));
const glob_1 = require("glob");
const tsyringe_1 = require("tsyringe");
const xregexp_1 = __importDefault(require("xregexp"));
const ToolNames_1 = require("../../tools/ToolNames");
const types_1 = require("../../types");
const Tool_1 = require("../Tool");
const toolDescription_1 = require("../toolDescription");
class SearchFileToolImpl extends Tool_1.BaseTool {
    constructor() {
        super(...arguments);
        this.name = ToolNames_1.McpToolNames.SEARCH_FILE;
        this.toolReferenceName = ToolNames_1.McpToolNames.SEARCH_FILE;
        this.displayName = 'Search Files';
        this.description = toolDescription_1.ToolDescriptions.SEARCH_FILE;
    }
    async search(workspacePath, query, includePattern) {
        const options = {
            nodir: true,
            ignore: ['**/node_modules/**', '**/.git/**', '**/target/**', '**/.github/**'], // Ignore common directories
            cwd: workspacePath,
            onlyFiles: true,
            absolute: true,
        };
        const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
        const results = [];
        if (!query) {
            logger.warn('No search query provided, returning empty results');
            return results; // Return empty if no query is provided
        }
        const files = await (0, glob_1.glob)(includePattern || '**', options);
        if (files.length === 0) {
            logger.warn(`No files found matching the pattern "${includePattern}"`);
            return results; // Return empty if no files match the glob pattern
        }
        const r = this.stringToRegex(query);
        for (const file of files) {
            const content = await promises_1.default.readFile(file, 'utf-8');
            if ((typeof r === 'string' && content.includes(r)) ||
                (r instanceof RegExp && r.test(content))) {
                results.push(file);
            }
        }
        logger.info(`Found ${results.length} files matching the pattern "${r}" and glob pattern "${includePattern}" in workspace "${workspacePath}"`);
        return results;
    }
    async execute(request, context) {
        const { workspacePath, query, includePattern } = request;
        const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
        const eventEmitter = tsyringe_1.container.resolve(types_1.Beans.McpEventEmitter);
        const startTime = Date.now();
        try {
            const results = await this.search(workspacePath, query, includePattern);
            // Return data in a format compatible with McpServer
            eventEmitter.emit('file_search_success', {
                query,
                includePattern,
                hit: results.length,
                duration: Date.now() - startTime,
            }, context);
            return this.createSuccessResponse(JSON.stringify(results, null, 2));
        }
        catch (error) {
            logger.error(`Error during search:`, error);
            let message = 'Unknown error';
            if (error instanceof Error) {
                message = error.message;
            }
            eventEmitter.emit('file_search_fail', {
                query,
                includePattern,
                error: error,
                duration: Date.now() - startTime,
            }, context);
            return this.createErrorResponse(`Error during search: ${message}`);
        }
    }
    stringToRegex(patternString) {
        // Regular expression to match the pattern and flags
        const regexParts = /^\/(.*)\/([a-z]*)$/.exec(patternString);
        if (regexParts) {
            const pattern = regexParts[1];
            const flags = regexParts[2];
            return new RegExp(pattern, flags);
        }
        try {
            const regex = (0, xregexp_1.default)(patternString);
            return regex;
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
        }
        catch (_error) {
            /* empty */
        }
        return patternString; // Return the original string if it cannot be converted to a regex
    }
}
exports.SearchFileToolImpl = SearchFileToolImpl;
//# sourceMappingURL=SearchFileToolImpl.js.map