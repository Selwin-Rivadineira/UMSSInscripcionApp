"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tsyringe_1 = require("tsyringe");
const formula_to_kb_1 = require("./kb/formula_to_kb");
const inference_1 = require("./kb/inference");
const loaders_1 = require("./kb/loaders");
const markdown_to_kb_1 = require("./kb/markdown_to_kb");
const metadata_1 = require("./kb/metadata");
const store_1 = require("./kb/store");
const logger_1 = require("./logger");
const settings_1 = require("./settings");
const devDeviceId_1 = require("./telemetry/devDeviceId");
const event_1 = require("./telemetry/event");
const machineId_1 = require("./telemetry/machineId");
const telemetry_1 = require("./telemetry/telemetry");
const types_1 = require("./types");
const utils_1 = require("./utils");
tsyringe_1.container.register(types_1.Beans.Settings, settings_1.Settings, { lifecycle: tsyringe_1.Lifecycle.Singleton });
tsyringe_1.container.register(types_1.Beans.Logger, logger_1.MCPLoggerImpl, { lifecycle: tsyringe_1.Lifecycle.Singleton });
tsyringe_1.container.register(types_1.Beans.ToolsConfig, {
    useFactory: (c) => {
        const settings = c.resolve(types_1.Beans.Settings);
        const logger = c.resolve(types_1.Beans.Logger);
        logger.debug(`Get tools config for server type: ${settings.getServerType()}`);
        return (0, utils_1.getToolsConfig)(__dirname, settings.getServerType());
    },
});
tsyringe_1.container.register(types_1.Beans.TelemetryReporter, {
    useFactory: (c) => {
        const settings = c.resolve(types_1.Beans.Settings);
        const logger = c.resolve(types_1.Beans.Logger);
        if (settings.isDebugTelemetry()) {
            logger.debug('Debug telemetry is enabled. Using LoggerTelemetryReporter.');
            return new telemetry_1.LoggerTelemetryReporter(logger);
        }
        return new telemetry_1.ApplicationInsightsTelemetryReporter(settings, logger);
    },
});
tsyringe_1.container.register(types_1.Beans.TelemetryService, {
    useFactory: (c) => {
        const settings = c.resolve(types_1.Beans.Settings);
        const telemetryReporter = c.resolve(types_1.Beans.TelemetryReporter);
        const staticProperties = {
            serverName: settings.getServerName(),
            serverVersion: settings.getServerVersion(),
            internal: (0, utils_1.isInternal)().toString(),
            devDeviceId: (0, devDeviceId_1.getDeviceId)(),
            machineId: (0, machineId_1.getMachineID)(),
            callerId: settings.getCallerId(),
            callerVersion: settings.getCallerVersion(),
            callerType: settings.getCallerType(),
            callerMachineId: settings.getCallerMachineId(),
            callerSessionId: settings.getCallerSessionId(),
            serveFrom: settings.getServeFrom(),
        };
        const telemetryService = new telemetry_1.TelemetryService([telemetryReporter], staticProperties);
        if ((0, utils_1.isJest)()) {
            staticProperties['repoName'] = settings.getMsbenchRepoName();
            staticProperties['runId'] = settings.getMsbenchRunId();
        }
        return telemetryService;
    },
});
tsyringe_1.container.register(types_1.Beans.CustomDocumentLoader, {
    useFactory: (c) => {
        const settings = c.resolve(types_1.Beans.Settings);
        const logger = c.resolve(types_1.Beans.Logger);
        return (0, loaders_1.createLoaderFromPaths)(logger, {
            watch: true,
        }, {
            filePath: settings.getCustomKbPath(),
            metadata: { author: 'custom' },
        });
    },
});
tsyringe_1.container.register(types_1.Beans.MsftDocumentLoader, {
    useFactory: (c) => {
        const settings = c.resolve(types_1.Beans.Settings);
        const logger = c.resolve(types_1.Beans.Logger);
        const msftKbPath = settings.getMsftKbPaths();
        return (0, loaders_1.createLoaderFromPaths)(logger, {
            watch: false,
        }, ...msftKbPath.map((filePath) => ({
            filePath,
            metadata: { author: 'microsoft' },
        })));
    },
});
tsyringe_1.container.register(types_1.Beans.DocumentLoader, {
    useFactory: (c) => {
        return loaders_1.CompositeLoader.from(c.resolve(types_1.Beans.CustomDocumentLoader), c.resolve(types_1.Beans.MsftDocumentLoader));
    },
});
tsyringe_1.container.register(types_1.Beans.KBStore, store_1.KBStore, { lifecycle: tsyringe_1.Lifecycle.Singleton });
tsyringe_1.container.register(types_1.Beans.KBLoaders, {
    useFactory: (c) => {
        const documentLoader = c.resolve(types_1.Beans.DocumentLoader);
        const settings = c.resolve(types_1.Beans.Settings);
        const logger = c.resolve(types_1.Beans.Logger);
        return [
            new formula_to_kb_1.FormulaToKb(documentLoader, settings, logger),
            new markdown_to_kb_1.MarkdownToKb(documentLoader, logger),
        ];
    },
});
tsyringe_1.container.register(types_1.Beans.KBVectorStore, {
    useFactory: (c) => {
        const settings = c.resolve(types_1.Beans.Settings);
        const embeddingsProvider = c.resolve(types_1.Beans.EmbeddingsProvider);
        const logger = c.resolve(types_1.Beans.Logger);
        if (settings.getVectorStoreType() === 'in-memory') {
            return new store_1.InMemoryVectorStore(embeddingsProvider, logger, (kb) => metadata_1.MetadataGetter.getSource(kb), // Identifier function
            store_1.formatKbHeader, store_1.formatKbContent);
        }
        else {
            throw new Error(`Unsupported vector store type: ${settings.getVectorStoreType()}`);
        }
    },
});
tsyringe_1.container.register(types_1.Beans.EmbeddingsProvider, inference_1.XenovaInferenceService, {
    lifecycle: tsyringe_1.Lifecycle.Singleton,
});
tsyringe_1.container.register(types_1.Beans.Reranker, inference_1.XenovaInferenceService, {
    lifecycle: tsyringe_1.Lifecycle.Singleton,
});
tsyringe_1.container.register(types_1.Beans.McpEventEmitter, {
    useFactory: (c) => {
        const toolsConfig = c.resolve(types_1.Beans.ToolsConfig);
        const telemetryService = c.resolve(types_1.Beans.TelemetryService);
        const logger = c.resolve(types_1.Beans.Logger);
        switch (toolsConfig.telemetryProfile) {
            case 'java':
                return new event_1.JavaTelemetryEventEmitter(telemetryService, logger);
            case 'dotnet':
                // FIXME: Placeholder for .NET telemetry event emitter
                return new event_1.DummyMcpEventEmitter();
            default:
                return new event_1.DummyMcpEventEmitter();
        }
    },
});
//# sourceMappingURL=ioc.js.map