"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runCommand = runCommand;
exports.spawnProcess = spawnProcess;
const child_process_1 = require("child_process");
async function runCommand(workDir, command, args, runOptions = {}) {
    const stdOut = [];
    const { logger, env = {}, exitOnError = true, outputToConsole = true, throwIfFail = true, } = runOptions;
    const useLogger = logger ? logger : outputToConsole ? console : undefined;
    const waitForProcess = new Promise((resolve, reject) => {
        const process = spawnProcess(workDir, command, args, useLogger, env, runOptions.signal);
        process.stdout.on('data', (data) => {
            stdOut.push(data);
        });
        if (runOptions.includeStdErrInStdOut) {
            process.stderr.on('data', (data) => {
                stdOut.push(data);
            });
        }
        process.on('error', (error) => {
            if (exitOnError) {
                reject(error);
            }
        });
        process.on('close', (code) => {
            if (throwIfFail && code !== 0) {
                reject(new Error(`Command ${command} failed with code ${code}.\n${stdOut}`));
            }
            else {
                resolve();
            }
        });
    });
    await waitForProcess;
    return stdOut.join('');
}
function spawnProcess(workDir, command, args, logger, envVars = {}, signal) {
    const env = { ...process.env, ...envVars };
    // If the path has spaces, we need to wrap it in quotes
    if (/\s/.test(command)) {
        command = `"${command}"`;
    }
    const childProcess = (0, child_process_1.spawn)(command, args, { shell: true, cwd: workDir, env, signal });
    if (logger) {
        childProcess.stdout.setEncoding('utf8');
        childProcess.stdout.on('data', (data) => {
            // for stdout we don't want to include timestamp, level or new line since we want to preserve the output as is
            logger.info(`${data}`, {
                appendNewLine: false,
                includeTimestamp: false,
                includeLevel: false,
            });
        });
        childProcess.stderr.setEncoding('utf8');
        childProcess.stderr.on('data', (data) => {
            logger.info(''); // add a new line to break stdout otherwise we will just append it to the last line
            logger.error(`${data}`);
        });
        childProcess.on('error', (error) => {
            logger.info(''); // add a new line to break stdout otherwise we will just append it to the last line
            logger.error(`${command} failed with error ${error}`);
        });
        childProcess.on('close', (code, signal) => {
            logger.info(''); // add a new line to break stdout otherwise we will just append it to the last line
            logger.info(`${command} process closed with code ${code} and signal ${signal}`);
        });
    }
    return childProcess;
}
//# sourceMappingURL=shell.js.map