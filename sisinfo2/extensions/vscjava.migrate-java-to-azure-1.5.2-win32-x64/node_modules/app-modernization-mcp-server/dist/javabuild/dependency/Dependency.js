"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dependency = void 0;
class Dependency {
    constructor(dep) {
        this.groupId = dep.groupId;
        this.artifactId = dep.artifactId;
        this.version = dep.version;
        this.name = dep.name;
        this.description = dep.description;
        this.tags = dep.tags;
        this.type = dep.type;
        this.classifier = dep.classifier;
        this.scope = dep.scope;
        this.module = dep.module;
    }
    /**
     * Parses a Maven dependency coordinate string and returns an `IJavaDep` object.
     *
     * The Maven dependency coordinate string should follow the format:
     * `groupId:artifactId:type[:classifier]:version[:scope]`.
     *
     * @param id - The Maven dependency coordinate string to parse.
     * @returns An `IJavaDep` object if the coordinate string is valid, otherwise `undefined`.
     *
     * @example
     *
     * Input: com.example:library:jar:classifier:1.0.0:compile
     *
     * Output:
     *  | Group | Value       | Description                        | Example     |
     *  |-------|-------------|------------------------------------|-------------|
     *  | 1     | groupId*    | Matches the group ID.              | com.example |
     *  | 2     | artifactId* | Matches the artifact ID.           | library     |
     *  | 3     | type*       | Matches the type.                  | jar         |
     *  | 5     | classifier  | (Optional) Matches the classifier. | classifier  |
     *  | 6     | version     | Matches the version.               | 1.0.0       |
     *  | 8     | scope       | (Optinal) Matches the scope.       | compile     |
     */
    static parse(coordinate, module) {
        const match = coordinate.match(/([a-zA-Z0-9\\._\\-]+):([a-zA-Z0-9\\._\\-]+)(:([a-zA-Z0-9\\.\\-]+))?(:([a-zA-Z0-9_\\-]+))?:([a-zA-Z0-9\\._\\-]+)+(:([a-zA-Z0-9\\.\\-]+))?/);
        if (match) {
            const [, groupId, artifactId, , type, , classifier, version, , scope] = match;
            return new Dependency({
                groupId,
                artifactId,
                type,
                classifier,
                version,
                scope,
                module,
            });
        }
        return undefined;
    }
    get key() {
        return Dependency.key(this);
    }
    static key(dep) {
        const artifactId = dep.artifactId || '*';
        return `${dep.groupId}:${artifactId}`;
    }
    get gav() {
        return Dependency.gav(this);
    }
    static gav(dep) {
        const artifactId = dep.artifactId || '*';
        const version = dep.version || '*';
        return `${dep.groupId}:${artifactId}:${version}`;
    }
    get coordinate() {
        return Dependency.coordinate(this);
    }
    static coordinate(dep) {
        const type = dep.type ? `:${dep.type}` : '';
        const classifier = dep.classifier ? `:${dep.classifier}` : '';
        return `${dep.groupId}:${dep.artifactId}:${dep.version}${type}${classifier}`;
    }
    /**
     * called by JSON.stringify when the object is JSONified
     * @returns Returns a JSON representation of the dependency.
     */
    toJSON() {
        return {
            groupId: this.groupId,
            artifactId: this.artifactId,
            version: this.version,
            name: this.name,
            description: this.description,
            tags: this.tags,
            type: this.type,
            classifier: this.classifier,
            scope: this.scope,
            module: this.module,
            key: this.key,
            gav: this.gav,
            coordinate: this.coordinate,
        };
    }
    toString() {
        return this.coordinate;
    }
    static diff(beforeDeps, afterDeps) {
        const isSameDep = (a, b) => Dependency.key(a) === Dependency.key(b) && a.module === b.module;
        const added = afterDeps.filter((dep) => !beforeDeps.find((d) => isSameDep(d, dep)));
        const deleted = beforeDeps.filter((dep) => !afterDeps.find((d) => isSameDep(d, dep)));
        const kept = beforeDeps.filter((dep) => afterDeps.find((d) => isSameDep(d, dep)));
        const changed = [];
        const unchanged = [];
        for (const dep of kept) {
            const afterDep = afterDeps.find((d) => isSameDep(d, dep));
            // we only care about version changes
            if (dep.version !== (afterDep === null || afterDep === void 0 ? void 0 : afterDep.version)) {
                changed.push({ before: dep, after: afterDep });
            }
            else {
                unchanged.push(dep);
            }
        }
        return { added, deleted, changed };
    }
}
exports.Dependency = Dependency;
//# sourceMappingURL=Dependency.js.map