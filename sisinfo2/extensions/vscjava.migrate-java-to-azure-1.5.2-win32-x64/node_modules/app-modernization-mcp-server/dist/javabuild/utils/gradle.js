"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.gradleVersion = gradleVersion;
exports.gradleDirectDependencies = gradleDirectDependencies;
exports.runGradleCmd = runGradleCmd;
exports.parseGradleOutput = parseGradleOutput;
const path_1 = __importDefault(require("path"));
const fileSystem_1 = require("../common/fileSystem");
const os_1 = require("../common/os");
const Environment_1 = require("../context/Environment");
const JavaDependency_utils_1 = require("../dependency/JavaDependency.utils");
async function gradleVersion(directory, gradle = 'gradle', logger, env = Environment_1.Environment.Local) {
    const output = await env.runCommand(directory, gradle, ['--version', '--no-daemon'], {
        logger,
    });
    return output;
}
async function handleGradleConfigFileError(output) {
    const errors = [];
    // Gradle error patterns
    const errorMessage = resolveWhatError(output);
    const errorDetails = resolveWhereError(output) || {
        filePath: undefined,
        lineNumber: undefined,
    };
    const { filePath, lineNumber } = errorDetails;
    if (errorMessage === undefined && filePath === undefined && lineNumber === undefined) {
        return errors;
    }
    const currentError = {
        lineNumber: lineNumber,
        filePath: filePath,
        errorMessage: errorMessage || '',
        raw: output,
    };
    errors.push(currentError);
    return errors;
}
function resolveWhatError(output) {
    /**
     Build file 'D:\sourceCode\java\gradleProjects\xdprueba\build.gradle' line: 41

* What went wrong:
A problem occurred evaluating root project 'xdprueba'.
> Could not find method compile() for arguments [{group=nz.net.ultraq.thymeleaf, name=thymeleaf-layout-dialect, version=2.4.1}] on object of type org.gradle.api.internal.artifacts.dsl.dependencies.DefaultDependencyHandler.

* Try:
> Run with --stacktrace option to get the stack trace.
     */
    const whatPattern = /\* What went wrong:\s*([\s\S]*?)(?=\* Try:)/;
    const errorReason = output.match(whatPattern);
    if (errorReason) {
        return errorReason[1].trim();
    }
    return undefined;
}
function resolveWhereError(output) {
    /**

* Where:
Build file 'D:\sourceCode\java\gradleProjects\xdprueba\build.gradle' line: 41

*
    */
    const wherePattern = /\* Where:\s*(.+)/;
    const where = output.match(wherePattern);
    if (where) {
        const buildErrorFilePattern = /Build file '([^']+)' line:\s*(\d+)/;
        const buildErrorMatch = where[1].match(buildErrorFilePattern);
        if (buildErrorMatch) {
            const filePath = buildErrorMatch[1];
            const lineNumber = buildErrorMatch[2];
            return { filePath, lineNumber };
        }
    }
    return undefined;
}
async function gradleDirectDependencies(repoPath, gradle = 'gradle', env = Environment_1.Environment.Local, logger) {
    var _a;
    let output = '';
    try {
        // `gradle dependencies --configuration implementation` not supported in the lower version of gradle, like gradle 4.X
        //  output = await env.runCommand(repoPath, gradle, ['dependencies', '--configuration', 'implementation'], {
        output = await env.runCommand(repoPath, gradle, ['dependencies', '--configuration', 'compileClasspath', '--no-daemon'], {
            logger,
            exitOnError: false,
            throwIfFail: false,
        });
        output = output.concat(await env.runCommand(repoPath, gradle, ['dependencies', '--configuration', 'testCompileClasspath', '--no-daemon'], {
            logger,
            exitOnError: false,
            throwIfFail: false,
        }));
        const submodulesOutput = await env.runCommand(repoPath, gradle, ['projects', '--no-daemon'], {
            logger,
            exitOnError: false,
            throwIfFail: false,
        });
        // Get the submodules from the submodulesOutput
        const submodules = (_a = submodulesOutput
            .match(/Project\s+'?:(\S+)'?\S/g)) === null || _a === void 0 ? void 0 : _a.map((submodule) => submodule.replace(/Project\s+[':]*|['\s]+/g, '').trim());
        logger === null || logger === void 0 ? void 0 : logger.info(`submodules: ${JSON.stringify(submodules)}`);
        if (submodules) {
            for (const submodule of submodules) {
                output = output.concat(await env.runCommand(repoPath, gradle, [
                    `${submodule}:dependencies`,
                    '--configuration',
                    'compileClasspath',
                    '--no-daemon',
                ], {
                    logger,
                    exitOnError: false,
                    throwIfFail: false,
                }));
                output = output.concat(await env.runCommand(repoPath, gradle, [
                    `${submodule}:dependencies`,
                    '--configuration',
                    'testCompileClasspath',
                    '--no-daemon',
                ], {
                    logger,
                    exitOnError: false,
                    throwIfFail: false,
                }));
            }
        }
    }
    catch (error) {
        logger === null || logger === void 0 ? void 0 : logger.error(`Get gradleDirectDependencies error: ${error}`);
    }
    return {
        parsed: parseGradleDependencies(output),
        raw: output,
    };
}
function parseGradleDependencies(output) {
    const result = {};
    const lines = output.split('\n');
    let currentProject;
    for (const line of lines) {
        // Match project name from "Project :{projectName}" or "Root project" corresponding to the multi-modules project and single-module project
        const projectMatch = line.match(/Project\s*:\s*(\S+)/);
        if (projectMatch) {
            currentProject = projectMatch[1];
            result[currentProject] = [];
            continue;
        }
        else if (Object.keys(result).length === 0) {
            const rootProjectMatch = line.match(/Root\s*project/);
            if (rootProjectMatch) {
                currentProject = 'Root project';
                result[currentProject] = [];
                continue;
            }
        }
        if (line.startsWith('+---')) {
            const dep = (0, JavaDependency_utils_1.parseJavaDepCoordFromGradle)(line);
            if (dep && currentProject) {
                result[currentProject].push(dep);
            }
        }
    }
    return result;
}
async function runGradleCmd(repoPath, gradle = 'gradle', args, env = Environment_1.Environment.Local, logger, cmdInfo = undefined, runOptions = { logger, exitOnError: true, throwIfFail: true }) {
    logger === null || logger === void 0 ? void 0 : logger.info(`Running commands for ${repoPath} with Gradle.`);
    await gradleVersion(repoPath, gradle, logger, env);
    logger === null || logger === void 0 ? void 0 : logger.info(`Command:\n\n${gradle} ${args.join(' ')}\n\n`);
    cmdInfo === null || cmdInfo === void 0 ? void 0 : cmdInfo(gradle, args);
    const stdOut = await env.runCommand(repoPath, gradle, args, runOptions);
    return stdOut;
}
async function parseGradleOutput(repoPath, output) {
    //D:\sourceCode\java\AutoDev\distGradle\dist\migration-tests\Koople-sdk-java.git\src\main\java\io\koople\sdk\KConfig.java:35: error: unreported exception URISyntaxException; must be caught or declared to be thrown
    // return new URI(protocol, null, host, port, initURL, null, null).toURL();
    const errorPattern = /(\S+\.java):(\d+): error: (.*(?:\n\s+.*)*)/g;
    let buildLog = output;
    const errors = [];
    // Removing duplicate of the error message
    const errorLogsStartIndex = buildLog.indexOf('FAILURE: Build failed with an exception.');
    if (errorLogsStartIndex !== -1) {
        buildLog = buildLog.slice(errorLogsStartIndex);
    }
    const errorLogsEndIndex = buildLog.indexOf('BUILD FAILED');
    if (errorLogsEndIndex !== -1) {
        buildLog = buildLog.slice(0, errorLogsEndIndex);
    }
    let errorMatch;
    while ((errorMatch = errorPattern.exec(buildLog)) !== null) {
        const filePath = errorMatch[1];
        const lineNumber = errorMatch[2];
        const errorMessage = errorMatch[3].replace(/\n/g, '').trim();
        const updatedFilePath = (0, os_1.isWindows)() ? filePath.replace(/^\//, '') : filePath;
        const normalizedFilePath = path_1.default.normalize(updatedFilePath);
        const resolvedPath = (0, fileSystem_1.tryResolvePath)(repoPath, normalizedFilePath).fullPath || normalizedFilePath;
        const updatedErrorMessage = errorMessage
            .replace(/\n/g, '')
            .replace(/-> \[Help (.*)\]/g, '')
            .trim();
        const currentError = {
            filepath: resolvedPath,
            lineNumber,
            errorMessage: updatedErrorMessage,
            raw: errorMatch[0],
        };
        errors.push(currentError);
    }
    const buildSuccessful = parseBuildSuccessful(output);
    if (errors.length === 0) {
        return {
            success: buildSuccessful,
            details: await handleGradleConfigFileError(output),
        };
    }
    return {
        success: buildSuccessful,
        details: errors,
    };
}
function parseBuildSuccessful(output) {
    const successPattern = /BUILD SUCCESSFUL/;
    return successPattern.test(output);
}
//# sourceMappingURL=gradle.js.map