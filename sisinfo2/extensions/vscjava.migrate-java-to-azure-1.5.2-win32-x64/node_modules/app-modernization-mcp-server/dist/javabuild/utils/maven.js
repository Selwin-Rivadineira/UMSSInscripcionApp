"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mvnVersion = mvnVersion;
exports.parseMavenOutput = parseMavenOutput;
exports.mvnDirectDependencies = mvnDirectDependencies;
exports.parseDirectDepsFromDependencyTree = parseDirectDepsFromDependencyTree;
exports.runMvnCmd = runMvnCmd;
const path_1 = __importDefault(require("path"));
const fileSystem_1 = require("../common/fileSystem");
const os_1 = require("../common/os");
const Environment_1 = require("../context/Environment");
const JavaDependency_1 = require("../dependency/JavaDependency");
const JavaDependency_utils_1 = require("../dependency/JavaDependency.utils");
async function mvnVersion(directory, mvn = 'mvn', logger, env = Environment_1.Environment.Local) {
    return await env.runCommand(directory, mvn, ['-v'], { logger });
}
async function parseMavenOutput(repoPath, output, logger) {
    const errorPattern = /\[ERROR\] (\S+\.java):\[([0-9]+),([0-9]+)\] (.*)/;
    let buildLog = output;
    const errors = [];
    const buildSuccessDetected = parseBuildSuccess(output);
    // Add a map to track build results for each module
    const moduleBuildStatuses = new Map();
    // Parse module-level build results
    let isMultiModule = false;
    try {
        isMultiModule = parseModuleBuildResults(repoPath, output, moduleBuildStatuses);
    }
    catch (error) {
        logger === null || logger === void 0 ? void 0 : logger.warn(`parse module build results failed: ${error.message}`);
        moduleBuildStatuses.clear();
    }
    // Removing duplicate of the error message
    const failedExecuteIndex = buildLog.indexOf('[ERROR] Failed to execute');
    if (failedExecuteIndex !== -1) {
        buildLog = buildLog.slice(failedExecuteIndex);
    }
    const stackTraceIndex = buildLog.indexOf('[ERROR] To see the full stack trace of the errors');
    if (stackTraceIndex !== -1) {
        buildLog = buildLog.slice(0, stackTraceIndex);
    }
    //Remove lines that are not errors (prefixed by INFO, WARN, etc)
    buildLog = buildLog
        .split('\n')
        .map((line) => line.replace(/\[(?:INFO|WARNING)\] (.*)/g, ''))
        .join('\n')
        .trim();
    const projectWiseErrorLogs = buildLog.split(/(?=\[ERROR\] Failed to execute)/);
    let skipDependencyConvergenceErrors = false;
    for (const projectErrorLog of projectWiseErrorLogs) {
        const lines = projectErrorLog.split('\n');
        let currentError = undefined;
        const currentErrorList = [];
        for (let line of lines) {
            const match = line.match(errorPattern);
            if (match) {
                const [raw, filePath, lineNumber, colNumber, errorMessage] = match;
                // if it's windows remove any leading "/" from the file path
                const updatedFilePath = (0, os_1.isWindows)() ? filePath.replace(/^\//, '') : filePath;
                const normalizedFilePath = path_1.default.normalize(updatedFilePath);
                const resolvedPath = (0, fileSystem_1.tryResolvePath)(repoPath, normalizedFilePath).fullPath || normalizedFilePath;
                const updatedErrorMessage = errorMessage
                    .replace(/\n/g, '')
                    .replace(/-> \[Help (.*)\]/g, '')
                    .trim();
                currentError = {
                    filepath: resolvedPath,
                    lineNumber,
                    colNumber,
                    errorMessage: updatedErrorMessage,
                    raw,
                };
                currentErrorList.push(currentError);
            }
            else if (currentError) {
                line = line.replace(/-> \[Help (.*)\]/g, '').trim();
                if (!line || line === '[ERROR]') {
                    continue;
                }
                currentError.raw += '\n' + line;
                currentError.errorMessage += ` ${line.replace('[ERROR]', '').trim()}`;
            }
        }
        if (currentErrorList.length === 0 && projectErrorLog.includes('[ERROR]')) {
            // Check for empty error lines
            const notEmptyErrorLines = projectErrorLog
                .split(/\n/)
                .filter((line) => line.includes('[ERROR]') && line.trim() !== '[ERROR]');
            if (notEmptyErrorLines.length === 0) {
                // Ignore empty error lines
                continue;
            }
            // Check for non-parsable POM errors
            const nonParsablePomErrorLines = projectErrorLog
                .split(/\n/)
                .filter((line) => /\[FATAL\] Non-parseable POM/.test(line));
            if (nonParsablePomErrorLines.length > 0) {
                return {
                    success: false,
                    details: [
                        {
                            errorMessage: nonParsablePomErrorLines.join('\n'),
                            raw: projectErrorLog,
                        },
                    ],
                };
            }
            // Check for dependency convergence errors
            const enforcerPluginError = /\[ERROR\] Failed to execute goal org\.apache\.maven\.plugins:maven-enforcer-plugin:\d+(\.\d+)*(-[a-zA-Z0-9]+)?:enforce/;
            if (!skipDependencyConvergenceErrors &&
                projectErrorLog.replace(/\n/g, '').match(enforcerPluginError)) {
                const dependencyConvergenceErrors = parseDependencyConvergenceErrors(output);
                if ((dependencyConvergenceErrors === null || dependencyConvergenceErrors === void 0 ? void 0 : dependencyConvergenceErrors.length) !== 0) {
                    return {
                        success: false,
                        details: dependencyConvergenceErrors,
                    };
                }
                else {
                    // If no dependency convergence errors detected, skip the detection next time
                    skipDependencyConvergenceErrors = true;
                }
            }
            const errorMsg = parseConfigFileErrors(projectErrorLog)
                .replace(/\n|\[ERROR\]/g, ' ')
                .trim();
            currentErrorList.push({
                errorMessage: `
    === Config File error
    The below errors can be due to missing dependencies. You may have to refer
    to the config files provided earlier to solve it.
    'errorMessage': ${errorMsg}
`,
                raw: errorMsg,
            });
        }
        errors.push(...currentErrorList);
    }
    const result = {
        success: buildSuccessDetected,
        details: errors,
    };
    if (isMultiModule) {
        result.moduleBuildStatuses = moduleBuildStatuses;
    }
    return result;
}
function parseBuildSuccess(output) {
    const successPattern = /\[INFO\] BUILD SUCCESS/;
    return successPattern.test(output);
}
function parseModuleBuildResults(repoPath, output, moduleBuildStatuses) {
    const lines = output.split('\n');
    // Check if this is a multi-module project by looking for "Reactor Build Order"
    const reactorOrderStartPattern = /\[INFO\] Reactor Build Order:/;
    const isMultiModule = lines.some((line) => line.match(reactorOrderStartPattern));
    // If not a multi-module project, don't populate moduleBuildStatuses
    if (!isMultiModule) {
        return false;
    }
    // First pass: identify POM modules from Reactor Build Order
    const pomModules = new Set();
    // Map to store module paths for each module name
    const modulePathsMap = new Map();
    let inReactorBuildOrder = false;
    const reactorOrderEndPattern = /\[INFO\] -+</; // Any section header
    const modulePackagingPattern = /\[INFO\] ([^-][^:]+)[: ]+\[([^\]]+)\]/;
    // Extract POM modules from Reactor Build Order section
    for (const line of lines) {
        if (line.match(reactorOrderStartPattern)) {
            inReactorBuildOrder = true;
            continue;
        }
        if (inReactorBuildOrder) {
            if (line.match(reactorOrderEndPattern) && !line.includes('Reactor Build Order')) {
                inReactorBuildOrder = false;
                continue;
            }
            // This handles the format [INFO] module-name ................................. [pom]
            const moduleMatch = line.match(modulePackagingPattern);
            if (moduleMatch) {
                const [, moduleName, packaging] = moduleMatch;
                if (packaging.toLowerCase().includes('pom')) {
                    pomModules.add(moduleName.trim());
                }
            }
        }
    }
    // Extract groupId and artifactId information for each module
    // Maven output format (coordinate line always appears before building line):
    // 1. Project coordinate line: [INFO] --------------------< guc.bttsBtngan:chat-service >---------------------
    // 2. Building line: [INFO] Building Chat Service 0.0.1-SNAPSHOT [2/7]
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        // Match building line
        const buildingMatch = line.match(/\[INFO\] Building (.+?)\s+[\d.\-\w]+(?:\s+\[[\d/]+\])?(?:\r|\n|\r\n)?$/);
        if (buildingMatch) {
            const moduleName = buildingMatch[1].trim();
            // Look at the next line for the module path
            if (i + 1 < lines.length) {
                const nextLine = lines[i + 1];
                // Format: [INFO]   from <module-path>\pom.xml
                const pathMatch = nextLine.match(/\[INFO\]\s+from\s+(.+?)(?:\r|\n|\r\n)?$/);
                if (pathMatch) {
                    const modulePath = pathMatch[1].trim();
                    // Remove the trailing \pom.xml if present
                    const cleanPath = modulePath.replace(/\\pom\.xml$|\/pom\.xml$/, '');
                    // Store the module name to path mapping
                    modulePathsMap.set(moduleName, cleanPath);
                }
            }
        }
    }
    let inReactorSummary = false;
    // Update Reactor Summary pattern to support different Maven versions and formats
    // Modified to match "Reactor Summary for..." format and handle trailing carriage return
    const reactorSummaryStartPattern = /\[INFO\]\s+Reactor Summary.*?(?:\r|\n|\r\n)?$/;
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        // Check if we've entered the reactor summary section
        if (line.match(reactorSummaryStartPattern)) {
            inReactorSummary = true;
            continue;
        }
        if (inReactorSummary) {
            // Skip Reactor Summary header lines and empty lines
            if (line.includes('Reactor Summary') || line.trim() === '[INFO]') {
                continue;
            }
            // Handle various possible formats:
            // Format 1: [INFO] Project Name ................................ SUCCESS [ 1.234 s]
            // Format 2: [INFO] Project Name .......... SUCCESS [  2.345 s]
            // Format 3: [INFO] Project Name                                   SUCCESS [  2.345 s]
            const reactorModuleResult = line.match(/\[INFO\]\s+([^.]+?)(?:[.\s]+|\s{2,})(SUCCESS|FAILURE|SKIPPED)(?:.*?)(?:\r|\n|\r\n)?$/);
            if (reactorModuleResult) {
                const [, moduleName, status] = reactorModuleResult;
                const moduleNameTrimmed = moduleName.trim();
                // Only record status if it's not a POM module
                if (!pomModules.has(moduleNameTrimmed)) {
                    const isSuccess = status === 'SUCCESS';
                    // Use the module path as the key if available
                    let modulePath = modulePathsMap.get(moduleNameTrimmed);
                    if (!modulePath) {
                        // Try to find by partial match in the module names
                        for (const [mapKey, mapValue] of modulePathsMap.entries()) {
                            if (mapKey.includes(moduleNameTrimmed) ||
                                moduleNameTrimmed.includes(mapKey)) {
                                modulePath = mapValue;
                                break;
                            }
                        }
                    }
                    // If we still don't have a path, create a fallback path
                    if (!modulePath) {
                        // Use module name as a fallback
                        const moduleNamePath = moduleNameTrimmed.toLowerCase().replace(/\s+/g, '-');
                        modulePath = moduleNamePath;
                    }
                    moduleBuildStatuses.set(path_1.default.join(repoPath, modulePath), isSuccess);
                }
            }
            else if (line.trim() === '' ||
                !line.startsWith('[INFO]') ||
                line.includes('--------')) {
                // End of reactor summary section if we see a non-[INFO] line, empty line, or divider
                inReactorSummary = false;
            }
        }
    }
    return true;
}
function parseConfigFileErrors(log) {
    const error = log.split('[INFO] BUILD FAILURE').pop() || '';
    const errorPart = error
        // split on new line \r\n or \n
        .split(/\r\n|\n/)
        .map((line) => line.trim())
        .filter((line) => line.includes('[ERROR]'))
        .join('\n');
    if (errorPart.includes('[ERROR] -> [Help')) {
        return errorPart.split(/\[ERROR\] -> \[Help (.*)\]/g)[0].trim();
    }
    // the format of the help message is not consistent
    if (errorPart.includes('-> [Help')) {
        return errorPart.split(/-> \[Help (.*)\]/g)[0].trim();
    }
    // If the error is not in the expected format, return the whole error
    if (errorPart === '[ERROR]') {
        return `${log.trim()}`;
    }
    // otherwise just return the error part
    return `${errorPart}`;
}
function parseDependencyConvergenceErrors(output) {
    const errorStartPattern = 'Dependency convergence error';
    const errorEndPattern = '\n\n'; // Assuming the error ends with two new lines
    const dependencyConvergenceErrors = [];
    let errorLog = output;
    let startIndex;
    while ((startIndex = errorLog.indexOf(errorStartPattern)) !== -1) {
        errorLog = errorLog.slice(startIndex);
        const endIndex = errorLog.indexOf(errorEndPattern);
        if (endIndex === -1) {
            dependencyConvergenceErrors.push(errorLog.trim());
            break; // No more errors found
        }
        else {
            const errorMessage = errorLog.slice(0, endIndex).trim();
            dependencyConvergenceErrors.push(errorMessage);
            errorLog = errorLog.slice(endIndex + errorEndPattern.length);
        }
    }
    return dependencyConvergenceErrors.map((error) => {
        var _a;
        return ({
            errorMessage: ((_a = error.split(/\+-/)[0]) === null || _a === void 0 ? void 0 : _a.replace(/\n/, '').trim()) || errorStartPattern,
            raw: error,
        });
    });
}
// Create an enum for dependency tree vs effective pom
var MvnOutputType;
(function (MvnOutputType) {
    MvnOutputType["DependencyTree"] = "dt";
    MvnOutputType["EffectivePom"] = "ep";
})(MvnOutputType || (MvnOutputType = {}));
async function mvnDependencyTree(repoPath, mvn = 'mvn', env = Environment_1.Environment.Local, logger) {
    let output = '';
    let method = MvnOutputType.DependencyTree;
    try {
        output = await env.runCommand(repoPath, mvn, ['dependency:tree', '-B'], {
            exitOnError: false,
            throwIfFail: true,
            outputToConsole: false,
            includeStdErrInStdOut: true,
            logger,
        });
    }
    catch (_a) {
        output = await env.runCommand(repoPath, mvn, ['help:effective-pom', '-B'], {
            exitOnError: false,
            throwIfFail: true,
            outputToConsole: false,
            includeStdErrInStdOut: true,
        });
        method = MvnOutputType.EffectivePom;
    }
    return { output, method };
}
async function mvnDirectDependencies(repoPath, mvn = 'mvn', env = Environment_1.Environment.Local, logger) {
    const raw = await mvnDependencyTree(repoPath, mvn, env, logger);
    let parsed;
    if (raw.method === MvnOutputType.DependencyTree) {
        parsed = parseDirectDepsFromDependencyTree(raw.output);
    }
    else {
        parsed = parseDirectDepsFromEffectivePom(raw.output);
    }
    return { parsed: parsed, raw: raw.output };
}
function parseDirectDepsFromDependencyTree(output) {
    const result = {};
    const lines = output.split('\n');
    let currentProject;
    for (const line of lines) {
        // Match lines that contain project name. Note: maven and maven wrapper output differs.
        // Maven project format:          [INFO] --- dependency:3.1.2:tree (default-cli) @ shopizer ---
        // Maven wrapper project format:  [INFO] --- maven-dependency-plugin:3.1.2:tree (default-cli) @ shopizer ---
        const projectMatch = line.match(/--- (maven-dependency-plugin|dependency):.*:tree \(default-cli\) @ (.*?) ---/);
        // If project match, add dependencies to it until you find a new project
        if (projectMatch) {
            currentProject = projectMatch[2];
            result[currentProject] = [];
            continue;
        }
        else {
            // Match lines that contain dependencies in the format groupId:artifactId:version:type:scope
            const match = line.match(/\[INFO\]\s(\+|\\|\\\\)-\s*(([a-zA-Z0-9\\.\\-]+):([a-zA-Z0-9\\.\\-]+):([a-zA-Z0-9\\.\\-]+)(:([a-zA-Z0-9_\\-]+))?:([a-zA-Z0-9\\.\\-]+)+(:([a-zA-Z0-9\\.\\-]+))?)/);
            // Add dependency to the current project
            if (match && currentProject) {
                const [, , dependency] = match;
                result[currentProject].push((0, JavaDependency_utils_1.parseJavaDepCoord)(dependency));
            }
        }
    }
    return result;
}
function parseDirectDepsFromEffectivePom(pomContent) {
    const result = {};
    const matchProjectsInEffectivePomXML = pomContent.match(/<projects>[\s\S]*?<\/projects>/);
    if (matchProjectsInEffectivePomXML) {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(matchProjectsInEffectivePomXML[0], 'text/xml');
        const projectNodes = Array.from(xmlDoc.getElementsByTagName('project'));
        projectNodes.forEach((node) => {
            const [key, deps] = parseDirectDepsFromEffectivePomForProject(node);
            result[key] = deps;
        });
    }
    else {
        const matchProjectInEffectivePomXML = pomContent.match(/<project [\s\S]*?<\/project>/);
        if (!matchProjectInEffectivePomXML) {
            return {};
        }
        const parser = new DOMParser();
        const projectPomXml = parser.parseFromString(matchProjectInEffectivePomXML[0], 'text/xml');
        const [key, deps] = parseDirectDepsFromEffectivePomForProject(projectPomXml);
        result[key] = deps;
    }
    return result;
}
function parseDirectDepsFromEffectivePomForProject(projectPomXml) {
    var _a, _b, _c, _d, _e, _f;
    const currentProject = ((_a = Array.from(projectPomXml.childNodes).find((node) => node.nodeName === 'artifactId')) === null || _a === void 0 ? void 0 : _a.textContent) || '';
    if (currentProject.length === 0) {
        return [currentProject, []];
    }
    // Get all dependencies from the effective pom
    const dependencies = projectPomXml.getElementsByTagName('dependency');
    const result = [];
    for (const dependency of Array.from(dependencies)) {
        const groupId = ((_b = dependency.getElementsByTagName('groupId')[0]) === null || _b === void 0 ? void 0 : _b.textContent) || '';
        const artifactId = ((_c = dependency.getElementsByTagName('artifactId')[0]) === null || _c === void 0 ? void 0 : _c.textContent) || '';
        const version = ((_d = dependency.getElementsByTagName('version')[0]) === null || _d === void 0 ? void 0 : _d.textContent) || '';
        const type = ((_e = dependency.getElementsByTagName('type')[0]) === null || _e === void 0 ? void 0 : _e.textContent) || '';
        const scope = ((_f = dependency.getElementsByTagName('scope')[0]) === null || _f === void 0 ? void 0 : _f.textContent) || '';
        const mvnOpts = {
            // TODO: Probably don't need coordinate as we have gav. Also I don't think coordinate uses scope and maybe not type
            coordinate: `${groupId}:${artifactId}:${version}:${type}:${scope}`,
            groupId,
            artifactId,
            version,
            type,
            scope,
        };
        const dep = new JavaDependency_1.JavaDep(mvnOpts);
        // If this dependency (identifed by the coordinate) hasn't been added to the project yet, add it.
        if (!result.some((d) => d.coordinate === dep.coordinate)) {
            result.push(dep);
        }
    }
    return [currentProject, result];
}
async function runMvnCmd(repoPath, mvn = 'mvn', args, env = Environment_1.Environment.Local, logger, cmdInfo = undefined, runOptions = { logger, exitOnError: true, throwIfFail: true }) {
    logger === null || logger === void 0 ? void 0 : logger.info(`Running commands for ${repoPath} with Maven.`);
    await mvnVersion(repoPath, mvn, logger, env);
    logger === null || logger === void 0 ? void 0 : logger.info(`Command:\n\n${mvn} ${args.join(' ')}\n\n`);
    cmdInfo === null || cmdInfo === void 0 ? void 0 : cmdInfo(mvn, args);
    const stdOut = await env.runCommand(repoPath, mvn, args, runOptions);
    return stdOut;
}
//# sourceMappingURL=maven.js.map