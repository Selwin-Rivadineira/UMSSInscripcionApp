import { MCPLogger } from '../logger';
import { Settings } from '../settings';
import { McpEventEmitter } from '../telemetry/event';
import { Formula, KB, KBWithScore, McpContext, SearchOption } from '../types';
export interface IKBStore {
    findKbById(context: McpContext, kbId: string): Promise<KB[]>;
    searchKbs(context: McpContext, query: string): Promise<KBWithScore[]>;
    listKbs(context: McpContext): Promise<KB[]>;
    load(context: McpContext): Promise<void>;
}
export interface IKBStoreChangeCallbacks {
    onAdd(kb: KB): void;
    onChange(kb: KB): void;
    onDelete(path: string): void;
}
export interface IKBLoader {
    load(): Promise<KB[]>;
    onChange?(cb: IKBStoreChangeCallbacks): void;
}
export interface EmbeddingsProvider {
    computeEmbeddings(text: string): Promise<number[]>;
}
export interface Reranker {
    rerank(query: string, candidates: string[]): Promise<{
        index: number;
        score: number;
    }[]>;
}
/**
 * Represents a generic vector store for storing, updating, deleting, and searching items using vector embeddings.
 *
 * @typeParam T - The type of items stored in the vector store.
 *
 * Implementations of this interface should provide methods for generating embeddings,
 * managing items, and performing similarity searches based on vector representations.
 */
export interface VectorStore<T> {
    computeEmbeddings: {
        (text: string): Promise<number[]>;
    };
    distance: {
        (a: number[], b: number[]): number;
    };
    getItemIdentifier: {
        (item: T): string;
    };
    getHeaderContent: {
        (item: T): string;
    };
    /**
     * Add an item to the vector store
     */
    add(item: T): Promise<void>;
    /**
     * Update an item in the vector store
     */
    update(item: T): Promise<void>;
    /**
     * Remove an item from the vector store by its identifier
     */
    delete(identifier: string): Promise<void>;
    /**
     * Filter items in the vector store using a predicate function.
     */
    filter(predicate: (item: T) => boolean): Promise<T[]>;
    /**
     * Search for items similar to the query using vector similarity
     */
    search(query: string, threshold: number): Promise<{
        item: T;
        score: number;
    }[]>;
    /**
     * Get the number of items in the vector store
     */
    size(): Promise<number> | number;
    /**
     * Clear all items from the vector store
     */
    clear(): Promise<void> | void;
}
export declare class InMemoryVectorStore<T> implements VectorStore<T> {
    private embeddingsProvider;
    private logger;
    getItemIdentifier: (item: T) => string;
    getHeaderContent: (item: T) => string;
    getBodyContent: (item: T) => string;
    private items;
    private mutex;
    constructor(embeddingsProvider: EmbeddingsProvider, logger: MCPLogger, getItemIdentifier: (item: T) => string, getHeaderContent: (item: T) => string, getBodyContent: (item: T) => string);
    computeEmbeddings: (text: string) => Promise<number[]>;
    distance: typeof cosine;
    add(item: T): Promise<void>;
    update(item: T): Promise<void>;
    delete(identifier: string): Promise<void>;
    filter(predicate: (item: T) => boolean): Promise<T[]>;
    search(query: string, threshold: number): Promise<({
        item: T;
    } & {
        score: number;
    })[]>;
    size(): Promise<number>;
    clear(): Promise<void>;
}
export declare class KBSearchOptions {
    static byId(id: string | undefined): SearchOption<KB>;
    static byTitle(title: string | undefined): SearchOption<KB>;
    static byGroup(group: string | undefined): SearchOption<KB>;
    static byRegex(regex: RegExp): SearchOption<Formula>;
}
export declare class KBStore implements IKBStore {
    private loaders;
    private vectorStore;
    private reranker;
    private settings;
    private eventEmitter;
    private logger;
    private loaded;
    private mutex;
    constructor(loaders: IKBLoader[], vectorStore: VectorStore<KB>, reranker: Reranker, settings: Settings, eventEmitter: McpEventEmitter, logger: MCPLogger);
    load(context: McpContext): Promise<void>;
    addKb(kb: KB): Promise<void>;
    updateKb(kb: KB): Promise<void>;
    deleteKbByPath(filePath: string): Promise<void>;
    findKbById(context: McpContext, kbId: string): Promise<KB[]>;
    listKbs(context: McpContext): Promise<KB[]>;
    searchKbs(context: McpContext, query: string): Promise<KBWithScore[]>;
}
declare function cosine(a: number[], b: number[]): number;
export declare function formatKbHeader(kb: KB): string;
export declare function formatKbContent(kb: KB): string;
export declare function sanitize(text: string): string;
export {};
//# sourceMappingURL=store.d.ts.map