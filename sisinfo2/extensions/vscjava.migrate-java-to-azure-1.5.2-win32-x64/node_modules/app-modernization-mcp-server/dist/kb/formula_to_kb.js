"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormulaToKb = void 0;
exports.formatKbIdentifier = formatKbIdentifier;
const fs = __importStar(require("fs"));
const ignore_1 = __importDefault(require("ignore"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const path_1 = __importDefault(require("path"));
const tsyringe_1 = require("tsyringe");
const xregexp_1 = __importDefault(require("xregexp"));
const metadata_1 = require("../kb/metadata");
const settings_1 = require("../settings");
const types_1 = require("../types");
const utils_1 = require("../utils");
const loaders_1 = require("./loaders");
let FormulaToKb = class FormulaToKb {
    constructor(documentLoader, settings, logger) {
        this.documentLoader = documentLoader;
        this.settings = settings;
        this.logger = logger;
        this.getFullGroupId = (obj) => {
            const { formulaMetadata, parentMetadata } = obj.metadata;
            if (!(formulaMetadata === null || formulaMetadata === void 0 ? void 0 : formulaMetadata.group)) {
                return path_1.default.dirname(metadata_1.MetadataGetter.getRelativePath(obj));
            }
            return this.formatGroupId(formulaMetadata.group, parentMetadata === null || parentMetadata === void 0 ? void 0 : parentMetadata.group);
        };
        this.formatGroupId = (group, parentGroup) => {
            if (!group) {
                return '';
            }
            return parentGroup ? `${parentGroup.id}/${group.id}` : group.id;
        };
        if ((0, loaders_1.isDocumentLoaderWithWatcher)(this.documentLoader)) {
            this.documentLoader.watch();
        }
    }
    formulas() {
        return this.convert(this.formulaConverter.bind(this));
    }
    prompts() {
        return this.convert(this.promptConverter.bind(this));
    }
    async convert(converter) {
        try {
            const docs = await this.documentLoader.load();
            return docs.flatMap((doc) => {
                const { ok, converted } = converter(doc);
                if (ok && converted) {
                    return [converted];
                }
                return [];
            });
        }
        catch (error) {
            this.logger.error(`Failed to convert documents:`, error);
            return [];
        }
    }
    formulaConverter(doc) {
        try {
            const source = doc.metadata.source;
            if (source && source.endsWith(types_1.FORMULA_EXTENSION)) {
                const formula = js_yaml_1.default.load(doc.pageContent);
                if (!formula) {
                    throw new Error(`Failed to parse formula from ${source}`);
                }
                formula.metadata = doc.metadata;
                const validationResult = types_1.FormulaSchema.safeParse(formula);
                if (!validationResult.success) {
                    this.logger.warn(`Failed to validate formula from ${source}: ${validationResult.error}`);
                    return { ok: false, converted: {} };
                }
                return { ok: true, converted: formula };
            }
            return { ok: false, converted: {} };
        }
        catch (error) {
            this.logger.error(`Failed to convert document to formula: ${error}`);
            return { ok: false, converted: {} };
        }
    }
    promptConverter(doc) {
        const source = doc.metadata.source;
        if (source && source.endsWith(types_1.PROMPT_EXTENSION)) {
            return {
                ok: true,
                converted: { content: doc.pageContent, metadata: doc.metadata },
            };
        }
        return { ok: false, converted: {} };
    }
    formulaToKb(formula) {
        var _a;
        const source = metadata_1.MetadataGetter.getSource(formula);
        const parsedPath = path_1.default.parse(source);
        const { name, description, codeLocation, steps, metadata } = formula;
        const formulaMetadata = this.getFormulaMetadata(parsedPath.dir);
        const parentMetadata = this.getFormulaMetadata(path_1.default.dirname(parsedPath.dir));
        const finalMetadata = {
            ...(0, utils_1.omit)(formulaMetadata !== null && formulaMetadata !== void 0 ? formulaMetadata : {}, ['group']),
            ...metadata,
            parentMetadata,
            formulaMetadata,
        };
        let content = '';
        if (codeLocation) {
            content += `
### Search code
Search files from workspace using below patterns:
- Glob pattern to find files: \`${codeLocation.filePattern}\`
- Regex pattern to find code lines: \`${(0, xregexp_1.default)((_a = codeLocation.codePattern) !== null && _a !== void 0 ? _a : '').toString()}\`
> you could use tools to search code whatever if possible.
`;
        }
        content += steps
            .map((step) => {
            return `${step.type === 'diff' ? '### Code Diff' : '### Instruction'}\n\n${step.content}`;
        })
            .join('\n\n');
        return {
            id: formatKbIdentifier(formula),
            title: name,
            description,
            content,
            disabled: false,
            metadata: {
                docType: 'formula',
                ...finalMetadata,
                group: this.getFullGroupId({ metadata: finalMetadata }),
            },
        };
    }
    promptToKb(prompt) {
        const { content, metadata } = prompt;
        const source = metadata_1.MetadataGetter.getSource(prompt);
        const parsedPath = path_1.default.parse(source);
        const formulaMetadata = this.getFormulaMetadata(parsedPath.dir);
        const parentMetadata = this.getFormulaMetadata(path_1.default.dirname(parsedPath.dir));
        const finalMetadata = {
            ...(0, utils_1.omit)(formulaMetadata !== null && formulaMetadata !== void 0 ? formulaMetadata : {}, ['group']),
            ...metadata,
            parentMetadata,
            formulaMetadata,
        };
        return {
            id: formatKbIdentifier(prompt),
            title: path_1.default.basename(source, types_1.PROMPT_EXTENSION),
            description: `Prompt from ${source}`,
            content,
            disabled: false,
            metadata: {
                docType: 'prompt',
                ...finalMetadata,
                group: this.getFullGroupId({ metadata: finalMetadata }),
            },
        };
    }
    getFormulaMetadata(folder) {
        const metadataPath = path_1.default.join(folder, 'formula.metadata');
        if (fs.existsSync(metadataPath)) {
            const metadataContent = fs.readFileSync(metadataPath, 'utf-8');
            return js_yaml_1.default.load(metadataContent);
        }
        return undefined;
    }
    async load() {
        const formulas = await this.formulas();
        // const prompts = await this.prompts();
        const prompts = []; // Temporarily disable prompts until we need them
        const formulaKBs = formulas.map(this.formulaToKb.bind(this));
        const promptKBs = prompts.map(this.promptToKb.bind(this));
        return [...promptKBs, ...formulaKBs];
    }
    onChange(callbacks) {
        if (!(0, loaders_1.isDocumentLoaderWithWatcher)(this.documentLoader)) {
            this.logger.warn('Document loader does not support change events');
            return;
        }
        this.documentLoader.on('add', ({ doc }) => {
            const source = metadata_1.MetadataGetter.getSource(doc);
            if (source.endsWith(types_1.FORMULA_EXTENSION)) {
                const formula = this.formulaConverter(doc);
                if (formula.ok) {
                    callbacks.onAdd(this.formulaToKb(formula.converted));
                }
            }
            else if (source.endsWith(types_1.PROMPT_EXTENSION)) {
                const prompt = this.promptConverter(doc);
                if (prompt.ok) {
                    callbacks.onAdd(this.promptToKb(prompt.converted));
                }
            }
        });
        this.documentLoader.on('change', ({ doc }) => {
            const source = metadata_1.MetadataGetter.getSource(doc);
            if (source.endsWith(types_1.FORMULA_EXTENSION)) {
                const formula = this.formulaConverter(doc);
                if (formula.ok) {
                    callbacks.onChange(this.formulaToKb(formula.converted));
                }
            }
            else if (source.endsWith(types_1.PROMPT_EXTENSION)) {
                const prompt = this.promptConverter(doc);
                if (prompt.ok) {
                    callbacks.onChange(this.promptToKb(prompt.converted));
                }
            }
        });
        this.documentLoader.on('delete', ({ filePath }) => {
            if (filePath.endsWith(types_1.FORMULA_EXTENSION) || filePath.endsWith(types_1.PROMPT_EXTENSION)) {
                callbacks.onDelete(filePath);
                return;
            }
        });
    }
    buildIgnore(ignoreFilePath) {
        const ragignoreContent = fs.readFileSync(ignoreFilePath, 'utf-8');
        return (0, ignore_1.default)().add(ragignoreContent);
    }
};
exports.FormulaToKb = FormulaToKb;
exports.FormulaToKb = FormulaToKb = __decorate([
    (0, tsyringe_1.injectable)(),
    __param(0, (0, tsyringe_1.inject)(types_1.Beans.DocumentLoader)),
    __param(1, (0, tsyringe_1.inject)(types_1.Beans.Settings)),
    __param(2, (0, tsyringe_1.inject)(types_1.Beans.Logger)),
    __metadata("design:paramtypes", [Object, settings_1.Settings, Object])
], FormulaToKb);
function formatKbIdentifier(hasMetadata) {
    return `${metadata_1.MetadataGetter.getAuthor(hasMetadata)}://${metadata_1.MetadataGetter.getRelativePath(hasMetadata)}`;
}
//# sourceMappingURL=formula_to_kb.js.map