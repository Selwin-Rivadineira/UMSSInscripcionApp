#codebase

Migration Guide: Memcached → Azure Cache for Redis

### Context
Your Java project currently uses Memcached as a distributed cache
Key Points:
1. You need to migrate the entire project to use Azure Cache for Redis instead of Memcached, focusing on code changes, dependency updates, and configuration adjustments.
2. Please find suitable places to make the changes directly, like in-place modifying the pom.xml/build.gradle/application.yml file, write compilable code, don't leave uncompleted code blocks.
3. You need to change the all the Memcached cache related logic and keep other unchanged. At the same time, each place that uses Memcached API, must be replaced with Azure cache for redis ones.
4. Ignore data migration and infrastructure setup.
5. You should delete or comment out the original implementation, since the depdendency will be removed. Or we cannot pass the build.

---

### Key Differences & Migration Considerations
1. Architecture & Features:
   - Memcached: Simple key-value store, no persistence, no native data structures (e.g., lists, hashes).
   - Azure Redis: Supports rich data types (strings, lists, hashes, sets, sorted sets), persistence (RDB/AOF), and TLS encryption.
   - Action: Migrate basic key-value operations directly, but redesign logic using Redis-specific data structures where applicable.

2. Persistence & High Availability:
   - Memcached lacks built-in persistence; Azure Redis offers RDB snapshots and AOF logging.
   - Action: Enable Redis persistence (e.g., `maxmemory-policy` in Azure portal) if data durability is required.

---

### Migration Steps

#### 1. Dependency Replacement
- Remove Memcached Client:
  ```xml
  <!-- Remove Memcached dependencies (e.g., Spymemcached) -->
  <dependency>
      <groupId>net.spy</groupId>
      <artifactId>spymemcached</artifactId>
  </dependency>
  ```
- Add Redis Client:
  ```xml
  <dependency>
      <groupId>io.lettuce</groupId>
      <artifactId>lettuce-core</artifactId>
      <version>6.2.4</version>
  </dependency>
  <!-- Optional: Spring Data Redis -->
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
			<version>3.4.4</version>
  </dependency>
  ```

---

#### 2. Configuration Updates
Note: if it's a spring boot project, consider leveraging the spring boot properties file to init the redis connections. At the same time, Azure cache for Redis requires SSL -> true by default.
- Memcached Config → Redis SSL Connection:
  ```java
  // Memcached (remove)
  MemcachedClient client = new MemcachedClient(new InetSocketAddress("memcached-host", 11211));

  // Redis (new)
  RedisURI uri = RedisURI.Builder.redis("<AZURE_REDIS_HOST>")
      .withPort(6380)
      .withSsl(true)
      .withAuthentication("<USERNAME>", "<PASSWORD>")
      .build();
  RedisClient redisClient = RedisClient.create(uri);
  StatefulRedisConnection<String, String> connection = redisClient.connect();
  RedisCommands<String, String> commands = connection.sync();
  ```

- Optional: Spring Boot `application.yml` Configuration
  If using Spring Boot, update Redis properties (keep strict the same properties), and please also consider using the following configs in the redis connection file above:
  ```yaml
  spring:
    data:
      redis:
        host: <AZURE_REDIS_HOST>
        port: 6380
        username: <USERNAME>
        password: <PASSWORD>
				ssl:
          enabled: true
        lettuce:
          pool:
            max-active: 20  # Optimize for Azure Redis connection limits
  ```

---

#### 3. Code Refactoring

You need to find all the distributed cache related usages and replace them with Azure cache for redis implementation base on the guides below:

##### 3.1 Basic Key-Value Operations
- Set/Get:
  ```java
  // Memcached
  client.set("key", 3600, "value");
  String value = (String) client.get("key");

  // Redis
  commands.set("key", "value");
  commands.expire("key", 3600);  // TTL in seconds
  String value = commands.get("key");
  ```

- CAS (Check-and-Set):
  Memcached’s `cas` has no direct equivalent. Use Redis transactions with `WATCH`:
  ```java
  commands.watch("key");
  String currentValue = commands.get("key");
  commands.multi();
  commands.set("key", "new-value");
  commands.exec();  // Fails if "key" is modified by another client
  ```

##### 3.2 Distributed Locks
- Memcached `add` → Redis `SETNX`:
  ```java
  // Memcached
  boolean locked = client.add("lock-key", 10, "owner");

  // Redis
  String result = commands.set("lock-key", "owner", SetArgs.Builder.nx().ex(10));
  boolean locked = "OK".equals(result);
  ```

##### 3.3 Data Structure Migration
- Counters:
  ```java
  // Memcached
  client.incr("counter", 1);

  // Redis
  commands.incr("counter");
  ```

- List/Queue:
  ```java
  // Memcached (no native list support; simulated via app logic)
  // Redis
  commands.lpush("task-queue", "task1");
  String task = commands.rpop("task-queue");
  ```

---

#### 4. Data Migration Strategies
1. Dual-Write During Transition:
   Write to both Memcached and Redis temporarily:
   ```java
   // Write to both caches
   memcachedClient.set("key", 0, "value");
   redisCommands.set("key", "value");
   ```

2. Custom Script for Bulk Migration:
   Use a tool like `redis-copy` to migrate data programmatically:
   ```bash
   # Export from Memcached (third-party tools required)
   # Import to Redis using DUMP/RESTORE
   ```

---

#### 5. Advanced Configuration
1. Performance Tuning:
   - Connection Pooling: Azure Redis supports up to 40,000 connections (Premium tier).
   - Pipelining: Batch operations to reduce round-trip latency.
     ```java
     RedisFuture<String> future1 = commands.set("key1", "value1");
     RedisFuture<String> future2 = commands.set("key2", "value2");
     LettuceFutures.awaitAll(10, TimeUnit.SECONDS, future1, future2);
     ```

2. Security:
   - Enable TLS 1.2+ (mandatory for Azure Redis).
   - Use Microsoft Entra ID for authentication in Premium tiers.

---

### Error Handling & Monitoring
- Exceptions:
  - Replace Memcached `OperationTimeoutException` with Redis `RedisCommandTimeoutException`.
  - Handle `RedisCommandExecutionException` for invalid commands (e.g., `FLUSHDB` in Azure Redis Basic tier).
- Monitoring:
  Use Azure Portal metrics (e.g., `cache hits`, `latency`) to validate migration success.

---
### Pass the build
Use this command to check whether the project can pass the build after migration. If not, fix any build error and make sure it pass the build.
For windows:
```
cmd /c "mvn clean compile -B -fn -DskipTests -Dossindex.failOnError=false -Dossindex.skip=true -Dlicense.skip=true -Dcheckstyle.skip=true -Dencoding=UTF-8"
```
For Linux / macOS:
```
mvn clean compile -B -fn -DskipTests -Dossindex.failOnError=false -Dossindex.skip=true -Dlicense.skip=true -Dcheckstyle.skip=true -Dencoding=UTF-8
```

### Key Takeaways
1. Feature Gap: Redis offers richer data types and persistence; redesign logic to leverage these.
2. Dual-Write Strategy: Minimize downtime by synchronizing data during migration.
3. Performance: Optimize connection pooling and use Redis pipelines for bulk operations.
