#codebase

Migration Guide: Oracle Coherence → Azure Cache for Redis

---

### Context
Your Java project currently uses Oracle Coherence as a distributed cache
Key Points:
1. You need to migrate the entire project to use Azure Cache for Redis instead of Oracle Coherence, focusing on code changes, dependency updates, and configuration adjustments.
2. Please find suitable places to make the changes directly, like in-place modifying the pom.xml/build.gradle/application.yml file, write compilable code, don't leave uncompleted code blocks.
3. You need to change the all the Oracle Coherence cache related logic and keep other unchanged. At the same time, each place that uses Oracle Coherence API, must be replaced with Azure cache for redis ones.
4. Ignore data migration and infrastructure setup.
5. You should delete or comment out the original implementation, since the depdendency will be removed. Or we cannot pass the build.

---

### Actionable Steps

#### 1. Dependency Replacement
Remove Coherence and add Redis Client (e.g., Lettuce or Jedis):
```xml
<!-- Remove Coherence dependencies -->
<dependency>
    <groupId>com.oracle.coherence</groupId>
    <artifactId>coherence</artifactId>
    <version>22.06</version>
</dependency>

<!-- Add Lettuce (Redis client) -->
<dependency>
    <groupId>io.lettuce</groupId>
    <artifactId>lettuce-core</artifactId>
    <version>6.2.4</version>
</dependency>

<!-- Optional: Spring Data Redis -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
    <version>3.4.4</version>
</dependency>
```

---

#### 2. Configuration Changes
Note: if it's a spring boot project, consider leveraging the spring boot properties file to init the redis connections. At the same time, Azure cache for Redis requires SSL -> true by default.
Replace Coherence Cluster Config with Redis SSL/TLS Connection:
```java
// Coherence (remove)
CacheFactory.ensureCluster();
NamedCache<String, String> cache = CacheFactory.getCache("myCache");

// Redis (new)
RedisURI uri = RedisURI.Builder.redis("<AZURE_REDIS_HOST>")
    .withPort(6380)
    .withSsl(true)  // Azure Redis requires SSL
    .withAuthentication("<USERNAME>", "<PASSWORD>")
    .build();
RedisClient client = RedisClient.create(uri);
StatefulRedisConnection<String, String> connection = client.connect();
RedisCommands<String, String> commands = connection.sync();
```

Optional: Spring Boot `application.yml` Configuration
  If using Spring Boot, update Redis properties (keep strict the same properties), and please also consider using the following configs in the redis connection file above:
```yaml
spring:
  data:
    redis:
      host: <AZURE_REDIS_HOST>
      port: 6380
      username: <USERNAME>
      password: <PASSWORD>
      ssl:
        enabled: true
      lettuce:
        pool:
          max-active: 20  # Optimize connection pooling
```

---

#### 3. Code Refactoring and Replacement

You need to find all the distributed cache related usages and replace them with Azure cache for redis implementation base on the guides below:

##### 3.1 Basic Cache Operations
- Put/Get:
  ```java
  // Coherence
  cache.put("key", "value");
  String value = (String) cache.get("key");


  commands.set("key", "value");
  String value = commands.get("key");
  ```

- Entry Processors → Lua Scripts:
  ```java
  // Coherence
  cache.invoke("key", entry -> {
    entry.setValue(entry.getValue() + "-modified");
    return null;
  });

  // Redis (Lua script)
  String script = "redis.call('SET', KEYS[1], ARGV[1] .. '-modified')";
  commands.eval(script, ScriptOutputType.STATUS, new String[]{"key"}, "value");
  ```

##### 3.2 Distributed Locks
```java
// Coherence
Lock lock = cache.lock("key");
lock.lock();
try { /* critical section */ } finally { lock.unlock(); }

// Redis (SETNX-based lock)
String result = commands.set("lock-key", "owner", SetArgs.Builder.nx().ex(10));
if ("OK".equals(result)) {
  try { /* critical section */ } finally { commands.del("lock-key"); }
}
```

##### 3.3 Query Support
- Coherence Filters → Redis Alternatives:
  ```java
  // Coherence
  Filter filter = new EqualsFilter("getRole", "admin");
  Set<Map.Entry> admins = cache.entrySet(filter);

  // Redis (store metadata in hashes and query client-side)
  Map<String, String> user = commands.hgetall("user:1001");
  if ("admin".equals(user.get("role"))) { /* ... */ }
  ```

---

#### 4. Advanced Features
##### 4.1 Partitioned Caches
- Coherence Data Partitioning → Redis Cluster:
  ```java
  // Coherence (automatic sharding) → Redis Cluster
  RedisClusterClient clusterClient = RedisClusterClient.create("redis://<HOST>:<PORT>");
  StatefulRedisClusterConnection<String, String> clusterConn = clusterClient.connect();
  ```

##### 4.2 Cache Loaders/Stores
- Read-Through/Write-Through:
  ```java
  // Coherence (via CacheStore) → Implement explicitly
  String value = commands.get("key");
  if (value == null) {
    value = fetchFromDatabase("key"); // Custom logic
    commands.set("key", value);
  }
  ```

##### 4.3 Transactions
```java
// Coherence
CacheTransactionManager txMgr = CacheFactory.getCacheTransactionManager();
txM();
cache.put("key", "value");
txMgr.commit();

// Redis
commands.multi();
commands.set("key1", "value1");
commands.set("key2", "value2");
commands.exec();
```

---

#### 5. Error Handling
- Coherence Exceptions (e.g., `CoherenceException`) → Redis Exceptions (e.g., `RedisCommandExecutionException`):
  ```java
  try {
    commands.get("key");
  } catch (RedisException e) {
    // Handle connection/timeout issues
  }
  ```

---

### Pass the build
Use this command to check whether the project can pass the build after migration. If not, fix any build error and make sure it pass the build.
For windows:
```
cmd /c "mvn clean compile -B -fn -DskipTests -Dossindex.failOnError=false -Dossindex.skip=true -Dlicense.skip=true -Dcheckstyle.skip=true -Dencoding=UTF-8"
```
For Linux / macOS:
```
mvn clean compile -B -fn -DskipTests -Dossindex.failOnError=false -Dossindex.skip=true -Dlicense.skip=true -Dcheckstyle.skip=true -Dencoding=UTF-8
```

### Key Takeaways
1. Dependency Cleanup: Remove Coherence JARs; use Lettuce/Jedis for Redis.
2. SSL/TLS: Azure Redis requires SSL on port 6380.
3. Data Structure Mapping:
   - Coherence `NamedCache` → Redis `String`/`Hash` keys.
   - Coherence `EntryProcessor` → Redis Lua scripts.
4. Performance: Use connection pooling and Redis pipelining for bulk operations.
