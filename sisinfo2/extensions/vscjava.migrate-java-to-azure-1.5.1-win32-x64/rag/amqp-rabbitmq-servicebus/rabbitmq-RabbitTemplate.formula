name: "Migrate RabbitTemplate"
description: "Migrate RabbitTemplate to ServiceBusTemplate"

codeLocation:
  type: textsearch
  filePattern: '**/*.java'
  codePattern: "(?i)RabbitTemplate|AmqpTemplate|AmqpHeaders"

steps:
  - description: "Migrate RabbitTemplate send methods to ServiceBusTemplate"
    type: "instruction"
    content: |
      Your task is to migrate a Java file from using the RabbitMQ send methods to the Azure Service Bus send methods while maintaining the same functionality. Below is a reference to the relevant APIs for your convenience. You can tell whether it's a rabbitmq or Azure API from the package name.
      Try replace all references to RabbitMQ APIs with equivalent Azure Service Bus APIs, using the provided API descriptions as guidance.
      Ensure the resulting code is clean, efficient, and preserves the original functionality.
      These rules are required when do the migration:
        - When constructing the service bus message, check if there is a routing key in the context. If a routing key is present, set it as the message header named ServiceBusMessageHeaders.SUBJECT. If there is no routing key, do not set the SUBJECT header.
        - When migrating RabbitMQ message properties / headers to service bus message headers, find the other associated message headers from org.springframework.messaging.MessageHeaders and com.azure.spring.messaging.servicebus.support.ServiceBusMessageHeaders.
          1. If RabbitMQ uses the Spring standard message headers, then don't need to migrate them.
          2. If RabbitMQ uses its own properties, try to find any applicable Spring standard Message Headers first, otherwise replace with Service Bus Message Headers.
          3. Remove RabbitMQ properties directly if there is no associated message headers from Spring or Service Bus.
        - ServiceBusTemplate with empty or null parameter is not allowed.
        - *DO NOT* optimize the code blocks not directly related to the migration changes, *KEEP* those commented out code, minimize the amount of code changes.
        - When migrating code to service bus, make sure to add the necessary imports for every newly add class.
        - RabbitTemplate#receive, RabbitTemplate#receiveAndConvert methods and other overloadings are not supported to be migrated to ServiceBusTemplate. You need to use com.azure.messaging.servicebus.ServiceBusReceiverClient to receive messages. To leverage the ServiceBusReceiverClient, use the Spring Bean of com.azure.messaging.servicebus.ServiceBusClientBuilder which is provided by the Spring Cloud Azure Starter automatically, then create the receiver client by the client builder:
            1. Autowire the bean of ServiceBusClientBuilder, com.azure.identity.DefaultAzureCredential and com.azure.spring.cloud.autoconfigure.implementation.servicebus.properties.AzureServiceBusProperties from the application context
            2. Create the ServiceBusReceiverClient(s) from the ServiceBusClientBuilder using the DefaultAzureCredential bean as the credential and fully qualified namespace from the AzureServiceBusProperties
            3. Configure the queue or topic/subscription to the receiver according to the topology
            4. Replace the source code of receiving messages from RabbitTemplate to ServiceBusReceiverClient.
            5. Find the proper place to close the client(s).
        - RabbitTemplate#sendAndReceive, RabbitTemplate#convertSendAndReceive and other overloadings can be migrated to ServiceBusTemplate#sendAndReceive. Note for ServiceBusTemplate, there is no overloadings for the sendAndReceive method, so you should use this method for all the RPC scenarios. The introduction of ServiceBusTemplate#sendAndReceive can be finded in the next API section.
          To use ServiceBusTemplate#sendAndReceive method, there are several prerequisites:
            1. Define a Spring Bean of PropertiesSupplier<ConsumerIdentifier, ConsumerProperties> to enable the session property for receiver client used within ServiceBusTemplate.
            2. Analyse the codebase to find the RabbitMQ reply_to entity, and convert it to a Service Bus entity.
            3. Every time before calling the sendAndReceive method, you should configure the org.springframework.messaging.MessageHeaders.REPLY_CHANNEL header with the reply_to queue/topic entity name for the message to be sent.
        - For the scenario of receive and reply, which is calling RabbitTemplate to send messages within a @RabbitListener, and the sending target is from the message header similar as "amqp_replyTo", then you should migrate is to ServiceBusTemplate following the below instuctions:
            1. get the sending target from the message header of org.springframework.messaging.MessageHeaders.REPLY_CHANNEL.
            2. when sending messages as the reply, set the message header com.azure.spring.messaging.servicebus.support.ServiceBusMessageHeaders.SESSION_ID with the value from the header ServiceBusMessageHeaders.REPLY_TO_SESSION_ID of the incoming messages.
        - The RabbitTemplate#setReturnsCallback and RabbitTemplate#setConfirmCallback methods are not compatable with Service Bus, and need to be removed directly instead of being migrated.
        - Import Cleanup:
          - Remove all AMQP-related imports after migration
          - All imports from packages starting with 'org.springframework.amqp'
          - All imports from packages starting with 'com.rabbitmq'
          - Any other unused imports that were related to RabbitMQ

      Below are the APIs provided for your reference:

      Interface: RabbitTemplate
        Package: org.springframework.amqp.rabbit.core
        Methods:
          - RabbitTemplate()
            Description: Convenient constructor for use with setter injection.
          - RabbitTemplate(ConnectionFactory connectionFactory)
            Description: Create a rabbit template with default strategies and settings.
          - setMessageConverter(MessageConverter messageConverter)
            Description: Set the message converter for this template.
            Parameters:
              - messageConverter: The message converter
            Returns: Void
          - convertAndSend(Object object)
            Description: Convert a Java object to an Amqp Message and send it to a default exchange with a default routing key.
            Parameters:
              - object: a message to send
            Returns: Void
          - convertAndSend(String routingKey, Object object)
            Description: Convert a Java object to an Amqp Message and send it to a default exchange with a specific routing key.
            Parameters:
              - routingKey: the routing key
              - object: a message to send
            Returns: Void
          - convertAndSend(String exchange, String routingKey, Object object)
            Description: Convert a Java object to an Amqp Message and send it to a specific exchange with a specific routing key.
            Parameters:
              - exchange: the name of the exchange
              - routingKey: the routing key
              - object: a message to send
            Returns: Void
          - setReturnsCallback(ReturnCallback returnCallback)
            Description: Set a callback to receive returned messages. When migrating to Service Bus, this method does not need to be migrated because ServiceBusTemplate doesn't support receive messages, so it should be removed directly.
            Parameters:
              - returnCallback: the callback.
            Returns: Void
          - setConfirmCallback(ConfirmCallback confirmCallback)
            Description: Set a callback function to receive the message publishing confirmation result
            Parameters:
              - confirmCallback: the callback
            Returns: Void
          - receive()
            Description: Receive a message from a default queue. Note: all receive() method and other overloadings should be migrated to ServiceBusReceiverClient's various receive methods, which can be autowired into a Bean from the application context.
             Parameters: void
            Returns: Message
          - receiveAndConvert()
            Description: Receive a message if there is one from a default queue and convert it to a Java object. Returns immediately, possibly with a null value. Note: all receiveAndConvert() method and other overloadings should be migrated to ServiceBusReceiverClient's various receive methods, which can be autowired into a Bean from the application context.
             Parameters: void
            Returns: Object

      Interface: ServiceBusTemplate
        Package: com.azure.spring.messaging.servicebus.core
        Description: Azure Service Bus template to support send Message
        Methods:
          - setMessageConverter(AzureMessageConverter<ServiceBusReceivedMessage, ServiceBusMessage> messageConverter)
            Description: Set the message converter to use.
            Parameters:
              - messageConverter: the message converter
            Returns: Void
          - send(String destination, Message<T> message)
            Description: Send a Message to the given destination synchronously.
            Parameters:
              - destination: destination
              - message: message
            Returns: Void
          - sendAsync(String destination, Message<T> message)
            Description: Send a Message to the given destination asynchronously.
            Parameters:
              - destination: destination
              - message: message
            Returns: Void
          - sendAndReceive(String destination, ServiceBusEntityType entityType, Message<T> message)
            Description: Basic RPC pattern usage. Send a message to the destination and wait for a reply message from the replay channel, which must be specified by the message header org.springframework.messaging.MessageHeaders#REPLY_CHANNEL and the session must be enabled
            Parameters:
              - destination: the destination topic or queue name
              - entityType: type of Service Bus entity
              - message: Message to be sent to the Service Bus entity.
            Returns: ServiceBusReceivedMessage - the reply message of the response. If the reply message fails to be obtained, null is returned.

      Class: ServiceBusReceiverClient
        Package: com.azure.messaging.servicebus
        Description: A synchronous receiver responsible for receiving ServiceBusReceivedMessage from a queue or topic/subscription on Azure Service Bus.
        Methods: 
          - receiveMessages(int maxMessages)
            Description: Receives an iterable stream of messages from the Service Bus entity.
            Parameters:
              - maxMessages: The maximum number of messages to receive.
            Returns: IterableStream<ServiceBusReceivedMessage>
          - abandon(ServiceBusReceivedMessage message)
            Description: Abandons a message.
            Parameters:
              - message: The ServiceBusReceivedMessage to perform this operation.
            Returns: Void
          - complete(ServiceBusReceivedMessage message)
            Description: Completes a message.
            Parameters:
              - message: The ServiceBusReceivedMessage to perform this operation.
            Returns: Void

      Interface: Message<T>
        Package: org.springframework.messaging
        Description: A generic message representation with headers and body.
        Methods:
          - getPayload()
            Returns: T
          - getHeaders()
            Returns: MessageHeaders

      Interface: MessageBuilder<T>
        Package: org.springframework.messaging.support
        Description: A builder for creating GenericMessage, where T is the message payload type
        Methods:
          - setHeader(String headerName, @Nullable Object headerValue)
            Description: Set the value for the given header name. If the provided value is null, the header will be removed.
            Parameters:
              - headerName: the name of the header
              - headerValue: the value of the header
            Returns: MessageBuilder<T>
          - withPayload(<T> payload)
            Description: Create a new builder for a message with the given payload.
            Parameters:
              - payload: the payload
            Returns: MessageBuilder<T>
          - build()
            Description: build a message
            Returns: Message<T>

      Below are the supported Spring and Service Bus message headers:

      Constants: CONTENT_TYPE
        Class: MessageHeaders
        Package: org.springframework.messaging
        Description: The RFC2045 Content-Type descriptor of the message.

      Constants: REPLY_CHANNEL
        Class: MessageHeaders
        Package: org.springframework.messaging
        Description: The address of an entity to send replies to.

      Constants: CORRELATION_ID
        Class: ServiceBusMessageHeaders
        Package: com.azure.spring.messaging.servicebus.support
        Description: The correlation ID of the message.

      Constants: REPLY_TO_SESSION_ID
        Class: ServiceBusMessageHeaders
        Package: com.azure.spring.messaging.servicebus.support
        Description: The ReplyToGroupId property value of the message.

      Constants: SCHEDULED_ENQUEUE_TIME
        Class: ServiceBusMessageHeaders
        Package: com.azure.spring.messaging.servicebus.support
        Description: The datetime at which the message should be enqueued in Service Bus, this header should be mapped with RabbitMQ's delay message property.

      Constants: SESSION_ID
        Class: ServiceBusMessageHeaders
        Package: com.azure.spring.messaging.servicebus.support
        Description: The session identifier for a session-aware entity.

      Constants: TIME_TO_LIVE
        Class: ServiceBusMessageHeaders
        Package: com.azure.spring.messaging.servicebus.support
        Description: The duration of time before this message expires.

      Constants: SUBJECT
        Class: ServiceBusMessageHeaders
        Package: com.azure.spring.messaging.servicebus.support
        Description: The subject for the message.

      Example migrations:

      1. Migrate the RabbitTemplate.convertAndSend to ServiceBusTemplate.send with routing key
        ```java
        // before
        rabbitTemplate.convertAndSend("topic", "routing.key", strMessage);

        // after
        Message<String> message = MessageBuilder.withPayload(strMessage)
            .setHeader(ServiceBusMessageHeaders.SUBJECT, "routing.key").build();
        serviceBusTemplate.send("topic", message);
        ```

      2. Migrate the RabbitTemplate.convertAndSend to ServiceBusTemplate.send without routing key
        ```java
        // before
        rabbitTemplate.convertAndSend("queueName", strMessage);

        // after
        Message<String> message = MessageBuilder.withPayload(strMessage).build();
        serviceBusTemplate.send("queueName", message);
        ```

      3. Example of migrating rabbitmq message properties to Spring standard message headers:
        ```java
        // before
        MessageProperties properties = new MessageProperties();
        properties.setContentType(MessageProperties.CONTENT_TYPE_JSON);
        Message responseMessage = new Message(responseString.getBytes(), properties);

        // after
        Message<String> responseMessage = MessageBuilder.withPayload(responseString)
            .setHeader(MessageHeaders.CONTENT_TYPE, "application/json")
            .build();
        ```

      4. Example of migrating rabbitmq message properties to Service Bus message headers:
        ```java
        // before
        long delayTime = ChronoUnit.MILLIS.between(LocalDateTime.now(), localDateTime);
        MessageProperties properties = new MessageProperties();
        properties.setDelay((int) delayTime);
        Message message = new Message(payload, messageProperties);
        rabbitTemplate.convertAndSend("destination","binding-key", message);

        // after
        Message<String> responseMessage = MessageBuilder.withPayload(payload)
            .setHeader(ServiceBusMessageHeaders.SUBJECT, "binding-key")
            .setHeader(ServiceBusMessageHeaders.SCHEDULED_ENQUEUE_TIME, OffsetDateTime.now().plus(Duration.ofMillis(delayTime)))
            .build();
        serviceBusTemplate.send("destination", message);
        ```

      5. Example of migrating RabbitTemplate#sendAndReceive to ServiceBusTemplate#sendAndReceive
        ```java
        // before for RabbitMQ
        Message msg = new Message(message.getBytes());
        log.info("RPC INVOCATION TO RABBITMQ");
        Object response = rabbitTemplate.sendAndReceive(inputBinding.getExchangeName(), inputBinding.getRoutineKey(), msg);
        if (response instanceof byte[]) {
            return new String((byte[]) response, StandardCharsets.UTF_8);
        }

        //after for Service Bus
        // 1. add a Bean of PropertiesSupplier<ConsumerIdentifier, ConsumerProperties> in a Configuration class
        @Bean
        PropertiesSupplier<ConsumerIdentifier, ConsumerProperties> consumerPropertiesSupplier() {
            return key -> {
                ConsumerProperties consumerProperties = new ConsumerProperties();
                consumerProperties.setSessionEnabled(true);
                return consumerProperties;
            };
        }
        // 2. Analyse the source codebase to find the reply_to rabbitmq entity and its migrated Service Bus entity, then set the message header of REPLY_CHANNEL with that entity
        Map<String, Object> headers = new HashMap<>();
        headers.put(MessageHeaders.REPLY_CHANNEL, RPC_QUEUE_REPLY_NAME);
        Message<ProductOfferEvent> message = MessageBuilder.createMessage(message.getBytes(), new MessageHeaders(headers));
        // 3. call ServiceBusTemplate#sendAndReceive
        ServiceBusReceivedMessage replyMessage = serviceBusTemplate.sendAndReceive(inputBinding.getExchangeName(), ServiceBusEntityType.QUEUE, message);
        if (replyMessage != null && replyMessage.getBody() != null) {
            return message.getBody().toString();
        }
        ```
      6. Example of Receive and Reply, ignore the difference for the listener annotation:
        ```java
        // before for RabbitMQ
        @RabbitListener(bindings = {
                @QueueBinding(
                        value = @Queue,
                        exchange = @Exchange(value = RabbitMQConfiguration.EXCHANGE_NAME, type = ExchangeTypes.TOPIC),
                        key = "prepend"
                )
        })
        public void onMessage(StringMessage msg, Message message) {
            String text = msg.getBody();
            System.out.println("PrependHello.onMessage - " + text);
            String result = "hello, " + text;
            template.convertAndSend(message.getMessageProperties().getReplyTo(), new StringMessage(result));
        }
        //after for Service Bus
        @ServiceBusListener(destination = RabbitMQConfiguration.EXCHANGE_NAME, group = RabbitMQConfiguration.SUBSCRIPTION_PREPEND)
        public void onMessage(StringMessage msg, Message<?> message) {
            String text = msg.getBody();
            System.out.println("PrependHello.onMessage - " + text);
            String result = "hello, " + text;

            Message<?> sbMessage = MessageBuilder
                    .withPayload(new StringMessage(result))
                    .setHeader(ServiceBusMessageHeaders.SESSION_ID, message.getHeaders().get(ServiceBusMessageHeaders.REPLY_TO_SESSION_ID))
                    .build();

            serviceBusTemplate.send(message.getHeaders().get(MessageHeaders.REPLY_CHANNEL).toString(), sbMessage);
        }
        ```
