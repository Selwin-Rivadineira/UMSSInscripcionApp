#codebase

**Prompt for Migrating Java Project from Spring Boot Cache (In-Memory) to Azure Cache for Redis**

---


### Context
Your Java project currently uses Spring Boot Cache as a distributed cache
Key Points:
1. You need to migrate the entire project to use Azure Cache for Redis instead of Spring Boot Cache, focusing on code changes, dependency updates, and configuration adjustments.
2. Please find suitable places to make the changes directly, like in-place modifying the pom.xml/build.gradle/application.yml file, write compilable code, don't leave uncompleted code blocks.
3. You need to change the all the Spring Boot Cache cache related logic and keep other unchanged. At the same time, each place that uses Spring Boot Cache API, must be replaced with Azure cache for redis ones.
4. Ignore data migration and infrastructure setup.
5. You should delete or comment out the original implementation, since the depdendency will be removed. Or we cannot pass the build.

---

### **Key Areas of Focus**
1. **Dependency Replacement**: Add Redis dependencies while retaining Spring Cache abstractions.
2. **Configuration Overhaul**: Replace in-memory cache settings with Redis connection details and serialization configurations.
3. **Annotation Retention**: Keep Spring Cache annotations (`@Cacheable`, `@CacheEvict`) but align them with Redis’s distributed caching behavior.
4. **Distributed Caching**: Transition from local in-memory caching to Redis’s shared, scalable cache.

---

### **Actionable Steps**

#### **1. Update Dependencies**
- **Add Redis Dependency** (required for Redis integration):
  ```xml
  <dependency>
    <groupId>io.lettuce</groupId>
    <artifactId>lettuce-core</artifactId>
    <version>6.2.4</version>
  </dependency>
  <!-- Optional: Spring Boot Redis Starter -->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
    <version>3.4.4</version>
  </dependency>
  ```

---

#### **2. Configure Redis Connection**
- **Update `application.properties` and setup connections**:
  ```
  RedisURI uri = RedisURI.Builder.redis("<AZURE_REDIS_HOST>")
      .withPort(6380)
      .withSsl(true)
      .withAuthentication("<access-key>")
      .build();
  RedisClient client = RedisClient.create(uri);
  StatefulRedisConnection<String, String> connection = client.connect();
  RedisCommands<String, String> commands = connection.sync();

  ```
- Optional: Spring Boot `application.yml` Configuration
  If using Spring Boot, update Redis properties (keep strict the same properties), and please also consider using the following configs in the redis connection file above:
  ```yaml
  spring:
    data:
      redis:
        host: <AZURE_REDIS_HOST>
        port: 6380
        username: <USERNAME>
        password: <PASSWORD>
        ssl:
          enabled: true
    # Optional: Enable Azure passwordless authentication
    cloud:
      azure:
        redis:
          passwordless-enabled: true
  ```

---

#### **3. Replace In-Memory Cache with Redis**
- **Configure `RedisCacheManager`** (to override the default `ConcurrentMapCacheManager`):
  ```java
  @Configuration
  @EnableCaching
  public class RedisConfig extends CachingConfigurerSupport {
    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory factory) {
      return RedisCacheManager.builder(factory)
        .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig()
          .entryTtl(Duration.ofHours(1))
          .disableCachingNullValues()
          .serializeValuesWith(RedisSerializationContext.SerializationPair
            .fromSerializer(new GenericJackson2JsonRedisSerializer())))
        .build();
    }
  }
  ```
  *This configures TTL, disables null caching, and uses JSON serialization for readability.*

---

#### **4. Retain and Align Cache Annotations**
- **Keep Spring Cache Annotations**:
  ```java
  @Service
  public class ProductService {
    @Cacheable(value = "products", key = "#id")
    public Product getProduct(String id) { /* ... */ }
  }
  ```
  *No changes needed to annotations, but ensure keys align with Redis naming conventions (e.g., no spaces).*

---

#### **5. Handle Serialization**
- **Avoid Binary Data in Redis**:
  Customize `RedisTemplate` to use JSON instead of Java serialization:
  ```java
  @Bean
  public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
    RedisTemplate<String, Object> template = new RedisTemplate<>();
    template.setConnectionFactory(factory);
    template.setKeySerializer(new StringRedisSerializer());
    template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
    return template;
  }
  ```
  *This ensures human-readable data in Redis.*

---

### **Example Migration**
**Before (Spring Boot In-Memory Cache)**:
```java
// Default behavior with ConcurrentMapCacheManager
@Cacheable("users")
public User getUser(Long id) { /* ... */ }
```

**After (Redis)**:
```java
// Same annotation, now backed by Redis
@Cacheable(value = "users", key = "#id")
public User getUser(Long id) { /* ... */ }
```

### Pass the build
Use this command to check whether the project can pass the build after migration. If not, fix any build error and make sure it pass the build.
For windows:
```
cmd /c "mvn clean compile -B -fn -DskipTests -Dossindex.failOnError=false -Dossindex.skip=true -Dlicense.skip=true -Dcheckstyle.skip=true -Dencoding=UTF-8"
```
For Linux / macOS:
```
mvn clean compile -B -fn -DskipTests -Dossindex.failOnError=false -Dossindex.skip=true -Dlicense.skip=true -Dcheckstyle.skip=true -Dencoding=UTF-8
```
