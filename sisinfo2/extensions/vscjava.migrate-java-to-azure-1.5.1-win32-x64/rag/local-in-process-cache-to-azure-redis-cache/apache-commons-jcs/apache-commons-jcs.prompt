#codebase

**Prompt for Migrating Java Project from Apache Commons JCS to Azure Cache for Redis**

---


### Context
Your Java project currently uses Apache Commons JCS as a distributed cache
Key Points:
1. You need to migrate the entire project to use Azure Cache for Redis instead of Apache Commons JCS, focusing on code changes, dependency updates, and configuration adjustments.
2. Please find suitable places to make the changes directly, like in-place modifying the pom.xml/build.gradle/application.yml file, write compilable code, don't leave uncompleted code blocks.
3. You need to change the all the Apache Commons JCS cache related logic and keep other unchanged. At the same time, each place that uses Apache Commons JCS API, must be replaced with Azure cache for redis ones.
4. Ignore data migration and infrastructure setup.
5. You should delete or comment out the original implementation, since the depdendency will be removed. Or we cannot pass the build.

---

### **Key Areas of Focus**
1. **Dependency Replacement**: Remove JCS dependencies and add Azure Redis libraries.
2. **Configuration Overhaul**: Replace JCS-specific `.properties` or `cache.ccf` files with Redis connection settings.
3. **Code Refactoring**: Transition from JCS `CacheAccess`/`GroupCacheAccess` APIs to Redis-compatible interfaces (e.g., `RedisTemplate`, Spring Cache annotations).
4. **Behavior Alignment**: Adapt JCS features like disk overflow, memory policies, and distributed caching to Redis equivalents.

---

### **Actionable Steps**

#### **1. Update Dependencies**
- **Remove JCS Dependencies**:
  ```xml
  <!-- Remove JCS from pom.xml -->
  <dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-jcs-core</artifactId>  <!-- For JCS 2.x -->
    <version>2.2.1</version>
  </dependency>
  <!-- OR for JCS 3.x -->
  <dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-jcs3-core</artifactId>
    <version>3.0</version>
  </dependency>
  ```
- **Add Redis Dependency**:
  ```xml
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
    <version>5.2.0</version>
</dependency>
<!-- Optional: Spring Boot Redis Starter -->
    <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
    <version>3.4.4</version>
</dependency>
  ```
  *Note:* JCS 3.x uses package `org.apache.commons.jcs3` instead of `org.apache.commons.jcs`.

---

#### **2. Configure Redis Connection**
- Configure Azure Redis Connection
    Implement secure connection with Microsoft Entra ID authentication:
    ```java
    // Jedis library doesn't support passing in AzureCredentials, so fall back to access key solution
    JedisPoolConfig poolConfig = new JedisPoolConfig();
    poolConfig.setMaxTotal(50); // Match WebSphere thread pool

    JedisPool pool = new JedisPool(poolConfig,
        "<your-cache>.redis.cache.windows.net",
        6380,
        2000,
        "<your-access-key>",
        true // SSL
    );
    ```

- Optional: Spring Boot `application.yml` Configuration
  If using Spring Boot, update Redis properties (keep strict the same properties), and please also consider using the following configs in the redis connection file above:
  ```yaml
  spring:
    data:
      redis:
        host: <AZURE_REDIS_HOST>
        port: 6380
        username: <USERNAME>
        password: <PASSWORD>
				ssl:
          enabled: true
        lettuce:
          pool:
            max-active: 20  # Optimize for Azure Redis connection limits
  ```
---

#### **3. Replace JCS Code Logic**
- **Refactor Cache Initialization**:
  **Before (JCS)**:
  ```java
  import org.apache.commons.jcs3.JCS;
  import org.apache.commons.jcs3.access.CacheAccess;

  public class UserCache {
    private CacheAccess<String, User> userCache;
    public UserCache() {
      this.userCache = JCS.getInstance("userCache");  // JCS region setup
    }
    public void addUser(String userId, User user) {
      userCache.put(userId, user);
    }
  }
  ```
  **After (Redis)**:
  ```java
  import org.springframework.data.redis.core.RedisTemplate;

  @Service
  public class UserCache {
    @Autowired
    private RedisTemplate<String, User> redisTemplate;

    public void addUser(String userId, User user) {
      redisTemplate.opsForValue().set(userId, user);
    }
  }
  ```

- **Replace Memory/Disk Hybrid Logic**:
  JCS often combines memory and disk caching (e.g., `LRUMemoryCache` with `IndexedDiskCache`). Redis uses in-memory storage with optional persistence. Remove JCS disk overflow logic and rely on Redis’s `maxmemory-policy` (configured via Azure portal).

---

#### **4. Align Caching Behaviors**
- **TTL and Eviction**:
  - **JCS**: Configured via `MaxLifeSeconds` or `IdleTime` in `ElementAttributes`.
  - **Redis**: Use `@Cacheable` with `ttl` or configure in `RedisCacheManager`:
    ```java
    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory factory) {
      return RedisCacheManager.builder(factory)
        .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig()
          .entryTtl(Duration.ofHours(1)))
        .build();
    }
    ```
- **Distributed Caching**:
  JCS supports remote caching via `RemoteCache`. Replace with Redis’s native clustering or use `RedisTemplate` for cross-instance synchronization.

---

#### **5. Handle Advanced Features**
- **Event Listeners**:
  JCS allows custom event handlers (e.g., `ElementEventHandler`). Replace with Redis Pub/Sub or `KeyspaceNotifications` for similar functionality.
- **Serialization**:
  JCS uses Java serialization by default. Configure Redis to use `Jackson2JsonRedisSerializer` or `GenericJackson2JsonRedisSerializer` for JSON storage.

---

### **Example Migration**
**Before (JCS Disk + Memory Configuration)**:
```properties
# JCS cache.ccf
jcs.default=DC
jcs.auxiliary.DC=org.apache.commons.jcs3.auxiliary.disk.indexed.IndexedDiskCacheFactory
jcs.auxiliary.DC.attributes.DiskPath=/cache/data
```
**After (Redis)**:
```java
// Configure TTL in RedisCacheManager
@Bean
public RedisCacheManager cacheManager(RedisConnectionFactory factory) {
  return RedisCacheManager.builder(factory)
    .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig()
      .entryTtl(Duration.ofHours(1)))
    .build();
}
```

### Pass the build
Use this command to check whether the project can pass the build after migration. If not, fix any build error and make sure it pass the build.
For windows:
```
cmd /c "mvn clean compile -B -fn -DskipTests -Dossindex.failOnError=false -Dossindex.skip=true -Dlicense.skip=true -Dcheckstyle.skip=true -Dencoding=UTF-8"
```
For Linux / macOS:
```
mvn clean compile -B -fn -DskipTests -Dossindex.failOnError=false -Dossindex.skip=true -Dlicense.skip=true -Dcheckstyle.skip=true -Dencoding=UTF-8
```
