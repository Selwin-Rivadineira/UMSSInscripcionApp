#codebase

**Prompt for Migrating Java Project from OSCache to Azure Cache for Redis**

---


### Context
Your Java project currently uses OSCache as a distributed cache
Key Points:
1. You need to migrate the entire project to use Azure Cache for Redis instead of OSCache, focusing on code changes, dependency updates, and configuration adjustments.
2. Please find suitable places to make the changes directly, like in-place modifying the pom.xml/build.gradle/application.yml file, write compilable code, don't leave uncompleted code blocks.
3. You need to change the all the OSCache cache related logic and keep other unchanged. At the same time, each place that uses OSCache API, must be replaced with Azure cache for redis ones.
4. Ignore data migration and infrastructure setup.
5. You should delete or comment out the original implementation, since the depdendency will be removed. Or we cannot pass the build.

---

### **Key Areas of Focus**
1. **Dependency Replacement**: Remove OSCache dependencies and add Azure Redis libraries.
2. **Configuration Overhaul**: Replace OSCache’s `.properties` or XML configurations with Redis settings.
3. **Code Refactoring**: Transition from OSCache’s `CacheAccess` API or JSP tags to Redis-compatible interfaces (`RedisTemplate`, Spring Cache annotations).
4. **Behavior Alignment**: Adapt TTL, distributed caching (via JGroups), and eviction policies to Redis capabilities.

---

### **Actionable Steps**

#### **1. Update Dependencies**
- **Remove OSCache Dependencies**:
  ```xml
  <!-- Remove OSCache from pom.xml -->
  <dependency>
    <groupId>opensymphony</groupId>
    <artifactId>oscache</artifactId>
    <version>2.4.1</version>
  </dependency>
  <!-- Remove JGroups if used for clustering -->
  <dependency>
    <groupId>org.jgroups</groupId>
    <artifactId>jgroups</artifactId>
  </dependency>
  ```
- **Add Redis Dependency**:
  ```xml
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
    <version>5.2.0</version>
</dependency>
<!-- Optional: Spring Boot Redis Starter -->
    <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
    <version>3.4.4</version>
</dependency>
  ```
  *Note:* For manual Redis operations, include `Jedis` or `Lettuce` client.

---

#### **2. Configure Redis Connection**
- Configure Azure Redis Connection
    Implement secure connection with Microsoft Entra ID authentication:
    ```java
    // Jedis library doesn't support passing in AzureCredentials, so fall back to access key solution
    JedisPoolConfig poolConfig = new JedisPoolConfig();
    poolConfig.setMaxTotal(50); // Match WebSphere thread pool

    JedisPool pool = new JedisPool(poolConfig,
        "<your-cache>.redis.cache.windows.net",
        6380,
        2000,
        "<your-access-key>",
        true // SSL
    );
    ```
- Optional: Spring Boot `application.yml` Configuration
  If using Spring Boot, update Redis properties (keep strict the same properties), and please also consider using the following configs in the redis connection file above:
  ```yaml
  spring:
    data:
      redis:
        host: <AZURE_REDIS_HOST>
        port: 6380
        username: <USERNAME>
        password: <PASSWORD>
				ssl:
          enabled: true
        lettuce:
          pool:
            max-active: 20  # Optimize for Azure Redis connection limits
  ```
---

#### **3. Refactor Code Logic**
- **Replace OSCache API Calls**:
  **Before (OSCache)**:
  ```java
  import com.opensymphony.oscache.base.Cache;
  import com.opensymphony.oscache.general.GeneralCacheAdministrator;

  public class ProductService {
    private Cache cache = new GeneralCacheAdministrator().getCache();
    public Product getProduct(String id) {
      return (Product) cache.getFromCache(id);
    }
  }
  ```
  **After (Redis)**:
  ```java
  import org.springframework.data.redis.core.RedisTemplate;

  @Service
  public class ProductService {
    @Autowired
    private RedisTemplate<String, Product> redisTemplate;

    public Product getProduct(String id) {
      return redisTemplate.opsForValue().get(id);
    }
  }
  ```

- **Replace JSP Caching Tags**:
  **Before (OSCache JSP tags)**:
  ```jsp
  <cache:cache key="product_${id}" time="3600">
    <!-- Dynamic content -->
  </cache:cache>
  ```
  **After (Redis with Spring Cache)**:
  ```java
  @Cacheable(value = "product", key = "#id", unless = "#result == null")
  public Product getProduct(String id) { /* ... */ }
  ```
  *Use Spring `@Cacheable`/`@CacheEvict` annotations for declarative caching.*

---

#### **4. Align Caching Behaviors**
- **TTL Configuration**:
  OSCache allows per-entry TTL (e.g., `cache.put(key, value, 3600)`). In Redis:
  ```java
  // Global TTL via RedisCacheManager
  @Bean
  public RedisCacheManager cacheManager(RedisConnectionFactory factory) {
    return RedisCacheManager.builder(factory)
      .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig()
        .entryTtl(Duration.ofHours(1)))
      .build();
  }
  ```
  *For per-entry TTL, use `redisTemplate.expire(key, ttl, TimeUnit)`.*

- **Distributed Caching**:
  OSCache uses JGroups for clustering. Replace with Redis’s built-in clustering (configured via Azure portal). Remove JGroups listeners and properties like `cache.cluster.multicast.ip`.

- **Eviction Policies**:
  OSCache supports LRU/FIFO algorithms (e.g., `cache.algorithm=com.opensymphony.oscache.base.algorithm.LRUCache`). In Redis, configure `maxmemory-policy` (e.g., `allkeys-lru`) via Azure portal.

---

#### **5. Handle Advanced Features**
- **Event Listeners**:
  OSCache’s `CacheEntryEventListener` can be replaced with Redis Pub/Sub or `KeyspaceNotifications` for cache expiration events.
- **Serialization**:
  OSCache uses Java serialization by default. Configure Redis to use JSON serialization for interoperability:
  ```java
  @Bean
  public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
    RedisTemplate<String, Object> template = new RedisTemplate<>();
    template.setDefaultSerializer(new GenericJackson2JsonRedisSerializer());
    template.setConnectionFactory(factory);
    return template;
  }
  ```

---

### **Example Migration**
**Before (OSCache Configuration)**:
```properties
# oscache.properties
cache.memory=true
cache.capacity=10000
cache.cluster.properties=UDP(mcast_addr=231.12.21.132;...)
```

**After (Redis)**:
```properties
# application.properties
spring.redis.host=your-redis-host.redis.cache.windows.net
spring.redis.ssl=true
```

### Pass the build
Use this command to check whether the project can pass the build after migration. If not, fix any build error and make sure it pass the build.
For windows:
```
cmd /c "mvn clean compile -B -fn -DskipTests -Dossindex.failOnError=false -Dossindex.skip=true -Dlicense.skip=true -Dcheckstyle.skip=true -Dencoding=UTF-8"
```
For Linux / macOS:
```
mvn clean compile -B -fn -DskipTests -Dossindex.failOnError=false -Dossindex.skip=true -Dlicense.skip=true -Dcheckstyle.skip=true -Dencoding=UTF-8
```
