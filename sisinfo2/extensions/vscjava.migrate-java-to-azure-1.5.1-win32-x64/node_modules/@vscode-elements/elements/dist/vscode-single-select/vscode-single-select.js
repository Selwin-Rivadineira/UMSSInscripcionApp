var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html, LitElement } from 'lit';
import { property, query } from 'lit/decorators.js';
import { customElement } from '../includes/VscElement.js';
import { chevronDownIcon } from '../includes/vscode-select/template-elements.js';
import { VscodeSelectBase } from '../includes/vscode-select/vscode-select-base.js';
import styles from './vscode-single-select.styles.js';
import { findNextSelectableOptionIndex, findPrevSelectableOptionIndex, } from '../includes/vscode-select/helpers.js';
/**
 * Allows to select an item from multiple options.
 *
 * When participating in a form, it supports the `:invalid` pseudo class. Otherwise the error styles
 * can be applied through the `invalid` property.
 *
 * @tag vscode-single-select
 *
 * ## Types
 *
 * ```typescript
 *interface Option {
 *  label: string;
 *  value: string;
 *  description: string;
 *  selected: boolean;
 *  disabled: boolean;
 *}
 * ```
 * @prop {boolean} invalid
 * @attr {boolean} invalid
 * @attr name - Name which is used as a variable name in the data of the form-container.
 *
 * @cssprop [--dropdown-z-index=2]
 * @cssprop [--vscode-badge-background=#616161]
 * @cssprop [--vscode-badge-foreground=#f8f8f8]
 * @cssprop [--vscode-settings-dropdownBorder=#3c3c3c]
 * @cssprop [--vscode-settings-checkboxBackground=#313131]
 * @cssprop [--vscode-settings-dropdownBackground=#313131]
 * @cssprop [--vscode-settings-dropdownForeground=#cccccc]
 * @cssprop [--vscode-settings-dropdownListBorder=#454545]
 * @cssprop [--vscode-focusBorder=#0078d4]
 * @cssprop [--vscode-foreground=#cccccc]
 * @cssprop [--vscode-font-family=sans-serif]
 * @cssprop [--vscode-font-size=13px]
 * @cssprop [--vscode-font-weight=normal]
 * @cssprop [--vscode-inputValidation-errorBackground=#5a1d1d]
 * @cssprop [--vscode-inputValidation-errorBorder=#be1100]
 * @cssprop [--vscode-list-activeSelectionBackground=#04395e]
 * @cssprop [--vscode-list-activeSelectionForeground=#ffffff]
 * @cssprop [--vscode-list-focusOutline=#0078d4]
 * @cssprop [--vscode-list-focusHighlightForeground=#2aaaff]
 * @cssprop [--vscode-list-highlightForeground=#2aaaff]
 * @cssprop [--vscode-list-hoverBackground=#2a2d2e]
 * @cssprop [--vscode-list-hoverForeground=#ffffff]
 */
let VscodeSingleSelect = class VscodeSingleSelect extends VscodeSelectBase {
    set selectedIndex(val) {
        this._selectedIndex = val;
        if (this._options[val]) {
            this._activeIndex = val;
            this._value = this._options[val].value;
            this._internals.setFormValue(this._value);
            this._manageRequired();
        }
        else {
            this._value = '';
            this._internals.setFormValue('');
            this._manageRequired();
        }
    }
    get selectedIndex() {
        return this._selectedIndex;
    }
    set value(val) {
        if (this._options[this._selectedIndex]) {
            this._options[this._selectedIndex].selected = false;
        }
        this._selectedIndex = this._options.findIndex((op) => op.value === val);
        if (this._selectedIndex > -1) {
            this._options[this._selectedIndex].selected = true;
            this._value = val;
            this._requestedValueToSetLater = '';
        }
        else {
            this._value = '';
            this._requestedValueToSetLater = val;
        }
        this._internals.setFormValue(this._value);
        this._manageRequired();
    }
    get value() {
        if (this._options[this._selectedIndex]) {
            return this._options[this._selectedIndex]?.value ?? '';
        }
        return '';
    }
    get validity() {
        return this._internals.validity;
    }
    get validationMessage() {
        return this._internals.validationMessage;
    }
    get willValidate() {
        return this._internals.willValidate;
    }
    checkValidity() {
        return this._internals.checkValidity();
    }
    reportValidity() {
        return this._internals.reportValidity();
    }
    updateInputValue() {
        if (!this.combobox) {
            return;
        }
        const input = this.renderRoot.querySelector('.combobox-input');
        if (input) {
            input.value = this._options[this._selectedIndex]
                ? this._options[this._selectedIndex].label
                : '';
        }
    }
    constructor() {
        super();
        this.defaultValue = '';
        /** @internal */
        this.role = 'listbox';
        this.name = undefined;
        this.required = false;
        /**
         * This variable was introduced for cases where the value is set before the corresponding option
         * exists. This can happen while a framework like Vue or React is rendering the component.
         */
        this._requestedValueToSetLater = '';
        /** @internal */
        this._multiple = false;
        this._internals = this.attachInternals();
    }
    connectedCallback() {
        super.connectedCallback();
        this.updateComplete.then(() => {
            this._manageRequired();
        });
    }
    /** @internal */
    formResetCallback() {
        this.value = this.defaultValue;
    }
    /** @internal */
    formStateRestoreCallback(state, _mode) {
        this.updateComplete.then(() => {
            this.value = state;
        });
    }
    /** @internal */
    get type() {
        return 'select-one';
    }
    get form() {
        return this._internals.form;
    }
    async _createAndSelectSuggestedOption() {
        const nextIndex = this._createSuggestedOption();
        await this.updateComplete;
        this.selectedIndex = nextIndex;
        this._dispatchChangeEvent();
        const opCreateEvent = new CustomEvent('vsc-single-select-create-option', { detail: { value: this._options[nextIndex]?.value ?? '' } });
        this.dispatchEvent(opCreateEvent);
        this._toggleDropdown(false);
        this._isPlaceholderOptionActive = false;
    }
    _onSlotChange() {
        super._onSlotChange();
        if (this._requestedValueToSetLater) {
            // the value is set before the available options are appended
            const foundIndex = this._options.findIndex((op) => op.value === this._requestedValueToSetLater);
            if (foundIndex > 0) {
                this._selectedIndex = foundIndex;
                this._requestedValueToSetLater = '';
            }
        }
        if (this._selectedIndex > -1 && this._options.length > 0) {
            this._internals.setFormValue(this._options[this._selectedIndex].value);
            this._manageRequired();
        }
        else {
            this._internals.setFormValue(null);
            this._manageRequired();
        }
    }
    _onArrowUpKeyDown() {
        super._onArrowUpKeyDown();
        if (this.open || this._selectedIndex <= 0) {
            return;
        }
        const options = this.combobox ? this._filteredOptions : this._options;
        const prevIndex = findPrevSelectableOptionIndex(options, this._activeIndex);
        this._filterPattern = '';
        this._selectedIndex = prevIndex;
        this._activeIndex = prevIndex;
        this._value = prevIndex > -1 ? this._options[prevIndex].value : '';
        this._internals.setFormValue(this._value);
        this._manageRequired();
        this._dispatchChangeEvent();
    }
    _onArrowDownKeyDown() {
        super._onArrowDownKeyDown();
        if (this.open || this._selectedIndex >= this._options.length - 1) {
            return;
        }
        const options = this.combobox ? this._filteredOptions : this._options;
        const nextIndex = findNextSelectableOptionIndex(options, this._activeIndex);
        this._filterPattern = '';
        this._selectedIndex = nextIndex;
        this._activeIndex = nextIndex;
        this._value = nextIndex > -1 ? this._options[nextIndex].value : '';
        this._internals.setFormValue(this._value);
        this._manageRequired();
        this._dispatchChangeEvent();
    }
    _onEnterKeyDown(ev) {
        super._onEnterKeyDown(ev);
        this.updateInputValue();
        this._internals.setFormValue(this._value);
        this._manageRequired();
    }
    _onOptionClick(ev) {
        super._onOptionClick(ev);
        const composedPath = ev.composedPath();
        const optEl = composedPath.find((et) => {
            const el = et;
            if ('matches' in el) {
                return el.matches('li.option');
            }
            return;
        });
        if (!optEl || optEl.matches('.disabled')) {
            return;
        }
        const isPlaceholderOption = optEl.classList.contains('placeholder');
        if (isPlaceholderOption) {
            if (this.creatable) {
                this._createAndSelectSuggestedOption();
            }
        }
        else {
            this._selectedIndex = Number(optEl.dataset.index);
            this._value = this._options[this._selectedIndex].value;
            this._toggleDropdown(false);
            this._internals.setFormValue(this._value);
            this._manageRequired();
            this._dispatchChangeEvent();
        }
    }
    _manageRequired() {
        const { value } = this;
        if (value === '' && this.required) {
            this._internals.setValidity({ valueMissing: true }, 'Please select an item in the list.', this._face);
        }
        else {
            this._internals.setValidity({});
        }
    }
    _renderSelectFace() {
        const label = this._options[this._selectedIndex]?.label ?? '';
        return html `
      <div
        class="select-face face"
        @click=${this._onFaceClick}
        tabindex=${this.tabIndex > -1 ? 0 : -1}
      >
        <span class="text">${label}</span> ${chevronDownIcon}
      </div>
    `;
    }
};
VscodeSingleSelect.styles = styles;
/** @internal */
VscodeSingleSelect.shadowRootOptions = {
    ...LitElement.shadowRootOptions,
    delegatesFocus: true,
};
/** @internal */
VscodeSingleSelect.formAssociated = true;
__decorate([
    property({ attribute: 'default-value' })
], VscodeSingleSelect.prototype, "defaultValue", void 0);
__decorate([
    property({ type: String, attribute: true, reflect: true })
], VscodeSingleSelect.prototype, "role", void 0);
__decorate([
    property({ reflect: true })
], VscodeSingleSelect.prototype, "name", void 0);
__decorate([
    property({ type: Number, attribute: 'selected-index' })
], VscodeSingleSelect.prototype, "selectedIndex", null);
__decorate([
    property({ type: String })
], VscodeSingleSelect.prototype, "value", null);
__decorate([
    property({ type: Boolean, reflect: true })
], VscodeSingleSelect.prototype, "required", void 0);
__decorate([
    query('.face')
], VscodeSingleSelect.prototype, "_face", void 0);
VscodeSingleSelect = __decorate([
    customElement('vscode-single-select')
], VscodeSingleSelect);
export { VscodeSingleSelect };
//# sourceMappingURL=vscode-single-select.js.map