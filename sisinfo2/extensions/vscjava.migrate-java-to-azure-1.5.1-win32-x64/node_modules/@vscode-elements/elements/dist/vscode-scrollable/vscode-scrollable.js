var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html, nothing } from 'lit';
import { property, query, queryAssignedElements, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { customElement, VscElement } from '../includes/VscElement.js';
import { stylePropertyMap } from '../includes/style-property-map.js';
import styles from './vscode-scrollable.styles.js';
/**
 * @tag vscode-scrollable
 *
 * @cssprop [--min-thumb-height=20px] - Scrollbar thumb minimum height
 * @cssprop [--vscode-scrollbar-shadow=#000000]
 * @cssprop [--vscode-scrollbarSlider-background=rgba(121, 121, 121, 0.4)]
 * @cssprop [--vscode-scrollbarSlider-hoverBackground=rgba(100, 100, 100, 0.7)]
 * @cssprop [--vscode-scrollbarSlider-activeBackground=rgba(191, 191, 191, 0.4)]
 */
let VscodeScrollable = class VscodeScrollable extends VscElement {
    constructor() {
        super(...arguments);
        this.shadow = true;
        this.scrolled = false;
        this._isDragging = false;
        this._thumbHeight = 0;
        this._thumbY = 0;
        this._thumbVisible = false;
        this._thumbFade = false;
        this._thumbActive = false;
        this._scrollThumbStartY = 0;
        this._mouseStartY = 0;
        this._scrollbarVisible = true;
        this._scrollbarTrackZ = 0;
        this._resizeObserverCallback = () => {
            this._updateScrollbar();
        };
        this._onSlotChange = () => {
            this._zIndexFix();
        };
        this._onScrollThumbMouseMoveBound = this._onScrollThumbMouseMove.bind(this);
        this._onScrollThumbMouseUpBound = this._onScrollThumbMouseUp.bind(this);
        this._onComponentMouseOverBound = this._onComponentMouseOver.bind(this);
        this._onComponentMouseOutBound = this._onComponentMouseOut.bind(this);
    }
    set scrollPos(val) {
        this._scrollableContainer.scrollTop = val;
    }
    get scrollPos() {
        if (!this._scrollableContainer) {
            return 0;
        }
        return this._scrollableContainer.scrollTop;
    }
    get scrollMax() {
        if (!this._scrollableContainer) {
            return 0;
        }
        return this._scrollableContainer.scrollHeight;
    }
    connectedCallback() {
        super.connectedCallback();
        this._hostResizeObserver = new ResizeObserver(this._resizeObserverCallback);
        this._contentResizeObserver = new ResizeObserver(this._resizeObserverCallback);
        this.requestUpdate();
        this.updateComplete.then(() => {
            this._scrollableContainer.addEventListener('scroll', this._onScrollableContainerScroll.bind(this));
            this._hostResizeObserver.observe(this);
            this._contentResizeObserver.observe(this._contentElement);
        });
        this.addEventListener('mouseover', this._onComponentMouseOverBound);
        this.addEventListener('mouseout', this._onComponentMouseOutBound);
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this._hostResizeObserver.unobserve(this);
        this._hostResizeObserver.disconnect();
        this._contentResizeObserver.unobserve(this._contentElement);
        this._contentResizeObserver.disconnect();
        this.removeEventListener('mouseover', this._onComponentMouseOverBound);
        this.removeEventListener('mouseout', this._onComponentMouseOutBound);
    }
    _updateScrollbar() {
        const compCr = this.getBoundingClientRect();
        const contentCr = this._contentElement.getBoundingClientRect();
        if (compCr.height >= contentCr.height) {
            this._scrollbarVisible = false;
        }
        else {
            this._scrollbarVisible = true;
            this._thumbHeight = compCr.height * (compCr.height / contentCr.height);
        }
        this.requestUpdate();
    }
    _zIndexFix() {
        let highestZ = 0;
        this._assignedElements.forEach((n) => {
            if ('style' in n) {
                const computedZIndex = window.getComputedStyle(n).zIndex;
                const isNumber = /([0-9-])+/g.test(computedZIndex);
                if (isNumber) {
                    highestZ =
                        Number(computedZIndex) > highestZ
                            ? Number(computedZIndex)
                            : highestZ;
                }
            }
        });
        this._scrollbarTrackZ = highestZ + 1;
        this.requestUpdate();
    }
    _onScrollThumbMouseDown(event) {
        const cmpCr = this.getBoundingClientRect();
        const thCr = this._scrollThumbElement.getBoundingClientRect();
        this._mouseStartY = event.screenY;
        this._scrollThumbStartY = thCr.top - cmpCr.top;
        this._isDragging = true;
        this._thumbActive = true;
        document.addEventListener('mousemove', this._onScrollThumbMouseMoveBound);
        document.addEventListener('mouseup', this._onScrollThumbMouseUpBound);
    }
    _onScrollThumbMouseMove(event) {
        const predictedPos = this._scrollThumbStartY + (event.screenY - this._mouseStartY);
        let nextPos = 0;
        const cmpH = this.getBoundingClientRect().height;
        const thumbH = this._scrollThumbElement.getBoundingClientRect().height;
        const contentH = this._contentElement.getBoundingClientRect().height;
        if (predictedPos < 0) {
            nextPos = 0;
        }
        else if (predictedPos > cmpH - thumbH) {
            nextPos = cmpH - thumbH;
        }
        else {
            nextPos = predictedPos;
        }
        this._thumbY = nextPos;
        this._scrollableContainer.scrollTop =
            (nextPos / (cmpH - thumbH)) * (contentH - cmpH);
    }
    _onScrollThumbMouseUp(event) {
        this._isDragging = false;
        this._thumbActive = false;
        const cr = this.getBoundingClientRect();
        const { x, y, width, height } = cr;
        const { pageX, pageY } = event;
        if (pageX > x + width || pageX < x || pageY > y + height || pageY < y) {
            this._thumbFade = true;
            this._thumbVisible = false;
        }
        document.removeEventListener('mousemove', this._onScrollThumbMouseMoveBound);
        document.removeEventListener('mouseup', this._onScrollThumbMouseUpBound);
    }
    _onScrollableContainerScroll() {
        const scrollTop = this._scrollableContainer.scrollTop;
        this.scrolled = scrollTop > 0;
        const cmpH = this.getBoundingClientRect().height;
        const thumbH = this._scrollThumbElement.getBoundingClientRect().height;
        const contentH = this._contentElement.getBoundingClientRect().height;
        const overflown = contentH - cmpH;
        const ratio = scrollTop / overflown;
        this._thumbY = ratio * (cmpH - thumbH);
    }
    _onComponentMouseOver() {
        this._thumbVisible = true;
        this._thumbFade = false;
    }
    _onComponentMouseOut() {
        if (!this._thumbActive) {
            this._thumbVisible = false;
            this._thumbFade = true;
        }
    }
    render() {
        return html `
      <div
        class="scrollable-container"
        .style=${stylePropertyMap({
            userSelect: this._isDragging ? 'none' : 'auto',
        })}
      >
        <div
          class=${classMap({ shadow: true, visible: this.scrolled })}
          .style=${stylePropertyMap({
            zIndex: String(this._scrollbarTrackZ),
        })}
        ></div>
        ${this._isDragging
            ? html `<div class="prevent-interaction"></div>`
            : nothing}
        <div
          class=${classMap({
            'scrollbar-track': true,
            hidden: !this._scrollbarVisible,
        })}
        >
          <div
            class=${classMap({
            'scrollbar-thumb': true,
            visible: this._thumbVisible,
            fade: this._thumbFade,
            active: this._thumbActive,
        })}
            .style=${stylePropertyMap({
            height: `${this._thumbHeight}px`,
            top: `${this._thumbY}px`,
        })}
            @mousedown=${this._onScrollThumbMouseDown}
          ></div>
        </div>
        <div class="content">
          <slot @slotchange=${this._onSlotChange}></slot>
        </div>
      </div>
    `;
    }
};
VscodeScrollable.styles = styles;
__decorate([
    property({ type: Boolean, reflect: true })
], VscodeScrollable.prototype, "shadow", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], VscodeScrollable.prototype, "scrolled", void 0);
__decorate([
    property({ type: Number, attribute: 'scroll-pos' })
], VscodeScrollable.prototype, "scrollPos", null);
__decorate([
    property({ type: Number, attribute: 'scroll-max' })
], VscodeScrollable.prototype, "scrollMax", null);
__decorate([
    state()
], VscodeScrollable.prototype, "_isDragging", void 0);
__decorate([
    state()
], VscodeScrollable.prototype, "_thumbHeight", void 0);
__decorate([
    state()
], VscodeScrollable.prototype, "_thumbY", void 0);
__decorate([
    state()
], VscodeScrollable.prototype, "_thumbVisible", void 0);
__decorate([
    state()
], VscodeScrollable.prototype, "_thumbFade", void 0);
__decorate([
    state()
], VscodeScrollable.prototype, "_thumbActive", void 0);
__decorate([
    query('.content')
], VscodeScrollable.prototype, "_contentElement", void 0);
__decorate([
    query('.scrollbar-thumb', true)
], VscodeScrollable.prototype, "_scrollThumbElement", void 0);
__decorate([
    query('.scrollable-container')
], VscodeScrollable.prototype, "_scrollableContainer", void 0);
__decorate([
    queryAssignedElements()
], VscodeScrollable.prototype, "_assignedElements", void 0);
VscodeScrollable = __decorate([
    customElement('vscode-scrollable')
], VscodeScrollable);
export { VscodeScrollable };
//# sourceMappingURL=vscode-scrollable.js.map