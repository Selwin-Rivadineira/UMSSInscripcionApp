"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeTest = exports.KBSchema = exports.FormulaMetadataSchema = exports.FormulaGroupSchema = exports.PromptSchema = exports.FormulaSchema = exports.CodeLocationSchema = exports.FormulaStepSchema = exports.HasMetadataSchema = exports.ContextAware = exports.Beans = exports.METADATA_EXTENSION = exports.MARKDOWN_EXTENSION = exports.PROMPT_EXTENSION = exports.FORMULA_EXTENSION = void 0;
const zod_1 = require("zod");
exports.FORMULA_EXTENSION = '.formula';
exports.PROMPT_EXTENSION = '.prompt';
exports.MARKDOWN_EXTENSION = '.md';
exports.METADATA_EXTENSION = '.metadata';
exports.Beans = {
    Settings: 'Settings',
    Logger: 'Logger',
    ToolsConfig: 'ToolsConfig',
    CustomDocumentLoader: 'CustomFormulaLoader',
    MsftDocumentLoader: 'MsftFormulaLoader',
    DocumentLoader: 'FormulaLoader',
    MarkdownLoader: 'MarkdownLoader',
    EmbeddingsProvider: 'EmbeddingsProvider',
    Reranker: 'Reranker',
    TelemetryReporter: 'TelemetryReporter',
    TelemetryService: 'TelemetryService',
    McpEventEmitter: 'McpEventEmitter',
    KBStore: 'KBStore',
    KBLoaders: 'KBLoaders',
    KBVectorStore: 'KBVectorStore',
};
exports.ContextAware = zod_1.z.object({
    sessionId: zod_1.z
        .string()
        .describe('The ID of the migration session during which this tool is invoked which will be used to track the migration process. You can leave it blank when not in a migration session.'),
});
exports.HasMetadataSchema = zod_1.z
    .object({
    metadata: zod_1.z.preprocess((data) => (data === null ? undefined : data), zod_1.z
        .record(zod_1.z.any())
        .describe('Metadata associated with the entity, e.g. author, version, etc.')
        .default({})),
})
    .describe('The schema of an entity with metadata');
exports.FormulaStepSchema = zod_1.z
    .object({
    type: zod_1.z
        .enum(['diff', 'instruction'])
        .describe('The type of the formula step, either a code diff or an instruction'),
    description: zod_1.z.string().describe('The description of the formula step'),
    content: zod_1.z
        .string()
        .nonempty()
        .describe('The content of the formula step, either a code diff or an instruction'),
})
    .describe('The schema of a formula step');
exports.CodeLocationSchema = zod_1.z
    .object({
    type: zod_1.z.enum(['textsearch', 'condition-textsearch']).describe('The type of code location'),
    filePattern: zod_1.z
        .string()
        .optional()
        .describe('The file pattern to search for, e.g. `src/**/*.java`'),
    codePattern: zod_1.z
        .string()
        .optional()
        .describe('The code pattern to search for, e.g. `public class MyClass`'),
    fileToExclude: zod_1.z
        .string()
        .optional()
        .describe('The file to exclude from the search, e.g. `src/test/**/*.java`'),
})
    .describe('The schema of the code location');
exports.FormulaSchema = exports.HasMetadataSchema.extend({
    name: zod_1.z.string().nonempty().describe('The name of the formula'),
    description: zod_1.z.string().describe('The description of the formula'),
    codeLocation: exports.CodeLocationSchema.describe('The code location of the formula, e.g. file pattern, code pattern, etc.'),
    customPrompt: zod_1.z.string().optional().describe('The custom prompt for the formula, if any'),
    steps: zod_1.z.array(exports.FormulaStepSchema.describe('The steps of the formula, each step can be a code diff or an instruction')),
}).describe('The schema of a formula');
exports.PromptSchema = exports.HasMetadataSchema.extend({
    content: zod_1.z
        .string()
        .describe('The content of the prompt, which is a string that can be used to generate text or code'),
}).describe('The schema of a prompt');
exports.FormulaGroupSchema = zod_1.z
    .object({
    id: zod_1.z.string().nonempty().describe('The unique identifier of the formula group'),
    displayName: zod_1.z.string().nonempty().describe('The display name of the formula group'),
    description: zod_1.z.string().describe('The description of the formula group'),
})
    .describe('The schema of a formula group');
exports.FormulaMetadataSchema = exports.HasMetadataSchema.extend({
    group: exports.FormulaGroupSchema.describe('The group of the formula, which is a collection of related formulas'),
    tags: zod_1.z
        .array(zod_1.z.string())
        .describe('The tags associated with the formula, e.g. ["java17", "springboot"]'),
}).describe('The schema of a formula metadata');
exports.KBSchema = exports.HasMetadataSchema.extend({
    id: zod_1.z.string().nonempty().describe('The unique identifier of the knowledge base'),
    title: zod_1.z.string().nonempty().describe('The title of the knowledge base'),
    description: zod_1.z.string().describe('The description of the knowledge base'),
    content: zod_1.z
        .optional(zod_1.z.string())
        .describe('The content of the knowledge base, which is a string that can be used to generate text or code'),
    disabled: zod_1.z
        .optional(zod_1.z.boolean())
        .describe('Whether the knowledge base is disabled, default is false'),
}).describe('The schema of a knowledge base');
class TypeTest {
    static isWorkspacePathAware(obj) {
        return typeof obj.workspacePath === 'string';
    }
    static isContextAware(obj) {
        return 'sessionId' in obj && typeof obj.sessionId === 'string';
    }
    static isRequestHandlerExtra(obj) {
        return '_meta' in obj;
    }
}
exports.TypeTest = TypeTest;
//# sourceMappingURL=types.js.map