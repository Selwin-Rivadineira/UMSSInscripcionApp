"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.detectBuildToolInRepo = detectBuildToolInRepo;
exports.detectBuildEnvInRepo = detectBuildEnvInRepo;
exports.checkEnvironment = checkEnvironment;
require("reflect-metadata");
const command_exists_1 = __importDefault(require("command-exists"));
const path = __importStar(require("path"));
const tsyringe_1 = require("tsyringe");
const Environment_1 = require("../javabuild/context/Environment");
const JavaBuildTool_utils_1 = require("../javabuild/JavaBuildTool.utils");
const types_1 = require("../types");
function detectBuildToolInRepo(repoPath, environmentService) {
    const results = [];
    // Maven
    const mvnwUnix = path.join(repoPath, 'mvnw');
    const mvnwWin = path.join(repoPath, 'mvnw.cmd');
    const pomConfigPath = path.join(repoPath, 'pom.xml');
    const mavenWrapperExists = environmentService.existsSync(mvnwUnix) || environmentService.existsSync(mvnwWin);
    const mavenExists = environmentService.existsSync(pomConfigPath);
    if (mavenWrapperExists || mavenExists) {
        results.push({ type: 'Maven', isWrapper: mavenWrapperExists });
    }
    // Gradle
    const gradleWrapperUnix = path.join(repoPath, 'gradlew');
    const gradleWrapperWin = path.join(repoPath, 'gradlew.bat');
    const gradleConfigPath = path.join(repoPath, 'build.gradle');
    const gradleKotlinsConfigPath = path.join(repoPath, 'build.gradle.kts');
    const gradleWrapperExists = environmentService.existsSync(gradleWrapperUnix) ||
        environmentService.existsSync(gradleWrapperWin);
    const gradleExists = environmentService.existsSync(gradleConfigPath) ||
        environmentService.existsSync(gradleKotlinsConfigPath);
    if (gradleWrapperExists || gradleExists) {
        results.push({ type: 'Gradle', isWrapper: gradleWrapperExists });
    }
    return results;
}
async function detectBuildEnvInRepo(repoPath, environmentService, jdkPath, mavenPath, context, from) {
    const javaExecutable = (0, Environment_1.pathExecutable)('java', jdkPath || '');
    const mvnExecutable = (0, Environment_1.pathExecutable)('mvn', mavenPath || '');
    const eventEmitter = tsyringe_1.container.resolve(types_1.Beans.McpEventEmitter);
    let buildTool = { type: 'Maven', isWrapper: false };
    const buildToolList = detectBuildToolInRepo(repoPath, environmentService);
    if (buildToolList.length > 0) {
        buildTool = buildToolList[0];
    }
    let javaCommandExists = false;
    await (0, command_exists_1.default)('java')
        .then(() => {
        javaCommandExists = true;
    })
        .catch(() => {
        javaCommandExists = false;
    });
    let mvnExists = true;
    if (buildTool && buildTool.type.toLowerCase().includes('maven') && !buildTool.isWrapper) {
        await (0, command_exists_1.default)('mvn')
            .then(() => {
            mvnExists = true;
        })
            .catch(() => {
            mvnExists = false;
        });
    }
    eventEmitter.emit('build_fix_info', {
        jdkConfigured: javaCommandExists,
        buildToolType: buildTool.type || '',
        isWrapper: buildTool.isWrapper,
        buildToolConfigured: mvnExists,
        message: `Call tool ${from} JDK configuration status`,
        workspacePath: repoPath,
    }, context);
    const executables = [javaExecutable];
    const javaHome = javaExecutable.path && javaExecutable.path.trim().length > 0
        ? path.join(javaExecutable.path, '..')
        : process.env.JAVA_HOME;
    switch (buildTool.type) {
        case 'Maven':
            //mvnw dependes on java_home
            if (buildTool.isWrapper && javaHome) {
                executables.push((0, Environment_1.pathExecutable)('mvnw', repoPath));
            }
            else {
                executables.push(mvnExecutable);
            }
            break;
        case 'Gradle':
            if (buildTool.isWrapper) {
                executables.push((0, Environment_1.pathExecutable)('gradlew', repoPath));
            }
            else {
                executables.push((0, Environment_1.localExecutable)('gradle'));
            }
    }
    const buildEnv = new Environment_1.Environment('custom', executables);
    buildEnv.envVars['JAVA_HOME'] = javaHome || '';
    return buildEnv;
}
async function checkEnvironment(env) {
    const missingVars = [];
    if (!env.envVars['JAVA_HOME'] && env.envVars['JAVA_HOME'].trim().length === 0) {
        missingVars.push('JAVA_HOME must be set when to call this tool. You must use JAVA_HOME from plan to call this tool\n\n');
    }
    const buildCmd = env === null || env === void 0 ? void 0 : env.getExecutableNames().find((name) => JavaBuildTool_utils_1.supportedBuildCmds.includes(name));
    const executables = env.executables.find((exec) => exec.name === buildCmd);
    switch (buildCmd) {
        case 'mvn':
            await (0, command_exists_1.default)('mvn')
                .catch(() => {
                if (!executables || !executables.path || executables.path.trim().length === 0) {
                    missingVars.push('mvn command not found. You must use mavenHome from plan to call this tool\n\n');
                }
            })
                .then(() => {
                //mvn exists
            });
            break;
        case 'mvnw':
            if (!executables || !executables.path || executables.path.trim().length === 0) {
                missingVars.push('mvnw should be called with full path\n');
            }
            break;
        case 'gradle':
        case 'gradlew':
            if (!executables || !executables.path || executables.path.trim().length === 0) {
                missingVars.push('gradlew should be called with full path\n');
            }
            break;
    }
    return missingVars;
}
//# sourceMappingURL=javaBuild.js.map