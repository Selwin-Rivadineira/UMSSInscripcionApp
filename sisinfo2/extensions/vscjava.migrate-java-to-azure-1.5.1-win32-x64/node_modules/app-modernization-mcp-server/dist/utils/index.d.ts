import { CallToolResult } from '@modelcontextprotocol/sdk/types';
import { ErrorDetails } from '../javabuild/test/types';
import { ServerType, ToolsConfig } from '../types';
export type { EnvironmentService } from './environmentService';
export { defaultEnvService } from './environmentService';
export { detectBuildEnvInRepo, detectBuildToolInRepo } from './javaBuild';
export { kbToMarkdown } from './validationUtils';
/**
 * A utility class for combining and negating filter functions.
 */
export declare class Filters {
    /**
     * Combines multiple filter functions using a logical AND operation.
     *
     * @template T - The type of the items to be filtered.
     * @param {...Array<(item: T) => boolean>} filters - The filter functions to combine.
     * @returns {(item: T) => boolean} A function that returns true if all the provided filters return true for the given item.
     */
    static and<T>(...filters: ((item: T) => boolean)[]): (item: T) => boolean;
    /**
     * Combines multiple filter functions using a logical OR operation.
     *
     * @template T - The type of the items to be filtered.
     * @param {...Array<(item: T) => boolean>} filters - The filter functions to combine.
     * @returns {(item: T) => boolean} A function that returns true if any of the provided filters return true for the given item.
     */
    static or<T>(...filters: ((item: T) => boolean)[]): (item: T) => boolean;
    /**
     * Negates a filter function.
     *
     * @template T - The type of the items to be filtered.
     * @param {(item: T) => boolean} filter - The filter function to negate.
     * @returns {(item: T) => boolean} A function that returns true if the provided filter returns false for the given item.
     */
    static not<T>(filter: (item: T) => boolean): (item: T) => boolean;
}
/**
 * Generates a hash of the given input string using the specified algorithm.
 *
 * @param {string} input - The input string to hash.
 * @param {string} [algorithm='sha256'] - The hash algorithm to use (default is 'sha256').
 * @returns {string} The resulting hash as a hexadecimal string.
 */
export declare function hashString(input: string, algorithm?: string): string;
/**
 * Groups the elements of an array by a specified key.
 *
 * @template T - The type of the elements in the array.
 * @template K - The type of the key.
 * @param {T[]} array - The array to group.
 * @param {(item: T) => K} key - A function that returns the key for each element.
 * @returns {Record<K, T[]>} An object where the keys are the group keys and the values are arrays of elements.
 */
export declare const groupBy: <T, K extends keyof any>(array: T[], key: (item: T) => K) => Record<K, T[]>;
/**
 * Converts an array of elements into an object where the keys are derived from a specified key function.
 *
 * @template T - The type of the elements in the array.
 * @template K - The type of the key.
 * @param {T[]} array - The array to convert.
 * @param {(item: T) => K} key - A function that returns the key for each element.
 * @returns {Record<K, T>} An object where the keys are derived from the key function and the values are the elements.
 */
export declare const toMap: <T, K extends keyof any>(array: T[], key: (item: T) => K) => Record<K, T>;
/**
 * Checks if a string is not empty.
 *
 * @param {string} [content] - The string to check.
 * @returns {boolean} True if the string is not empty, false otherwise.
 */
export declare const notEmpty: (content?: string) => boolean;
/**
 * Checks if a value is unique in an array.
 *
 * @param {any} v - The value to check.
 * @param {number} i - The index of the value in the array.
 * @param {any[]} a - The array to check.
 * @returns {boolean} True if the value is unique, false otherwise.
 */
export declare const unique: (v: any, i: number, a: any[]) => boolean;
/**
 * Creates a deduplication function that can be used to filter out duplicate elements from an array.
 *
 * @template T - The type of elements in the array.
 * @param compare - A comparison function that takes two elements of type T and returns a boolean indicating whether they are considered equal.
 * @returns A function that takes an element, its index, and the array, and returns a boolean indicating whether the element is unique in the array.
 */
export declare function dedup<T>(compare: (a: T, b: T) => boolean): (find: T, i: number, arr: T[]) => boolean;
/**
 * Picks specified keys from an object.
 *
 * @template T - The type of the object.
 * @template K - The type of the keys.
 * @param {T} obj - The object to pick keys from.
 * @param {K[]} keys - The keys to pick.
 * @returns {Pick<T, K>} An object with only the picked keys.
 */
export declare function pick<T extends object, K extends keyof T>(obj: T, keys: K[]): Pick<T, K>;
/**
 * Creates a shallow copy of the given object, omitting the specified keys.
 *
 * @typeParam T - The type of the source object.
 * @typeParam K - The keys of the source object to omit.
 * @param obj - The source object from which to omit properties.
 * @param keys - An array of keys to omit from the resulting object.
 * @returns A new object with the specified keys omitted.
 */
export declare function omit<T extends object, K extends keyof T>(obj: T, keys: K[]): Omit<T, K>;
/**
 * Retrieves a configuration value from the environment or a configuration file.
 *
 * @template T - The type of the configuration value.
 * @param {string} key - The key of the configuration value.
 * @param {T} defaultValue - The default value to return if the configuration value is not found.
 * @returns {T} The configuration value.
 */
export declare function getConfig<T>(key: string, defaultValue: T): T;
/**
 * Loads and returns the tools configuration from the `tools.json` file.
 *
 * The configuration is expected to be a JSON object where each key is a tool name
 * and the value is a boolean indicating whether the tool is enabled.
 *
 * @returns {Record<string, boolean>} An object mapping tool names to their enabled status.
 * If the configuration file does not exist, returns an empty object.
 */
export declare function getToolsConfig(currentPath: string, serverType?: ServerType): ToolsConfig;
/**
 * Negates the result of a function.
 *
 * @param {(arg: any) => boolean} fn - The function to negate.
 * @returns {(arg: any) => boolean} A function that returns the negated result of the original function.
 */
export declare const not: (fn: (arg: any) => boolean) => (arg: any) => boolean;
/**
 * Converts a given path to use Linux-style separators.
 * @param inputPath The path to be converted.
 * @returns The converted path with Linux-style separators.
 */
export declare function toForwardSlash(inputPath: string): string;
/**
 * Joins multiple path segments and converts the result to use Linux-style separators.
 * @param segments The path segments to be joined.
 * @returns The joined path with Linux-style separators.
 */
export declare function joinToForwardSlash(...segments: string[]): string;
/**
 * Splits path to segments no matter it uses Linux-style or Windows-style separators.
 * @param inputPath The path to split.
 * @returns The split segments
 */
export declare function split(inputPath: string): string[];
export declare function relative(basePath: string, targetPath: string): string;
export declare function pathEquals(path1: string, path2: string): boolean;
export declare const isJest: () => boolean;
export declare class Mutex {
    private mutex;
    lock(): PromiseLike<() => void>;
}
export declare const MCPOutput: {
    success: (...messages: string[]) => CallToolResult;
    structured: (structuredContent: any) => CallToolResult;
    error: (...messages: string[]) => CallToolResult;
};
export declare function findFileInteratively(currentPath: string, fileName: string): string | undefined;
export declare function detectPackageJson(currentPath: string): any | undefined;
/**
 * Gets the installation path for the AppCAT CLI.
 * If the AppCAT CLI is installed, it returns the directory containing the executable.
 * If not installed, it returns a default user home path for AppCAT.
 *
 * @returns {string} The installation path for AppCAT CLI.
 */
export declare function getAppCatInstallPath(): string;
export declare function isInternal(): boolean;
export declare function getFormattedTimestamp(): string;
/**
 * Formats a date as a simple string in the format YYYYMMDDHHMMSS.
 *
 * @param {Date} date - The date to format.
 * @returns {string} The formatted date string including seconds.
 */
export declare const formatDateWithSeconds: (date: Date) => string;
export declare function sanitizeString(input: string): string;
export declare function camelToTitleWithSpace(str: string): string;
export declare function findParamByTypeWithIndex<T>(args: any[], filter: (value: any) => boolean): {
    index: number;
    value: T;
} | undefined;
export declare function loadIgnoreFile(filePath: string): string[];
export declare function extendIfEmpty<T>(child: T, parent: T, keys: (keyof T)[]): any;
/**
 * List files in a directory sorted by modification time (newest first)
 * Works on Linux, macOS, and Windows
 */
export declare function listDirSortedByMtime(dirPath: string): {
    name: string;
    mtime: Date;
}[];
export declare function parseArg(argKey: string): string | undefined;
export declare function toMarkdown(error: ErrorDetails): string;
//# sourceMappingURL=index.d.ts.map