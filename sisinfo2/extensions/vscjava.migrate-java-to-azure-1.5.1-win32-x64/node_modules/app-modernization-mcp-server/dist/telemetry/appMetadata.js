"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GradleJavaVersionResolver = exports.MavenJavaVersionResolver = exports.GradleSpringBootVersionResolver = exports.MavenSpringBootVersionResolver = void 0;
exports.buildAppMetadataParser = buildAppMetadataParser;
const assert_1 = __importDefault(require("assert"));
const fs = __importStar(require("fs"));
const ignore_1 = __importDefault(require("ignore"));
const path = __importStar(require("path"));
const xml2js_1 = require("xml2js");
const utils_1 = require("../utils");
class JavaProjectWalker {
    constructor(parsers) {
        this.parsers = parsers;
        this.projectSizeCache = {};
        this.moduleMap = {};
        this.supportedProjectFileTypes = ['pom.xml', 'build.gradle'];
    }
    walk(root) {
        this.walkDir(root, root);
    }
    walkDir(projectDir, root, ignoreStack = []) {
        if (this.projectSizeCache[projectDir]) {
            return this.projectSizeCache[projectDir];
        }
        const entries = fs.readdirSync(projectDir, { withFileTypes: true });
        entries.sort(this.fileFirst); // ensure parent project file parse first
        // Handle .gitignore for this directory
        const clonedIgnoreStack = [...ignoreStack];
        const gitignorePath = path.join(projectDir, '.gitignore');
        if (fs.existsSync(gitignorePath)) {
            clonedIgnoreStack.push({
                matcher: (0, ignore_1.default)().add((0, utils_1.loadIgnoreFile)(gitignorePath)),
                base: projectDir,
            });
        }
        let count = 0;
        for (const entry of entries) {
            const entryPath = path.join(projectDir, entry.name);
            const normalizedEntryPath = path.normalize(entryPath);
            // Check ignore rules
            const relPaths = clonedIgnoreStack.map(({ base }) => path.relative(base, normalizedEntryPath).replace(/\\/g, '/') || entry.name);
            const ignored = clonedIgnoreStack.some((stack, i) => stack.matcher.ignores(relPaths[i]));
            if (ignored) {
                continue;
            }
            if (entry.isDirectory()) {
                const subFolderSize = this.walkDir(normalizedEntryPath, root, clonedIgnoreStack);
                if (!this.getModule(normalizedEntryPath)) {
                    count += subFolderSize;
                }
            }
            else if (entry.isFile()) {
                count++;
                // If it's a supported project file type, parse it
                if (this.supportedProjectFileTypes.includes(entry.name)) {
                    const parser = this.parsers[entry.name];
                    if (parser) {
                        try {
                            const result = parser(entryPath);
                            if (result) {
                                const newModule = {
                                    filePath: entryPath,
                                    result: result,
                                };
                                const existingModule = this.getModule(projectDir);
                                if (existingModule) {
                                    this.moduleMap[projectDir] = this.mergeModules(newModule, existingModule);
                                }
                                else {
                                    this.moduleMap[projectDir] = newModule;
                                }
                            }
                            // eslint-disable-next-line @typescript-eslint/no-unused-vars
                        }
                        catch (error) {
                            // skip any error detected
                        }
                    }
                }
            }
        }
        const projectModule = this.getModule(projectDir);
        if (projectModule) {
            const parentModule = this.getModule(path.dirname(projectDir));
            const isSubmodule = parentModule === null || parentModule === void 0 ? void 0 : parentModule.result.modules.includes(path.basename(projectDir));
            projectModule.projectSize = count;
            projectModule.result =
                isSubmodule && parentModule
                    ? (0, utils_1.extendIfEmpty)(projectModule.result, parentModule === null || parentModule === void 0 ? void 0 : parentModule.result, [
                        'groupId',
                        'javaVersion',
                        'springBootVersion',
                    ])
                    : projectModule.result;
            projectModule.parentPath =
                isSubmodule && parentModule ? parentModule.filePath : undefined;
            projectModule.hierarchy =
                projectDir === root ? 'root' : isSubmodule ? 'submodule' : 'standalone';
        }
        this.projectSizeCache[projectDir] = count;
        return count;
    }
    getModules() {
        return Object.values(this.moduleMap);
    }
    getModule(projectDir) {
        if (!fs.existsSync(projectDir)) {
            return undefined;
        }
        const stat = fs.statSync(projectDir);
        if (stat.isFile()) {
            projectDir = path.dirname(projectDir);
        }
        return this.moduleMap[projectDir];
    }
    mergeModules(...projectModules) {
        (0, assert_1.default)(projectModules, 'projectModules should not be undefined');
        const [first, ...rest] = projectModules.sort(this.sortByOrder.bind(this));
        if (rest) {
            for (const p of rest) {
                first.result = (0, utils_1.extendIfEmpty)(first.result, p.result, [
                    'groupId',
                    'javaVersion',
                    'springBootVersion',
                ]);
            }
        }
        return first;
    }
    sortByOrder(a, b) {
        // Sort by pom.xml first, then by file path
        return (this.supportedProjectFileTypes.indexOf(path.basename(a.filePath)) -
            this.supportedProjectFileTypes.indexOf(path.basename(b.filePath)));
    }
    fileFirst(a, b) {
        if (a.isFile()) {
            return b.isFile() ? 0 : -1;
        }
        return 1;
    }
}
function buildAppMetadataParser(workspacePath) {
    return new JavaAppMetadataParser(workspacePath);
}
class JavaAppMetadataParser {
    constructor(workspacePath) {
        this.workspacePath = workspacePath;
        const parsers = {
            'pom.xml': this.parsePom.bind(this),
            'build.gradle': this.parseGradle.bind(this),
        };
        this.walker = new JavaProjectWalker(parsers);
        this.walker.walk(workspacePath);
    }
    findAppMetadata(filePath) {
        const module = this.walker.getModule(filePath);
        if (!module) {
            return undefined;
        }
        const rootModule = this.walker.getModule(this.workspacePath);
        return this.convertToJavaAppMetadata(module, rootModule || this.findStandaloneRoot(module));
    }
    findAppMetadatas() {
        const modules = this.walker.getModules();
        const appMetadatas = [];
        const rootModule = this.walker.getModule(this.workspacePath);
        for (const module of modules) {
            appMetadatas.push(this.convertToJavaAppMetadata(module, rootModule || this.findStandaloneRoot(module)));
        }
        return appMetadatas;
    }
    findStandaloneRoot(module) {
        // iterate module.parentPath till hierarchy is standalone
        let currentModule = module;
        while (currentModule.parentPath) {
            currentModule = this.walker.getModule(currentModule.parentPath);
            if (!currentModule) {
                return undefined;
            }
            if (currentModule.hierarchy === 'standalone') {
                return currentModule;
            }
        }
        return currentModule;
    }
    convertToJavaAppMetadata(module, rootModule) {
        var _a, _b, _c, _d;
        return {
            filePath: module.filePath,
            hashedAppId: this.getHashedId(module.result),
            hashedProjectId: this.getHashedId(rootModule === null || rootModule === void 0 ? void 0 : rootModule.result),
            hierarchy: module.hierarchy,
            projectSize: `${module.projectSize}`,
            // java additional properties
            packagingType: ((_a = module === null || module === void 0 ? void 0 : module.result) === null || _a === void 0 ? void 0 : _a.packagingType) || 'jar',
            javaVersion: (_b = module === null || module === void 0 ? void 0 : module.result) === null || _b === void 0 ? void 0 : _b.javaVersion,
            springBootVersion: (_c = module === null || module === void 0 ? void 0 : module.result) === null || _c === void 0 ? void 0 : _c.springBootVersion,
            buildTool: (_d = module === null || module === void 0 ? void 0 : module.result) === null || _d === void 0 ? void 0 : _d.buildTool,
        };
    }
    getHashedId(result) {
        if (((result === null || result === void 0 ? void 0 : result.groupId) === undefined || (result === null || result === void 0 ? void 0 : result.groupId.trim()) === '') &&
            ((result === null || result === void 0 ? void 0 : result.artifactId) === undefined || (result === null || result === void 0 ? void 0 : result.artifactId.trim()) === '')) {
            return '';
        }
        else {
            return (0, utils_1.hashString)((0, utils_1.hashString)((result === null || result === void 0 ? void 0 : result.groupId) || '') + (0, utils_1.hashString)((result === null || result === void 0 ? void 0 : result.artifactId) || ''));
        }
    }
    parsePom(filePath) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const pomContent = fs.readFileSync(filePath, 'utf-8');
        let parseResult;
        (0, xml2js_1.parseString)(pomContent, { async: false }, (err, result) => {
            if (err) {
                throw new Error(`Failed to parse pom file: ${filePath}, error: ${err.message}, skip...`);
            }
            parseResult = result;
        });
        if (!parseResult) {
            return undefined;
        }
        const groupId = ((_b = (_a = parseResult === null || parseResult === void 0 ? void 0 : parseResult.project) === null || _a === void 0 ? void 0 : _a.groupId) === null || _b === void 0 ? void 0 : _b[0]) ||
            ((_f = (_e = (_d = (_c = parseResult === null || parseResult === void 0 ? void 0 : parseResult.project) === null || _c === void 0 ? void 0 : _c.parent) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.groupId) === null || _f === void 0 ? void 0 : _f[0]) ||
            '';
        const artifactId = (_h = (_g = parseResult === null || parseResult === void 0 ? void 0 : parseResult.project) === null || _g === void 0 ? void 0 : _g.artifactId) === null || _h === void 0 ? void 0 : _h[0];
        const packagingType = ((_k = (_j = parseResult === null || parseResult === void 0 ? void 0 : parseResult.project) === null || _j === void 0 ? void 0 : _j.packaging) === null || _k === void 0 ? void 0 : _k[0]) || 'jar';
        const javaVersion = new MavenJavaVersionResolver().resolveMetadata(parseResult);
        const springBootVersion = new MavenSpringBootVersionResolver().resolveMetadata(parseResult);
        const modules = ((_o = (_m = (_l = parseResult === null || parseResult === void 0 ? void 0 : parseResult.project) === null || _l === void 0 ? void 0 : _l.modules) === null || _m === void 0 ? void 0 : _m[0]) === null || _o === void 0 ? void 0 : _o.module) || [];
        return {
            groupId,
            artifactId,
            packagingType,
            javaVersion,
            springBootVersion,
            buildTool: 'maven',
            modules,
        };
    }
    parseGradle(projectFilePath) {
        const projectDir = path.dirname(projectFilePath);
        const current = this.readBuildGradle(projectDir);
        // eslint-disable-next-line prefer-const
        let { groupId, artifactId, packagingType, javaVersion, springBootVersion } = current;
        const projectNameVariable = this.readSettingsGradle(projectDir);
        if (!artifactId) {
            artifactId =
                readGradleProperties(projectDir, projectNameVariable) || projectNameVariable;
        }
        const modules = this.readModulesFromSettingsGradle(projectDir);
        return {
            groupId: groupId || '',
            artifactId: artifactId || '',
            packagingType: packagingType || 'jar',
            javaVersion: javaVersion || '',
            springBootVersion: springBootVersion || '',
            buildTool: 'gradle',
            modules: modules,
        };
    }
    // Function to read and parse the build.gradle file
    readBuildGradle(projectDir) {
        const buildGradlePath = path.join(projectDir, 'build.gradle');
        if (!fs.existsSync(buildGradlePath)) {
            return {
                groupId: null,
                artifactId: null,
                packagingType: null,
                javaVersion: null,
                springBootVersion: null,
            };
        }
        const data = fs.readFileSync(buildGradlePath, 'utf8');
        const groupMatch = data.match(/group\s*=\s*['"](.+?)['"]/);
        const projectMatch = data.match(/project\(['"]:(.*?)['"]\)/);
        const gradleJavaVersionResolver = new GradleJavaVersionResolver();
        const javaVersion = gradleJavaVersionResolver.resolveMetadata(data);
        let packaging = null;
        if (data.includes("apply plugin: 'war'") || data.includes("id 'war'")) {
            packaging = 'war';
        }
        else if (data.includes("apply plugin: 'java'") || data.includes("id 'java'")) {
            packaging = 'jar';
        }
        const gradleSpringBootVersionResolver = new GradleSpringBootVersionResolver();
        const springBootVersion = gradleSpringBootVersionResolver.resolveMetadata(data, projectDir);
        return {
            groupId: groupMatch ? groupMatch[1] : null,
            artifactId: projectMatch ? projectMatch[1] : null,
            packagingType: packaging,
            javaVersion,
            springBootVersion,
        };
    }
    // Function to read and parse the settings.gradle file
    readSettingsGradle(projectDir) {
        const settingsGradlePath = path.join(projectDir, 'settings.gradle');
        if (!fs.existsSync(settingsGradlePath)) {
            return null;
        }
        const data = fs.readFileSync(settingsGradlePath, 'utf8');
        const projectNameMatch = data.match(/rootProject.name\s*=\s*['"](.+?)['"]/);
        return projectNameMatch ? projectNameMatch[1] : null;
    }
    readModulesFromSettingsGradle(projectDir) {
        const settingsGradlePath = path.join(projectDir, 'settings.gradle');
        if (!fs.existsSync(settingsGradlePath)) {
            return [];
        }
        const content = fs.readFileSync(settingsGradlePath, 'utf8');
        const modules = [];
        // Match include statements with or without parentheses, using single or double quotes, across multiple lines
        const includeRegex = /include\s*(?:\(\s*)?((?:(?:"[^"]+"|'[^']+')\s*,?\s*)+)(?:\s*\))?/gs;
        let match;
        while ((match = includeRegex.exec(content)) !== null) {
            const includesPart = match[1];
            // Extract each quoted module name
            const moduleRegex = /["']([^"']+)["']/g;
            let moduleMatch;
            while ((moduleMatch = moduleRegex.exec(includesPart)) !== null) {
                modules.push(moduleMatch[1]);
            }
        }
        return modules;
    }
}
const propertyPlaceholder = /^\$\{(.+)\}$/;
function isPropertyReference(propertyReference) {
    if (!propertyReference) {
        return false;
    }
    return propertyPlaceholder.test(propertyReference.trim());
}
function getPropertyName(propertyReference) {
    if (!propertyReference) {
        return null;
    }
    const match = propertyReference.trim().match(propertyPlaceholder);
    return match ? match[1] : null;
}
function resolveMavenPropertyReference(value, properties) {
    var _a, _b;
    if (!value || !properties) {
        return '';
    }
    const propName = getPropertyName(value);
    if (!propName) {
        return '';
    }
    return (_b = (_a = properties[propName]) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : properties[propName];
}
class MavenSpringBootVersionResolver {
    resolveMetadata(pomObject) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        const properties = (_c = (_b = (_a = pomObject === null || pomObject === void 0 ? void 0 : pomObject.project) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c !== void 0 ? _c : {};
        let springBootVersion = (_e = (_d = properties['spring-boot.version']) === null || _d === void 0 ? void 0 : _d[0]) !== null && _e !== void 0 ? _e : '';
        if (springBootVersion) {
            return springBootVersion;
        }
        if ((_g = (_f = pomObject === null || pomObject === void 0 ? void 0 : pomObject.project) === null || _f === void 0 ? void 0 : _f.parent) === null || _g === void 0 ? void 0 : _g[0]) {
            const parent = pomObject.project.parent[0];
            if (((_h = parent.groupId) === null || _h === void 0 ? void 0 : _h[0]) === 'org.springframework.boot' &&
                ((_j = parent.artifactId) === null || _j === void 0 ? void 0 : _j[0]) === 'spring-boot-starter-parent') {
                springBootVersion = ((_k = parent.version) === null || _k === void 0 ? void 0 : _k[0]) || '';
                if (isPropertyReference(springBootVersion)) {
                    springBootVersion =
                        resolveMavenPropertyReference(springBootVersion, properties) || '';
                }
                if (springBootVersion) {
                    return springBootVersion;
                }
            }
        }
        if ((_q = (_p = (_o = (_m = (_l = pomObject === null || pomObject === void 0 ? void 0 : pomObject.project) === null || _l === void 0 ? void 0 : _l.dependencyManagement) === null || _m === void 0 ? void 0 : _m[0]) === null || _o === void 0 ? void 0 : _o.dependencies) === null || _p === void 0 ? void 0 : _p[0]) === null || _q === void 0 ? void 0 : _q.dependency) {
            const dependencies = pomObject.project.dependencyManagement[0].dependencies[0].dependency;
            for (const dep of dependencies) {
                if (((_r = dep.groupId) === null || _r === void 0 ? void 0 : _r[0]) === 'org.springframework.boot' &&
                    ((_s = dep.artifactId) === null || _s === void 0 ? void 0 : _s[0]) === 'spring-boot-dependencies') {
                    springBootVersion = ((_t = dep.version) === null || _t === void 0 ? void 0 : _t[0]) || '';
                    if (isPropertyReference(springBootVersion)) {
                        springBootVersion = resolveMavenPropertyReference(springBootVersion, properties);
                    }
                    if (springBootVersion) {
                        return springBootVersion;
                    }
                    break;
                }
            }
        }
        return springBootVersion || '';
    }
}
exports.MavenSpringBootVersionResolver = MavenSpringBootVersionResolver;
class GradleSpringBootVersionResolver {
    resolveMetadata(gradleBuildContent, projectDir) {
        let springBootVersion = null;
        // 1. Try plugins block
        const springBootVersionMatch = gradleBuildContent.match(/id\s+['"]org.springframework.boot['"]\s+version\s+['"](.+?)['"]/);
        if (springBootVersionMatch) {
            springBootVersion = springBootVersionMatch[1];
            if (isPropertyReference(springBootVersion)) {
                springBootVersion = this.getGradleProperty(springBootVersion, gradleBuildContent, projectDir);
            }
            if (springBootVersion) {
                return springBootVersion;
            }
        }
        // 2. Try org.springframework.boot:spring-boot-dependencies block
        const springBootDepsMatch = gradleBuildContent.match(/["']org\.springframework\.boot\s*:\s*spring-boot-dependencies\s*:\s*([^"']+)["']/);
        if (springBootDepsMatch) {
            springBootVersion = springBootDepsMatch[1];
            if (isPropertyReference(springBootVersion)) {
                springBootVersion = this.getGradleProperty(springBootVersion, gradleBuildContent, projectDir);
            }
            if (springBootVersion) {
                return springBootVersion;
            }
        }
        return '';
    }
    getGradleProperty(propertyReference, gradleBuildContent, projectDir) {
        const propertyName = getPropertyName(propertyReference);
        if (!propertyName) {
            return '';
        }
        // Try to resolve from ext properties in build.gradle
        const extPropMatch = gradleBuildContent.match(new RegExp(`ext\\s*\\{[\\s\\S]*?${propertyName}\\s*=\\s*['"](.+?)['"]`));
        if (extPropMatch) {
            const extPropertyValue = extPropMatch[1];
            if (extPropertyValue) {
                return extPropertyValue;
            }
        }
        if (projectDir) {
            // Try gradle.properties
            return readGradleProperties(projectDir, propertyName) || '';
        }
        return '';
    }
}
exports.GradleSpringBootVersionResolver = GradleSpringBootVersionResolver;
function readGradleProperties(projectDir, propertyName) {
    const gradlePropertiesPath = path.join(projectDir, 'gradle.properties');
    if (!fs.existsSync(gradlePropertiesPath)) {
        return null;
    }
    if (!propertyName) {
        return null;
    }
    const data = fs.readFileSync(gradlePropertiesPath, 'utf8');
    const regex = new RegExp(`${propertyName}\\s*=\\s*(.+)`);
    const projectNameMatch = data.match(regex);
    return projectNameMatch ? projectNameMatch[1].trim() : null;
}
class MavenJavaVersionResolver {
    resolveMetadata(pomObject) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
        // 1. <java.version> property (Spring Boot convention)
        let javaVersion = ((_d = (_c = (_b = (_a = pomObject === null || pomObject === void 0 ? void 0 : pomObject.project) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c['java.version']) === null || _d === void 0 ? void 0 : _d[0]) || '';
        if (javaVersion) {
            return javaVersion;
        }
        // 2. <maven.compiler.source> property and <maven.compiler.target> property
        javaVersion = ((_h = (_g = (_f = (_e = pomObject === null || pomObject === void 0 ? void 0 : pomObject.project) === null || _e === void 0 ? void 0 : _e.properties) === null || _f === void 0 ? void 0 : _f[0]) === null || _g === void 0 ? void 0 : _g['maven.compiler.source']) === null || _h === void 0 ? void 0 : _h[0]) || '';
        if (javaVersion) {
            return javaVersion;
        }
        javaVersion = ((_m = (_l = (_k = (_j = pomObject === null || pomObject === void 0 ? void 0 : pomObject.project) === null || _j === void 0 ? void 0 : _j.properties) === null || _k === void 0 ? void 0 : _k[0]) === null || _l === void 0 ? void 0 : _l['maven.compiler.target']) === null || _m === void 0 ? void 0 : _m[0]) || '';
        if (javaVersion) {
            return javaVersion;
        }
        // 3 maven-compiler-plugin <source>/<target>
        const plugins = ((_s = (_r = (_q = (_p = (_o = pomObject === null || pomObject === void 0 ? void 0 : pomObject.project) === null || _o === void 0 ? void 0 : _o.build) === null || _p === void 0 ? void 0 : _p[0]) === null || _q === void 0 ? void 0 : _q.plugins) === null || _r === void 0 ? void 0 : _r[0]) === null || _s === void 0 ? void 0 : _s.plugin) || [];
        const properties = ((_u = (_t = pomObject === null || pomObject === void 0 ? void 0 : pomObject.project) === null || _t === void 0 ? void 0 : _t.properties) === null || _u === void 0 ? void 0 : _u[0]) || {};
        const compilerPlugin = plugins.find((p) => { var _a; return ((_a = p.artifactId) === null || _a === void 0 ? void 0 : _a[0]) === 'maven-compiler-plugin'; });
        if (compilerPlugin) {
            const config = ((_v = compilerPlugin.configuration) === null || _v === void 0 ? void 0 : _v[0]) || {};
            // Try <configuration><source>
            javaVersion = ((_w = config.source) === null || _w === void 0 ? void 0 : _w[0]) || '';
            if (isPropertyReference(javaVersion)) {
                javaVersion = resolveMavenPropertyReference(javaVersion, properties) || '';
            }
            if (javaVersion) {
                return javaVersion;
            }
            // Try <configuration><target>
            javaVersion = ((_x = config.target) === null || _x === void 0 ? void 0 : _x[0]) || '';
            if (isPropertyReference(javaVersion)) {
                javaVersion = resolveMavenPropertyReference(javaVersion, properties) || '';
            }
            if (javaVersion) {
                return javaVersion;
            }
        }
        return '';
    }
}
exports.MavenJavaVersionResolver = MavenJavaVersionResolver;
class GradleJavaVersionResolver {
    resolveMetadata(gradleBuildContent) {
        let javaVersion = '';
        // 1. sourceCompatibility
        const javaVersionMatch = gradleBuildContent.match(/sourceCompatibility\s*=\s*['"](.+?)['"]/);
        if (javaVersionMatch) {
            javaVersion = javaVersionMatch[1];
            if (javaVersion) {
                return javaVersion;
            }
        }
        // 2. targetCompatibility
        const targetVersionMatch = gradleBuildContent.match(/targetCompatibility\s*=\s*['"](.+?)['"]/);
        if (targetVersionMatch) {
            javaVersion = targetVersionMatch[1];
            if (javaVersion) {
                return javaVersion;
            }
        }
        // 3. java { sourceCompatibility = JavaVersion.VERSION_X_Y }
        const javaBlockMatch = gradleBuildContent.match(/java\s*\{[\s\S]*?sourceCompatibility\s*=\s*JavaVersion\.VERSION_([\d_]+)/);
        if (javaBlockMatch) {
            javaVersion = javaBlockMatch[1];
            javaVersion = javaVersion.includes('_') ? javaVersion.replace('_', '.') : javaVersion;
            if (javaVersion) {
                return javaVersion;
            }
        }
        // 4. java {
        //        setSourceCompatibility(JavaVersion.VERSION_11)
        //        setTargetCompatibility(JavaVersion.VERSION_11)
        //    }
        const javaSetMatch = gradleBuildContent.match(/java\s*\{[\s\S]*?setSourceCompatibility\s*\(\s*JavaVersion\.VERSION_([\d_]+)\s*\)/i);
        if (javaSetMatch) {
            javaVersion = javaSetMatch[1];
            javaVersion = javaVersion.includes('_') ? javaVersion.replace('_', '.') : javaVersion;
            if (javaVersion) {
                return javaVersion;
            }
        }
        // 5. java toolchain { languageVersion = JavaLanguageVersion.of(X) }
        const toolchainMatch = gradleBuildContent.match(/java\s*\{[\s\S]*?toolchain\s*\{[\s\S]*?languageVersion\s*=\s*JavaLanguageVersion\.of\((\d+)\)/);
        if (toolchainMatch) {
            javaVersion = toolchainMatch[1];
            if (javaVersion) {
                return javaVersion;
            }
        }
        // 6. plugins/ext: java.version property
        const javaVersionPropMatch = gradleBuildContent.match(/java\.version\s*=\s*['"](.+?)['"]/);
        if (javaVersionPropMatch) {
            javaVersion = javaVersionPropMatch[1];
            if (javaVersion) {
                return javaVersion;
            }
        }
        const extJavaVersionMatch = gradleBuildContent.match(/ext\s*\{[\s\S]*?javaVersion\s*=\s*['"](.+?)['"]/);
        if (extJavaVersionMatch) {
            javaVersion = extJavaVersionMatch[1];
            if (javaVersion) {
                return javaVersion;
            }
        }
        return '';
    }
}
exports.GradleJavaVersionResolver = GradleJavaVersionResolver;
//# sourceMappingURL=appMetadata.js.map