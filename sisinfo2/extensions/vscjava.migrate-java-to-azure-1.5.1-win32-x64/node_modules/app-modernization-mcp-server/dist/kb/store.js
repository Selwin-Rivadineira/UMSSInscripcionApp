"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KBStore = exports.KBSearchOptions = exports.InMemoryVectorStore = void 0;
exports.formatKbHeader = formatKbHeader;
exports.formatKbContent = formatKbContent;
exports.sanitize = sanitize;
const tsyringe_1 = require("tsyringe");
const settings_1 = require("../settings");
const types_1 = require("../types");
const utils_1 = require("../utils");
const metadata_1 = require("./metadata");
const statistics_1 = require("./statistics");
let InMemoryVectorStore = class InMemoryVectorStore {
    constructor(embeddingsProvider, logger, getItemIdentifier, getHeaderContent, getBodyContent) {
        this.embeddingsProvider = embeddingsProvider;
        this.logger = logger;
        this.getItemIdentifier = getItemIdentifier;
        this.getHeaderContent = getHeaderContent;
        this.getBodyContent = getBodyContent;
        this.items = new Map();
        this.mutex = new utils_1.Mutex();
        this.computeEmbeddings = this.embeddingsProvider.computeEmbeddings.bind(this.embeddingsProvider);
        this.distance = cosine;
    }
    async add(item) {
        const id = this.getItemIdentifier(item);
        const headerEmbeddings = await this.computeEmbeddings(this.getHeaderContent(item));
        const bodyEmbeddings = await this.computeEmbeddings(this.getBodyContent(item));
        const unlock = await this.mutex.lock();
        try {
            this.items.set(id, { item, headerEmbeddings, bodyEmbeddings });
            this.logger.debug(`Added item with ID ${id} to vector store`);
        }
        finally {
            unlock();
        }
    }
    async update(item) {
        const id = this.getItemIdentifier(item);
        const headerEmbeddings = await this.computeEmbeddings(this.getHeaderContent(item));
        const bodyEmbeddings = await this.computeEmbeddings(this.getBodyContent(item));
        const unlock = await this.mutex.lock();
        try {
            if (this.items.has(id)) {
                this.items.set(id, { item, headerEmbeddings, bodyEmbeddings });
                this.logger.debug(`Updated item with ID ${id} in vector store`);
                unlock();
            }
            else {
                this.logger.warn(`Item with ID ${id} not found in vector store, adding as new`);
                unlock();
                await this.add(item); // add() has its own mutex lock
            }
        }
        catch (error) {
            unlock();
            throw error;
        }
    }
    async delete(identifier) {
        const unlock = await this.mutex.lock();
        try {
            if (this.items.has(identifier)) {
                this.items.delete(identifier);
                this.logger.debug(`Deleted item with ID ${identifier} from vector store`);
            }
            else {
                this.logger.warn(`Item with ID ${identifier} not found in vector store, nothing to delete`);
            }
        }
        finally {
            unlock();
        }
    }
    async filter(predicate) {
        const results = [];
        for (const { item } of this.items.values()) {
            if (predicate(item)) {
                results.push(item);
            }
        }
        return results;
    }
    async search(query, threshold) {
        const queryEmbedding = await this.embeddingsProvider.computeEmbeddings(query);
        const results = [];
        for (const [, { item, headerEmbeddings, bodyEmbeddings }] of this.items.entries()) {
            const headerSimilarity = this.distance(headerEmbeddings, queryEmbedding);
            const bodySimilarity = this.distance(bodyEmbeddings, queryEmbedding);
            const matched = headerSimilarity >= threshold || bodySimilarity >= threshold;
            this.logger.debug(`${matched ? '✅' : '❌'} Similarity result: ${sanitize(this.getHeaderContent(item))}, header similarity: ${headerSimilarity.toFixed(3)}, body similarity: ${bodySimilarity.toFixed(3)}, threshold: ${threshold}`);
            if (matched) {
                results.push({ item, score: headerSimilarity });
            }
        }
        results.sort((a, b) => b.score - a.score);
        return results;
    }
    async size() {
        const unlock = await this.mutex.lock();
        try {
            return this.items.size;
        }
        finally {
            unlock();
        }
    }
    async clear() {
        const unlock = await this.mutex.lock();
        try {
            this.items.clear();
            this.logger.debug('Vector store cleared');
        }
        finally {
            unlock();
        }
    }
};
exports.InMemoryVectorStore = InMemoryVectorStore;
exports.InMemoryVectorStore = InMemoryVectorStore = __decorate([
    (0, tsyringe_1.injectable)(),
    __param(0, (0, tsyringe_1.inject)(types_1.Beans.EmbeddingsProvider)),
    __param(1, (0, tsyringe_1.inject)(types_1.Beans.Logger)),
    __metadata("design:paramtypes", [Object, Object, Function, Function, Function])
], InMemoryVectorStore);
class KBSearchOptions {
    static byId(id) {
        if (!id || id.length === 0) {
            return () => false; // No ID specified, return false for all
        }
        return (f) => f.id === id;
    }
    static byTitle(title) {
        if (!title || title.length === 0) {
            return () => false; // No title specified, return false for all
        }
        return (f) => f.title === title;
    }
    static byGroup(group) {
        if (!group || group.length === 0) {
            return () => false; // No group specified, return false for all
        }
        return (f) => {
            const groupFromMetadata = metadata_1.MetadataGetter.getGroup(f);
            if (!groupFromMetadata || groupFromMetadata.length === 0) {
                return false; // No group in metadata, return false
            }
            return (0, utils_1.toForwardSlash)(groupFromMetadata).includes((0, utils_1.toForwardSlash)(group));
        };
    }
    static byRegex(regex) {
        return (f) => regex.test(f.name) || regex.test(f.description);
    }
}
exports.KBSearchOptions = KBSearchOptions;
let KBStore = class KBStore {
    constructor(loaders, vectorStore, reranker, settings, eventEmitter, logger) {
        this.loaders = loaders;
        this.vectorStore = vectorStore;
        this.reranker = reranker;
        this.settings = settings;
        this.eventEmitter = eventEmitter;
        this.logger = logger;
        this.loaded = false;
        this.mutex = new utils_1.Mutex();
        const callbacks = {
            onAdd: (kb) => this.addKb(kb),
            onChange: (kb) => this.updateKb(kb),
            onDelete: (path) => this.deleteKbByPath(path),
        };
        for (const loader of this.loaders) {
            if (!loader.onChange) {
                this.logger.debug(`Loader ${loader.constructor.name} does not support onChanges events, skipping event listeners.`);
                continue;
            }
            loader.onChange(callbacks);
        }
    }
    async load(context) {
        const unlock = await this.mutex.lock();
        const start = Date.now();
        try {
            if (this.loaded) {
                this.logger.debug('KBStore is already loaded, skipping.');
                return;
            }
            await Promise.resolve(this.vectorStore.clear());
            const kbs = (await Promise.all(this.loaders.flatMap((loader) => loader.load()))).flat();
            // Filter out disabled KBs and add them to the vector store
            await Promise.all(kbs
                .filter((kb) => {
                if (kb.disabled) {
                    this.logger.debug(`Skipping disabled KB: ${kb.id}`);
                    return false;
                }
                return true;
            })
                .map((kb) => this.addKb(kb)));
            this.logger.info(`Loaded ${await this.vectorStore.size()} knowledge bases, took ${Date.now() - start}ms.`);
            this.eventEmitter.emit('kb_load_success', {
                loaded: kbs.length,
                duration: Date.now() - start,
            }, context);
        }
        catch (error) {
            const err = error instanceof Error ? error : new Error(String(error));
            this.logger.error(`Failed to load kb: ${error}`);
            this.eventEmitter.emit('kb_load_fail', {
                error: err,
                loaded: 0,
                duration: Date.now() - start,
            }, context);
        }
        finally {
            this.loaded = true;
            unlock();
        }
    }
    async addKb(kb) {
        return await this.vectorStore.add(kb);
    }
    async updateKb(kb) {
        return await this.vectorStore.update(kb);
    }
    async deleteKbByPath(filePath) {
        return await this.vectorStore.delete(filePath);
    }
    async findKbById(context, kbId) {
        if (!this.loaded) {
            this.logger.debug('KBStore is not loaded, loading now.');
            await this.load(context);
        }
        const start = Date.now();
        try {
            const kbs = await this.vectorStore.filter(utils_1.Filters.or(KBSearchOptions.byId(kbId), KBSearchOptions.byTitle(kbId), KBSearchOptions.byGroup(kbId)));
            this.eventEmitter.emit('kb_get_success', {
                kbId,
                hit: kbs.length,
                duration: Date.now() - start,
            }, context);
            return kbs;
        }
        catch (error) {
            this.eventEmitter.emit('kb_get_fail', {
                error: error,
                kbId,
                duration: Date.now() - start,
                hit: 0,
            }, context);
            throw error;
        }
    }
    async listKbs(context) {
        if (!this.loaded) {
            this.logger.debug('KBStore is not loaded, loading now.');
            await this.load(context);
        }
        const start = Date.now();
        try {
            const kbs = await this.vectorStore.filter(() => true);
            this.eventEmitter.emit('kb_list_success', {
                hit: kbs.length,
                duration: Date.now() - start,
            }, context);
            return kbs;
        }
        catch (error) {
            this.logger.error(`Failed to list KBs: ${error}`);
            this.eventEmitter.emit('kb_list_fail', {
                error: error,
                duration: Date.now() - start,
                hit: 0,
            }, context);
            throw error;
        }
    }
    async searchKbs(context, query) {
        if (!this.loaded) {
            this.logger.debug('KBStore is not loaded, loading now.');
            await this.load(context);
        }
        const start = Date.now();
        let searchResults = [];
        let reranked = [];
        let err = null;
        try {
            this.logger.info(`Searching KBs with query: ${query}, model: ${this.settings.getEmbeddingModelName()}`);
            searchResults = await this.vectorStore.search(query, this.settings.getSimilarityThreshold());
            const totalItems = await Promise.resolve(this.vectorStore.size());
            this.logger.info(`Found ${searchResults.length} matching KB out of ${totalItems} after similarity search for query ${query}. ${this.settings.isRerankingEnabled() ? 'Reranking enabled.' : 'Reranking disabled.'}`);
            if (!this.settings.isRerankingEnabled() || searchResults.length === 0) {
                return searchResults;
            }
            this.logger.info(`Reranking ${searchResults.length} KBs based on query: ${query} with model: ${this.settings.getRerankingModelName()} and threshold: ${this.settings.getRerankingThreshold()}`);
            const headerCandidates = searchResults.map((result) => `${formatKbHeader(result.item)}`);
            const bodyCandidates = searchResults.map((result) => `${formatKbContent(result.item)}`);
            const headerRerankedResults = await this.reranker.rerank(query, headerCandidates);
            const bodyRerankedResults = await this.reranker.rerank(query, bodyCandidates);
            // Merge reranked results by index, using the highest score for each index
            const rerankResultsMap = new Map();
            [...headerRerankedResults, ...bodyRerankedResults].forEach(({ index, score }) => {
                const prev = rerankResultsMap.get(index);
                if (prev === undefined || score > prev) {
                    rerankResultsMap.set(index, score);
                }
            });
            const rerankResults = Array.from(rerankResultsMap.entries()).map(([index, score]) => ({
                index,
                score,
            }));
            reranked = rerankResults.flatMap((rerankResult) => {
                const searchResult = searchResults[rerankResult.index];
                const filtered = rerankResult.score >= this.settings.getRerankingThreshold();
                this.logger.debug(`${filtered ? '✅' : '❌'} Reranking result: ${sanitize(formatKbHeader(searchResult.item))}, score=${rerankResult.score.toFixed(4)}, threshold=${this.settings.getRerankingThreshold()}`);
                return filtered ? [searchResult] : [];
            });
            this.logger.info(`Found ${reranked.length} out of ${searchResults.length} relevant kb after reranking for query: ${query}.`);
            return reranked;
        }
        catch (error) {
            err = error instanceof Error ? error : new Error(String(error));
            throw error;
        }
        finally {
            const totalItems = await Promise.resolve(this.vectorStore.size());
            const statistics = new statistics_1.SearchStatistics(reranked.map((result) => result.score));
            if (err) {
                this.logger.error(`Failed to search KBs: ${err}`);
                this.eventEmitter.emit('kb_search_fail', {
                    error: err,
                    query,
                    perfMeter: {
                        total: totalItems,
                        hit: searchResults.length,
                        reranked: reranked.length,
                        mean: statistics.mean,
                        median: statistics.median,
                        stddev: statistics.stddev,
                        min: statistics.min,
                        max: statistics.max,
                    },
                    duration: Date.now() - start,
                }, context);
            }
            else {
                this.eventEmitter.emit('kb_search_success', {
                    query,
                    perfMeter: {
                        total: totalItems,
                        hit: searchResults.length,
                        reranked: reranked.length,
                        mean: statistics.mean,
                        median: statistics.median,
                        stddev: statistics.stddev,
                        min: statistics.min,
                        max: statistics.max,
                    },
                    duration: Date.now() - start,
                }, context);
            }
        }
    }
};
exports.KBStore = KBStore;
exports.KBStore = KBStore = __decorate([
    (0, tsyringe_1.injectable)(),
    __param(0, (0, tsyringe_1.inject)(types_1.Beans.KBLoaders)),
    __param(1, (0, tsyringe_1.inject)(types_1.Beans.KBVectorStore)),
    __param(2, (0, tsyringe_1.inject)(types_1.Beans.Reranker)),
    __param(3, (0, tsyringe_1.inject)(types_1.Beans.Settings)),
    __param(4, (0, tsyringe_1.inject)(types_1.Beans.McpEventEmitter)),
    __param(5, (0, tsyringe_1.inject)(types_1.Beans.Logger)),
    __metadata("design:paramtypes", [Array, Object, Object, settings_1.Settings, Object, Object])
], KBStore);
function cosine(a, b) {
    const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
    const normA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
    const normB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
    return dotProduct / (normA * normB);
}
function formatKbHeader(kb) {
    let kbContent = `* KB ID: ${kb.id}
* Title: ${kb.title}
* Description: ${kb.description}
`;
    const tags = metadata_1.MetadataGetter.getTags(kb);
    if (tags && tags.length > 0) {
        kbContent += `* Tags: ${tags.join(', ')}`;
    }
    const metadataToShow = (0, utils_1.omit)(kb.metadata, [...Object.values(metadata_1.ReservedSystemMetadata)]);
    if (metadataToShow) {
        for (const metadataKey of Object.keys(metadataToShow)) {
            kbContent += `\n${(0, utils_1.camelToTitleWithSpace)(metadataKey)}: ${metadataToShow[metadataKey]}`;
        }
    }
    return kbContent;
}
function formatKbContent(kb) {
    return kb.content ? kb.content : 'No content available';
}
function sanitize(text) {
    return text
        .replace(/[\r\n]+/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .substring(0, 150);
}
//# sourceMappingURL=store.js.map