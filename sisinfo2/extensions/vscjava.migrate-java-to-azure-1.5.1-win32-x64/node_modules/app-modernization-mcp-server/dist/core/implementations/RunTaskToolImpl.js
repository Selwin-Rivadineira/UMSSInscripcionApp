"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunTaskToolImpl = exports.planFileName = void 0;
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const path_1 = __importDefault(require("path"));
const tsyringe_1 = require("tsyringe");
const ToolNames_1 = require("../../tools/ToolNames");
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const JavaBuildToolRequest_1 = require("../request/JavaBuildToolRequest");
const Tool_1 = require("../Tool");
const toolDescription_1 = require("../toolDescription");
const ToolNameHelper_1 = require("./ToolNameHelper");
exports.planFileName = `plan.md`;
class RunTaskToolImpl extends Tool_1.BaseTool {
    constructor() {
        super(...arguments);
        this.name = ToolNames_1.McpToolNames.RUN_TASK;
        this.toolReferenceName = ToolNames_1.McpToolNames.RUN_TASK;
        this.displayName = 'Run Migration Task';
        this.description = toolDescription_1.ToolDescriptions.RUN_TASK;
    }
    async execute(request, context) {
        const { scenario, kbId, workspacePath } = request;
        const eventEmitter = tsyringe_1.container.resolve(types_1.Beans.McpEventEmitter);
        const settings = tsyringe_1.container.resolve(types_1.Beans.Settings);
        if (!scenario && !kbId) {
            const error = new Error('Either scenario or kbId must be provided');
            eventEmitter.emit('run_task_fail', { error, workspacePath, scenario, kbId }, context);
            throw error;
        }
        let goal = '';
        let branchSuffix = '';
        if (kbId) {
            goal = `You will help user to migrate this project to Azure using #${ToolNames_1.McpToolNames.GET_KB} by kbId: ${kbId}.`;
            branchSuffix = kbId;
        }
        else {
            goal = `You will help user to migrate this project to Azure using #${ToolNames_1.McpToolNames.SEARCH_KB} for scenario: ${scenario}, and check relevance of the found kb, and if it is not relevant, you should not use it`;
            branchSuffix = 'migration';
        }
        // FIXME - this is a temporary fix for the specific knowledge bases
        const skipCveFixAndTestFix = kbId === 'ant-project-to-maven-project' || kbId === 'eclipse-project-to-maven-project';
        // Get the appropriate CVE tool name based on environment
        const cveToolName = ToolNameHelper_1.ToolNameHelper.getCveToolName(settings);
        const reportBasePath = path_1.default.join(workspacePath, '.github', 'appmod-java', 'code-migration');
        // Create .gitignore
        const gitignorePath = path_1.default.join(reportBasePath, '.gitignore');
        const folderPath = path_1.default.dirname(gitignorePath);
        if (!fs.existsSync(folderPath)) {
            fs.mkdirSync(folderPath, { recursive: true, mode: 0o755 });
        }
        fs.writeFileSync(gitignorePath, `\n*\n`);
        const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
        // Get the latest git commit ID from the workspace directory
        let latestCommitId = '';
        try {
            latestCommitId = (0, child_process_1.execSync)('git rev-parse HEAD', {
                cwd: workspacePath,
                encoding: 'utf8',
            }).trim();
        }
        catch (error) {
            logger.error('Failed to get git commit ID:', error);
        }
        const sessionId = (0, utils_1.formatDateWithSeconds)(new Date());
        const branchName = `appmod/java-${branchSuffix}-${sessionId}`;
        if ((0, utils_1.isJest)()) {
            this.configureGitUserForBenchmark();
            this.setupOutDirectoryGitignore(workspacePath);
        }
        const TERMINAL_TOOL = ToolNameHelper_1.ToolNameHelper.getTerminalToolName((0, utils_1.isJest)());
        const VERSION_CONTROL_TOOL = ToolNames_1.McpToolNames.VERSION_CONTROL;
        const reportPath = path_1.default.join(reportBasePath, kbId ? kbId + `-${sessionId}` : `${sessionId}`);
        const supportListJdk = process.env.APPMOD_SUPPORT_LIST_JDKS === 'true' || (0, utils_1.isJest)();
        const supportInstallJdk = process.env.APPMOD_SUPPORT_INSTALL_JDKS === 'true' || (0, utils_1.isJest)();
        const scope = `
## Scope
* DO - Collect the framework used and keep the original project framework
* DO - Collect build environment of the project include the JDK version and build type (maven or gradle) from dependency file (pom.xml or gradle setting file)${!supportListJdk
            ? ''
            : `
* DO - Collect build environment of the device include the JDK installation and Maven installation information if the project is built by maven`}
* DO - Code modification to replace original technology dependencies with equivalents
* DO - Configuration file updates necessary for compilation
* DO - Dependency management changes
* DO - Update the function references to use the new generated functions
* DO - Fix any introduced CVEs during code migration
* DO - Build the project with tool #${ToolNames_1.McpToolNames.JAVA_BUILD} and ensure it compiles successfully
* DO - Run unit tests with tool #${ToolNames_1.McpToolNames.JAVA_RUN_TEST} and ensure they pass
* DO - Clean up old code files and project configurations if they are no longer needed after migration
* DO - **CRITICAL**: Migrate ALL files containing old technology references - do NOT assume any files are "intentionally unchanged" or "no longer used"
* DO NOT - No infrastructure setup (assumed to be handled separately)
* DO NOT - No deployment considerations
* DO NOT - No application/service/project assessment is required
* NEVER run build or test with terminal commands, you MUST use tools #${ToolNames_1.McpToolNames.JAVA_BUILD} and #${ToolNames_1.McpToolNames.JAVA_RUN_TEST} to run build and test
* NEVER run version control operations with terminal commands, you MUST use tool #${ToolNames_1.McpToolNames.VERSION_CONTROL} for all version control operations
`;
        const toolUsage = `
## Tool usage
* USE - #${ToolNames_1.McpToolNames.SEARCH_FILE} to search content in files
* USE - #${ToolNames_1.McpToolNames.SEARCH_KB} to search kb by the scenario
* USE - #${ToolNames_1.McpToolNames.GET_KB} to get the knowledge base by the ID${!supportListJdk
            ? ''
            : `
* USE - #${ToolNames_1.UpgradeToolNames.ListJdks} to collect a list of JDKs avaliable in the device
* USE - #${ToolNames_1.UpgradeToolNames.ListMavens} to collect a list of Mavens avaliable in the device if the project is built by maven`}
* USE - #${ToolNames_1.McpToolNames.MIGRATION_SUMMARY} to generate migration summary
* USE - #${ToolNames_1.McpToolNames.CONSISTENCY_VALIDATE} to validate code consistency after migration and ensure behavior equivalence
* USE - #${ToolNames_1.McpToolNames.COMPLETENESS_VALIDATE} to validate migration completeness by systematically discovering ALL unchanged items across ALL KB patterns before fixing them - NO EXCEPTIONS for perceived "unused" or "intentional" files
* You MUST use tool #${ToolNames_1.McpToolNames.VERSION_CONTROL} for all version control operations
* You MUST use tool #${ToolNames_1.McpToolNames.JAVA_RUN_TEST} to run the unit test cases, DO NOT use terminal commands
* You MUST use tool #${ToolNames_1.McpToolNames.JAVA_BUILD} to compile the project, DO NOT use terminal commands
* You MUST use tool #${ToolNames_1.McpToolNames.JAVA_FIX_TEST} to generate fix guidelines for unit test failures
* You MUST use tool #${cveToolName} to validate and fix introduced CVEs
* You MUST use tool #${ToolNames_1.VscodeToolNames.GetConfigTool} to retrieve extension configuration settings
* â›” FORBIDDEN: DO NOT USE #${ToolNames_1.McpToolNames.RUN_ASSESSMENT} to run assessment, this is strictly prohibited for this task
* â›” FORBIDDEN: DO NOT USE #${ToolNames_1.McpToolNames.PRECHECK_ASSESSMENT} to initialize assessment, this is strictly prohibited for this task
* â›” FORBIDDEN: DO NOT USE #${ToolNames_1.McpToolNames.INSTALL_APPCAT} to install appcat, this is strictly prohibited for this task
`;
        const successCriteria = `
## Success criteria
* No CVEs introduced during migration
* Codebase compiles successfully
* Code maintains functional consistency after migration
* All unit tests pass after migration
* All dependencies and imports are replaced
* All old code files and project configurations are cleaned
* All migration tasks are tracked and completed
`;
        const progressTracking = `
## Progress Tracking
* Before starting the migration, you MUST track the progress as todos.
* !!!Important!!! Save the task list in a file named \`${reportPath}/progress.md\` and open it in preview mode using ${ToolNames_1.VscodeToolNames.PreviewMarkdown} to ensure proper formatting and readability
* You MUST always update this file with the latest progress in the \`Progress\` section, including:
    - Task with status (in progress, completed)
    - Current In-progress tasks should be marked as \`[âŒ›ï¸]\`
    - Completed tasks should be marked as \`[âœ…]\`
    - Failed tasks should be marked as \`[âŒ]\`
    - Only show one of next pending tasks, do NOT show all tasks
* You must use the steps from migration workflow as tasks
* You should also additionally add below steps in the progress file, marking it as \`[âœ…]\` once finished
    - Migration Plan Generation (add link to the progress file)
    - Final Summary (add link to the progress file)
      - Final Code Commit (sub-step of Final Summary)
      - Migration Summary Generation (sub-step of Final Summary)
* You should add below step in the progress file only when run in interactive mode
    - Migration Plan Confirmation (only if interactive mode)
* When in code migration stage, you should:
    - Use matching KB as sub-tasks and update progress of each file change status
    - Document any issues encountered, how they were resolved, and any remaining issues
* Sample Progress File
    - [âœ…] Migration Plan Generation
        - [âœ…] Plan generated (link to the progress file)
        - [âœ…] User confirmed
    - Code Migration
        - [âœ…] path/to/changed/file
        - [âŒ›ï¸] path/to/in/progress/file
        - ...
    - Validation & Fixing (In loops)
    ${supportListJdk
            ? `        - [âœ…] Build Environment is setup
            - [âœ…] JAVA_HOME is set to /path/to/java/home
            - [âœ…] MAVEN_HOME is set to /path/to/maven/home`
            : ``}
        - [âœ…] Build Environment is setup
            - [âœ…] JAVA_HOME is set to /path/to/java/home
            - [âœ…] MAVEN_HOME is set to /path/to/maven/home
        - Iteration Loop 1
          - ...
          - [âŒ] Build Fix
          - [âœ…] Consistency Check
          - [âœ…] Completeness Check
          - ...
        - ...
    - [âœ…] Final Summary (link to the progress file)
      - [âœ…] Final Code Commit
      - [âœ…] Migration Summary Generation
`;
        const executionWorkflow = `
## Execution Workflow

âš ï¸ **CRITICAL INSTRUCTIONS**:
* A new migration session ID: **${context.correlationId}** has been created. (You must remember this session ID to use it invoke other tools in followup steps). All the subsequent tool invocations must be included in this migration session.
* You MUST strictly execute bellow migration steps in order, DO NOT skip any steps:
    - Progress tracking
    - Migration plan generation
    - Version control setup
    - Code migration
    - Validation & Fix
    - Final Summary
      - Final Code Commit
      - Migration Summary Generation
* You MUST create a migration plan, including code migration and validation & fix steps.
* When run in interactive mode, you should wait for the confirmation by user, then you have the highest decision-making authority at any time, you do NOT need to seek my approval/confirmation, please directly execute your plan and update the progress back to plan.

âš ï¸ **CRITICAL COMPLETION COMMIT**: 
  - After ALL migration tasks are completed successfully, you MUST use #${VERSION_CONTROL_TOOL} with action 'commitChanges' and commitMessage "Code migration completed: [brief summary of changes]" in workspace directory: ${workspacePath}
  
âš ï¸ **CRITICAL RESTART REQUIREMENTS**:
* After completing ALL code migration tasks, you MUST execute the VALIDATION & FIX ITERATION LOOP exactly as described in step 3
* You MUST execute all the stages in sequence attempting to resolve all issues
* **MANDATORY RESTART RULE**: You MUST restart from first Stage ONLY AFTER completing all the stages whenever ANY changes are made in ANY stage during an iteration
* This restart rule ensures that changes don't introduce new issues in previously validated areas
* Do NOT skip any validation stage
* Continue iterations until either:
  - **SUCCESS**: An iteration completes with ALL stages passing AND no changes made during that iteration, OR
  - **MAXIMUM REACHED**: You've reached the maximum 10 iterations (even if some issues remain unresolved)
* ALWAYS generate the final migration summary using the exact conditions specified in step 3
`;
        const planning = `
### 1. Code migration plan generation
* Use tools to retrieve the knowledge base for details with migration session ID **${context.correlationId}**
* You MUST use tool #${ToolNames_1.VscodeToolNames.GetConfigTool} to get the configuration for key 'uncommittedChangesAction' (this will be used in the Version Control Setup step)
* Search for source code files by the patterns from knowledge base with migration session ID **${context.correlationId}**
* Generate the migration plan, including:
  - Migration Session ID: **${context.correlationId}**
  - Time of this plan creation (${(0, utils_1.getFormattedTimestamp)()})
  - Uncommitted Changes Policy: [The policy value retrieved from #${ToolNames_1.VscodeToolNames.GetConfigTool}]
  - Target branch name: \`${branchName}\` (will be used during version control setup after plan confirmation)
  - Files to be changed, incl. search patterns
  - The matching knowledge base guidelines (title only)
  - You should sort the order of files to be changed based on:
    - Analyze file dependency relationships and construct a dependency graph. A file is considered dependent on other files if:
      - It uses class, methods or fields defined in other Java files.
      - It references Spring configuration keys defined in other configuration files.
      - It autowires Spring beans defined in other Java files.
    - Update files following the determined dependency order:
      - Modify files that have no dependencies first.
      - A file should only be updated after all its dependent files have been modified.
    - When a file's dependent files are updated, use these changes as a reference to make necessary updates in the file:
      - Update the file to use the new API if there are changes to classes, methods, or fields that the file depends on.
      - Modify the file to use updated configuration keys if there are changes to keys referenced in the file.
      - Adjust the file to use updated Spring Beans if there are changes to injected Spring Beans.
      - Review other relevant changes in dependent files and apply necessary updates to ensure compatibility.
${supportListJdk
            ? `  - According to the project dependency analysis and JDKs and build tools avaliable in the device, generate the the Build enviroment settings include below sections:
    - JDK settings:
      - The JDK version: The JDK version the project is using. It should respect the user defined in the dependency file like java.version, maven.compiler.source, sourceCompatibility
      - Reason you choose above JDK version
      - Need to install a new JDK: It should be true if no JDK is detected or the existing installed JDK version is not suitable (existing installed JDK is lower than the JDK version of project or the installed JDK is not the LTS version 8, 11, 17, or 21), or it should be false
      - JAVA_HOME: A path a JDK already installed, with suitable version equal to or higher than the JDK version the project is using, and it must be the LTS version (8, 11, 17, or 21). If multiple suitable JDKs found, choose the one user configured in system enviroment with priority JAVA_HOME,PATH... If no suitable JDK is found, this field should be N/A
      - Reason you choose above installed JDK path if a suitable JDK is found, the reason include version suitability and user configuration in system environment like JAVA_HOME, PATH...
      - The path to install a new JDK: If Need to install a new JDK, it must be installed to ${(0, JavaBuildToolRequest_1.getDefaultJDKInstallPath)()} and you must not change it. If no need to install a new JDK, the field should be N/A
      - The JDK version of the new JDK to be installed: A JDK version to install if a new JDK needs to be installed. It should be one of the LTS versions (version 8, 11, 17, or 21), with a suitable version equal to or higher than the JDK version currently used by the project.
    - Build Tool settings
      - The build tool type (maven or gradle) to use for the build: If both exist, prefer to use maven
      - Is wrapper used for the build tool
      - MAVEN_HOME: A path a maven already installed, if wrapper used for the build tool.
      - The path to install the maven/gradle: A path to install maven or gradle if no maven or gradle is detected in current device. It must be installed to ${(0, JavaBuildToolRequest_1.getDefaultMavenInstallPath)()} and you must not change it. This field MUST not be appear if wrapper used for the build tool`
            : ''}
* Save the Migration Plan
- You must save the migration plan to workspace directory: ${workspacePath} in \`${reportPath}/${exports.planFileName}\`.
- If plan file already exists, you should overwrite it with the new plan.
- âš ï¸ **CRITICAL**: Do NOT perform any version control operations (like checking version control status or handling uncommitted changes) during plan generation. These operations will be performed only after user confirms the plan.
`;
        const versionControlSetup = `
### 2. Version Control Setup (ONLY AFTER Plan is Confirmed)
ðŸ”´ **MANDATORY VERSION CONTROL POLICY**:
* ðŸ›‘ NEVER USE DIRECT git COMMANDS - ONLY USE #${VERSION_CONTROL_TOOL}
* ðŸ›‘ DO NOT EXECUTE ANY VERSION CONTROL OPERATIONS DURING PLAN GENERATION
* ðŸ›‘ WAIT FOR EXPLICIT PLAN CONFIRMATION BEFORE PROCEEDING WITH THESE STEPS

âš ï¸ **CRITICAL INSTRUCTIONS FOR VERSION CONTROL SETUP**:
* These steps MUST be executed ONLY AFTER the migration plan has been confirmed by the user
* You MUST execute these steps BEFORE starting any code migration tasks
* Use #${VERSION_CONTROL_TOOL} to check if version control system is available:
  - Check status with action 'checkStatus' in workspace directory: ${workspacePath}
  - âš ï¸ **MANDATORY**: Check for existing uncommitted changes before creating any new branch:
    * Use #${VERSION_CONTROL_TOOL} with action 'checkForUncommittedChanges' in workspace directory: ${workspacePath}
    * âš ï¸ **CRITICAL**: IF uncommitted changes exist, you MUST handle them according to the 'uncommittedChangesAction' retrieved during plan generation BEFORE proceeding to branch creation:
      - If the policy is 'Always Stash': You MUST use #${VERSION_CONTROL_TOOL} with action 'stashChanges' and stashMessage "Auto-stash: Save uncommitted changes before migration" in workspace directory: ${workspacePath}
      - If the policy is 'Always Commit': You MUST use #${VERSION_CONTROL_TOOL} with action 'commitChanges' and commitMessage "Auto-commit: Save uncommitted changes before migration" in workspace directory: ${workspacePath}
      - If the policy is 'Always Discard': You MUST use #${VERSION_CONTROL_TOOL} with action 'discardChanges' in workspace directory: ${workspacePath}
      - If the policy is 'Always Ask': You MUST inform the user about the uncommitted changes and ask how they would like to proceed, providing these options: stash, commit, or discard. Wait for the user's response before taking any action.
    * âš ï¸ **VERIFICATION REQUIRED**: After handling uncommitted changes, you MUST use #${VERSION_CONTROL_TOOL} with action 'checkForUncommittedChanges' to verify that the working directory is clean in workspace directory: ${workspacePath} before proceeding to branch creation
    * IF no uncommitted changes exist: proceed directly to branch creation
  - âš ï¸ **ONLY AFTER handling uncommitted changes**: Use #${VERSION_CONTROL_TOOL} with action 'createBranch' and branchName '${branchName}' in workspace directory: ${workspacePath}
  - Verify branch creation was successful before proceeding
* If NO version control system detected (as indicated by the response from #${VERSION_CONTROL_TOOL}):
  - Note "No version control detected" and proceed with direct migration on workspace directory: ${workspacePath}    
`;
        const validationAndFix = `
### 3. Append the Plan with Validation & Fix Steps

âš ï¸ **CRITICAL INSTRUCTIONS**:
After the code migration part, you MUST append the plan with the following validation & fix steps.
To make the plan clear and actionable, you MUST follow these steps:
* When you append the validation & fix steps, you MUST include below steps EXACTLY AS THEY APPEAR in this prompt.
* DO NOT modify, summarize, or paraphrase these steps.
* COPY AND PASTE them directly from this prompt into your migration plan.
* These steps contain specific tool references and detailed instructions that MUST be preserved exactly as written.
* Failure to include these exact steps will result in an invalid migration plan.

  ## VALIDATION & FIX STEPS
  You MUST execute the following validation and fix iteration loop until ALL issues are resolved. 
  
  âš ï¸ **CRITICAL LOOP RESTART RULE**: 
  - Complete ALL the stages in sequence in the current iteration
  - IF ANY CHANGES ARE MADE during ANY stage of the current iteration, you MUST start a NEW iteration from first Stage ONLY AFTER completing all the stages of the current iteration
  - This ensures that any changes made in one stage don't introduce new issues in other areas
  - Only proceed to Final Summary when an ENTIRE iteration completes successfully WITHOUT making any changes in any of the four stages

  ### Iteration Loop Process:
  Each iteration must go through all stages in sequence:
  
  âš ï¸ **MANDATORY ITERATION TRACKING**:
  - At the beginning of each iteration, you MUST clearly state: "ðŸ”„ **VALIDATION ITERATION [X]/10** - Starting validation loop" in the progress tracking
  - At the beginning of each stage, you MUST clearly state: "ðŸ“ **ITERATION [X] - STAGE [Y]: [STAGE_NAME]**" in the progress tracking
  - This helps track progress through the validation loop and prevents getting lost in long iteration flows

  ### Iteration Completion Rules:
  **After completing all stages in current iteration**:
  
  **IF NO CHANGES were made in ANY stage during this iteration**:
  * âœ… Current iteration is SUCCESSFUL
  * âš ï¸ **FINAL ITERATION COMMIT CHECK**: Before proceeding to Final Summary, ensure all changes from previous iterations are committed:
    * Use #${VERSION_CONTROL_TOOL} with action 'checkForUncommittedChanges' in workspace directory: ${workspacePath} to verify no uncommitted changes exist
    * IF any uncommitted changes are found: Use #${VERSION_CONTROL_TOOL} with action 'commitChanges' and commitMessage "Final fixes: Cleanup remaining issues" in workspace directory: ${workspacePath}
  * âœ… Proceed to Final Summary - validation loop is complete
  
  **IF ANY CHANGES were made in ANY stage during this iteration**:
  * Document all changes made in this iteration
  * âš ï¸ **NOW** start a NEW iteration from first Stage
  * Continue until either:
    - An iteration completes with NO changes made in any stage, OR
    - Maximum 10 iterations are reached
  `;
        const cveFix = `
  ### CVE Validation and Fixing
  - List all added/updated Java dependencies in format 'groupId:artifactId:version'
  - Use tool #${cveToolName} to scan for vulnerabilities for these dependencies and get recommended fix versions
  - Document any detected CVEs
  - Apply the recommended fixes for any detected CVEs
  - Document all changes made to address CVEs
  - âš ï¸ **IF CVE FIXES ARE APPLIED**: 
    * Mark current iteration as "changes made" 
    * **MUST COMMIT**: Use #${VERSION_CONTROL_TOOL} with action 'commitChanges' and commitMessage "CVE fixes: [specific CVE fixes summary]" (e.g., "CVE fixes: Update Spring Boot to 3.2.12 to fix CVE-2023-1234") in workspace directory: ${workspacePath}
    * CONTINUE to Stage 2 (do NOT restart iteration yet) and update the progress tracking
`;
        const buildFix = `
  ### Build Validation and Fixing
  ${supportInstallJdk
            ? `  - You MUST make sure the JDK and build tool are properly installed before you run the build. Before you run the tool #${ToolNames_1.McpToolNames.JAVA_BUILD}, you must make sure the JDK and build tool are installed in the device according to plan
    - If the JDK is not installed in the plan, use the tool #${ToolNames_1.UpgradeToolNames.InstallJdkTool} to install the JDK with the version specified in the plan to the destination path outlined in the plan
    - If a wrapper is used for the build tool, and the build tool is Maven, but it is not installed on the device according to plan, use the tool #${ToolNames_1.UpgradeToolNames.InstallMavenTool} to install the Maven into the destination path to install the maven/gradle given in the plan with latest version
    - You MUST update the Build enviroment settings in plan and Progress File with the JDK installation path and build tool installation path after installation
    - You MUST set the JAVA_HOME environment variable to point to the JDK Path in plan anytime you use tool #${TERMINAL_TOOL} to run mvn command
    - You MUST use the full path of the mvn command from plan when you use tool #${TERMINAL_TOOL} to run mvn command, if there is maven installed
  `
            : ''}
  - You MUST use tool #${ToolNames_1.McpToolNames.JAVA_BUILD} with migration session ID **${context.correlationId}** to compile the project, do NOT use terminal commands to run build
  - If there are multiple build tools available, you MUST use mvnen to build the project if maven is one of them
   ${!supportListJdk
            ? ``
            : `   - You MUST call the tool #${ToolNames_1.McpToolNames.JAVA_BUILD} use the JAVA_HOME and MAVEN_HOME in the migration plan to
`}

  - For any build failures:
    * Analyze each error in detail
    * Implement fixes for each error
    * Document each error and its corresponding fix
    * Use tool #${ToolNames_1.McpToolNames.JAVA_BUILD} with migration session ID **${context.correlationId}** to verify the fix
  - Continue this process until the build is successful or maximum 10 attempts are reached
  - Document all build failures and the final fix results
  - âš ï¸ **IF BUILD FIXES ARE APPLIED**: 
    * Mark current iteration as "changes made"
    * **MUST COMMIT**: Use #${VERSION_CONTROL_TOOL} with action 'commitChanges' and commitMessage "Build fixes: [specific build issues resolved]" (e.g., "Build fixes: Fix import statements and dependency conflicts in ServiceImpl") in workspace directory: ${workspacePath}
    * CONTINUE to Stage 3 (do NOT restart iteration yet) and update the progress tracking
    `;
        const consistencyValidation = `
  ### Consistency validation and fixing
    After build fix, you MUST execute the consistency validation flow to ensure code is functionally consistent:
    - Use tool #${ToolNames_1.McpToolNames.CONSISTENCY_VALIDATE} with these EXACT parameters:
      * migrationSessionId: **${context.correlationId}** to generate a guideline for code consistency validation
      * baselineRevisionId: **${latestCommitId || ''}**
    - Follow the provided guideline to analyze the code for functional consistency
    - Document all detected inconsistency issues from your analysis
    - Group inconsistency issues by severity levels (Critical, Major, Minor)
    - For any inconsistency issues with severity "Critical" or "Major":
      * Identify the specific functional differences between original and migrated code
      * Implement fixes to ensure the migrated code maintains the same behavior as the original
    - For "Minor" issues, document them with a note on potential impact
    - Document all detected issues and the final fix results
    - âš ï¸ **IF CONSISTENCY FIXES ARE APPLIED**: 
      * Mark current iteration as "changes made"
      * **MUST COMMIT**: Use #${VERSION_CONTROL_TOOL} with action 'commitChanges' and commitMessage "Consistency fixes: [specific issues resolved]" (e.g., "Consistency fixes: Restore missing validation logic and error handling in UserService") in workspace directory: ${workspacePath}
      * CONTINUE to Stage 4 (do NOT restart iteration yet) and update the progress tracking
`;
        const testFix = `
  ### Test Validation and Fixing
  - You MUST use tool #${ToolNames_1.McpToolNames.JAVA_RUN_TEST} with migration session ID **${context.correlationId}** to run the unit tests, do NOT use terminal commands to run tests
     ${!supportListJdk
            ? ``
            : `   - You MUST call the tool #${ToolNames_1.McpToolNames.JAVA_RUN_TEST} use the JAVA_HOME and MAVEN_HOME in the migration plan to run the tests
`}
  - **FIRST**: Analyze test failures and categorize them:
    * Identify and document integration tests (IT) that should be skipped:
      - Tests with @Integration, @SpringBootTest, @TestContainers, @DataJpaTest annotations
      - Tests requiring external resources (databases, servers, APIs)
      - Test failures indicating missing external dependencies
    * Document these as "Skipped Integration Tests" and exclude from fix attempts
    * Only proceed to fix genuine unit tests that don't require external dependencies
  - Follow below guidelines to fix the unit tests:
    * IMPORTANT: Focus on fixing ONLY the test cases, NEVER create or modify any Java implementation classes
    * IMPORTANT: When mocking final classes or methods, use mockito-inline instead of refactoring the code. Add mockito-inline dependency to the pom.xml
    * DO NOT refactor or modify the original implementation classes to make them easier to test
  - For each test failure:
    * Analyze the error in detail
    * Implement fixes for the test
    * Document the error and its corresponding fix
    * Use tool #${ToolNames_1.McpToolNames.JAVA_RUN_TEST} with migration session ID **${context.correlationId}** to verify the fix
  - Continue this process until all **unit tests** pass or maximum 10 attempts are reached (integration tests in "Skipped Integration Tests" do NOT count as failures)
  - Document all test failures and the final fix results
  - âš ï¸ **IF TEST FIXES ARE APPLIED**: 
    * Mark current iteration as "changes made"
    * **MUST COMMIT**: Use #${VERSION_CONTROL_TOOL} with action 'commitChanges' and commitMessage "Test fixes: [specific test issues resolved]" (e.g., "Test fixes: Fix mock configurations and update assertions in UserServiceTest") in workspace directory: ${workspacePath}
    * CONTINUE to Stage 5 (do NOT restart iteration yet) and update the progress tracking
`;
        const completenessValidation = `
  ### Completeness Validation and Fixing
  ðŸš¨ **CRITICAL**: This stage catches migration items missed in initial code migration. Execute ALL sub-stages systematically:

  **5.1 - Get Validation Guidelines**: Use tool #${ToolNames_1.McpToolNames.COMPLETENESS_VALIDATE} with migration session ID **${context.correlationId}** to generate completeness validation guidelines
  **5.2 - ðŸš¨ MANDATORY FILE DISCOVERY**: **YOU MUST ACTUALLY EXECUTE THE SEARCHES** provided by the completeness validation tool:
    * The tool will give you specific search patterns and commands to find remaining old technology references
    * **EXECUTE EVERY SINGLE SEARCH** the tool recommends - do NOT skip any searches thinking files are "unused" or "intentionally unchanged"
    * Use #${ToolNames_1.McpToolNames.SEARCH_FILE} with the exact patterns provided by the validation tool
    * Search in ALL file types: build files (pom.xml, build.gradle), config files, source files, resources, documentation
    * Document EVERY file found by your searches that contains old technology references
  **5.3 - Analyze & Document**: For each discovered file from your searches, identify and document ALL unchanged old technology references with specific locations and expected changes
  **5.4 - Fix All Issues**: Apply ALL documented fixes systematically - âš ï¸ **NO EXCEPTIONS**: migrate every old technology reference regardless of perceived usage
  **5.5 - Commit Changes**: âš ï¸ **IF FIXES APPLIED**: 
    * Mark current iteration as "changes made"
    * Use #${VERSION_CONTROL_TOOL} with action 'commitChanges' and commitMessage "Completeness fixes: [specific completeness issues resolved]" (e.g., "Completeness fixes: Update remaining configuration and dependencies") in workspace directory: ${workspacePath}
    * CONTINUE to Iteration Completion Rules (do NOT restart iteration yet) and update the progress tracking
`;
        const finalSummary = `
  ### Final Summary
  
  #### Step 1: Final Code Commit
  - âš ï¸ **MANDATORY FINAL COMMIT** (if version control system is available): Before generating the migration summary, you MUST ensure ALL code changes have been committed:
    * Use #${VERSION_CONTROL_TOOL} with action 'checkForUncommittedChanges' in workspace directory: ${workspacePath} to verify uncommitted changes
    * If uncommitted changes exist: Use #${VERSION_CONTROL_TOOL} with action 'commitChanges' and commitMessage "Final migration completion: [brief summary]" in workspace directory: ${workspacePath}
    * Use #${VERSION_CONTROL_TOOL} with action 'checkForUncommittedChanges' in workspace directory: ${workspacePath} to verify the commit was successful and no uncommitted changes remain
    * â›” **DO NOT PROCEED TO SUMMARY GENERATION UNTIL ALL CHANGES ARE COMMITTED**
  - If NO version control system is available: proceed directly to Step 2
  
  #### Step 2: Migration Summary Generation
  - Generate final summary ONLY after:
    - An iteration completes successfully with ALL validation stages passing AND no changes made in any stage, OR
    - Maximum 10 iterations are reached (even if issues remain unresolved)
  - You MUST use tool #${ToolNames_1.McpToolNames.MIGRATION_SUMMARY} with migration session ID **${context.correlationId}** to get the instructions for creating migration summary:
    - Follow the instructions provided by the tool to create the migration summary.
    - Save the migration summary to the report path: \`${reportPath}/summary.md\`
  
  #### Step 3: Process Completion
  - After both the code commit and migration summary sub-steps are complete, update the progress tracking to indicate the migration process is complete
  - This finalizes the entire migration workflow
`;
        const validationStages = skipCveFixAndTestFix
            ? [
                {
                    title: 'Build Validation and Fix',
                    instruction: buildFix,
                },
                {
                    title: 'Consistency Validation and Fix',
                    instruction: consistencyValidation,
                },
                {
                    title: 'Completeness Validation',
                    instruction: completenessValidation,
                },
            ]
            : [
                {
                    title: 'CVE Validation and Fix',
                    instruction: cveFix,
                },
                {
                    title: 'Build Validation and Fix',
                    instruction: buildFix,
                },
                {
                    title: 'Consistency Validation and Fix',
                    instruction: consistencyValidation,
                },
                {
                    title: 'Test Validation and Fix',
                    instruction: testFix,
                },
                {
                    title: 'Completeness Validation',
                    instruction: completenessValidation,
                },
            ];
        const response = {
            sessionId: context.correlationId,
            runMode: (0, utils_1.isJest)() ? 'non-interactive' : 'interactive',
            generalExecutionInstructions: executionWorkflow,
            goal: goal,
            scope: scope,
            toolUsageInstructions: toolUsage,
            successCriteria: successCriteria,
            progressTrackingInstructions: progressTracking,
            planningInstructions: planning,
            versionControlSetupInstructions: versionControlSetup,
            finalSummaryInstructions: finalSummary,
            validations: {
                validationInstructions: validationAndFix,
                stages: validationStages,
            },
        };
        eventEmitter.emit('run_task_success', { workspacePath, scenario, kbId }, context);
        return this.createStructuredResponse(response);
    }
    configureGitUserForBenchmark() {
        const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
        try {
            (0, child_process_1.execSync)('git config --global user.email "app_modernization@example.com"', {
                stdio: 'inherit',
            });
            (0, child_process_1.execSync)('git config --global user.name "app_modernization"', { stdio: 'inherit' });
            logger.info('Git user settings configured for benchmark test');
        }
        catch (error) {
            logger.warn('Failed to configure git user settings:', error);
        }
    }
    setupOutDirectoryGitignore(workspacePath) {
        const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
        // Check if .out directory exists and create .gitignore if needed
        const outDirPath = path_1.default.join(workspacePath, '.out');
        logger.info(`Checking for .out directory at: ${outDirPath}`);
        if (fs.existsSync(outDirPath)) {
            const outGitignorePath = path_1.default.join(outDirPath, '.gitignore');
            logger.info(`Found .out directory, creating .gitignore at: ${outGitignorePath}`);
            fs.writeFileSync(outGitignorePath, `\n*\n`);
            logger.info('Successfully created .gitignore in .out directory');
        }
        else {
            logger.info('.out directory not found, skipping .gitignore creation');
        }
    }
}
exports.RunTaskToolImpl = RunTaskToolImpl;
//# sourceMappingURL=RunTaskToolImpl.js.map