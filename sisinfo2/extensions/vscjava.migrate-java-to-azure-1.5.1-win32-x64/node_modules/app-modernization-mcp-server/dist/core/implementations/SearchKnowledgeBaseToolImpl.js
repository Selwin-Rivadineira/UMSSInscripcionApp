"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchKnowledgeBaseToolImpl = void 0;
const tsyringe_1 = require("tsyringe");
const metadata_1 = require("../../kb/metadata");
const ToolNames_1 = require("../../tools/ToolNames");
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const Tool_1 = require("../Tool");
const toolDescription_1 = require("../toolDescription");
class SearchKnowledgeBaseToolImpl extends Tool_1.BaseTool {
    constructor() {
        super(...arguments);
        this.name = ToolNames_1.McpToolNames.SEARCH_KB;
        this.toolReferenceName = ToolNames_1.McpToolNames.SEARCH_KB;
        this.displayName = 'Search Knowledge Base';
        this.description = toolDescription_1.ToolDescriptions.SEARCH_KB;
    }
    async execute(request, context) {
        const { query } = request;
        const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
        const kbStore = tsyringe_1.container.resolve(types_1.Beans.KBStore);
        try {
            const kbs = await kbStore.searchKbs(context, query);
            if (!kbs || kbs.length === 0) {
                throw new Error(`No KB found with query: ${query}`);
            }
            // Return data in a format compatible with McpServer
            return this.createSuccessResponse(this.formatKBSearchResults(kbs));
        }
        catch (error) {
            logger.error(`Error during search:`, error);
            let message = 'Unknown error';
            if (error instanceof Error) {
                message = error.message;
            }
            return this.createErrorResponse(`Error during search: ${message}`);
        }
    }
    formatKBSearchResults(kbs) {
        return `Available knowledge bases:

Each result includes:
- KB ID: Unique identifier
- Title: Knowledge base title
- Description: Knowledge base description
- Trust Score: Authority indicator
... other fields ...

For best results, select knowledge base based on name match, trust score, and relevance to your use case.

----------

${kbs.map((kb) => this.formatEachKb(kb)).join('\n\n----------\n\n')}
`;
    }
    formatEachKb(kbWithScore) {
        let message = `KB ID: ${kbWithScore.item.id}
Title: ${kbWithScore.item.title}
Description: ${kbWithScore.item.description}
Trust Score: ${kbWithScore.score.toFixed(2)}`;
        const metadataToShow = (0, utils_1.omit)(kbWithScore.item.metadata, [
            ...Object.values(metadata_1.ReservedSystemMetadata),
        ]);
        if (metadataToShow) {
            for (const metadataKey of Object.keys(metadataToShow)) {
                message += `\n${(0, utils_1.camelToTitleWithSpace)(metadataKey)}: ${metadataToShow[metadataKey]}`;
            }
        }
        return message;
    }
}
exports.SearchKnowledgeBaseToolImpl = SearchKnowledgeBaseToolImpl;
//# sourceMappingURL=SearchKnowledgeBaseToolImpl.js.map