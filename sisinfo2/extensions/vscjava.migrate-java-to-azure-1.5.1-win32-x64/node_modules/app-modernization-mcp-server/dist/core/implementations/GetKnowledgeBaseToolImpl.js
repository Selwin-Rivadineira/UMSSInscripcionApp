"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetKnowledgeBaseToolImpl = void 0;
const tsyringe_1 = require("tsyringe");
const metadata_1 = require("../../kb/metadata");
const ToolNames_1 = require("../../tools/ToolNames");
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const Tool_1 = require("../Tool");
const toolDescription_1 = require("../toolDescription");
class GetKnowledgeBaseToolImpl extends Tool_1.BaseTool {
    constructor() {
        super(...arguments);
        this.name = ToolNames_1.McpToolNames.GET_KB;
        this.toolReferenceName = ToolNames_1.McpToolNames.GET_KB;
        this.displayName = 'Fetch Knowledge Base';
        this.description = toolDescription_1.ToolDescriptions.GET_KB;
    }
    async getKb(context, kbId, workspacePath) {
        const kbStore = tsyringe_1.container.resolve(types_1.Beans.KBStore);
        const kbs = await kbStore.findKbById(context, kbId);
        if (!kbs || kbs.length === 0) {
            throw new Error(`No KB found with id: ${kbId}`);
        }
        const eventEmitter = tsyringe_1.container.resolve(types_1.Beans.McpEventEmitter);
        for (const kb of kbs) {
            eventEmitter.emit('kb_apply_success', { kb, workspacePath }, context);
        }
        return kbs.map((kb) => this.formatEachKb(kb)).join('\n\n----------\n\n');
    }
    async execute(request, context) {
        const { kbId, workspacePath } = request;
        const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
        if (!kbId) {
            return this.createErrorResponse('KB ID is required');
        }
        try {
            const kbData = await this.getKb(context, kbId, workspacePath);
            return this.createSuccessResponse(kbData);
        }
        catch (error) {
            logger.error(`Failed to retrieve KB:`, error);
            let message = 'Unknown error';
            if (error instanceof Error) {
                message = error.message;
            }
            throw error;
            return this.createErrorResponse(`Failed to retrieve KB: ${message}`);
        }
    }
    formatEachKb(kb) {
        let kbContent = `* KB ID: ${kb.id}
* Title: ${kb.title}
* Description: ${kb.description}
* Content: ${kb.content || 'No content available'}`;
        const tags = metadata_1.MetadataGetter.getTags(kb);
        if (tags && tags.length > 0) {
            kbContent += `* Tags: ${tags.join(', ')}`;
        }
        const metadataToShow = (0, utils_1.omit)(kb.metadata, [
            ...Object.values(metadata_1.ReservedSystemMetadata),
        ]);
        if (metadataToShow) {
            for (const metadataKey of Object.keys(metadataToShow)) {
                kbContent += `\n${(0, utils_1.camelToTitleWithSpace)(metadataKey)}: ${metadataToShow[metadataKey]}`;
            }
        }
        return kbContent;
    }
}
exports.GetKnowledgeBaseToolImpl = GetKnowledgeBaseToolImpl;
//# sourceMappingURL=GetKnowledgeBaseToolImpl.js.map