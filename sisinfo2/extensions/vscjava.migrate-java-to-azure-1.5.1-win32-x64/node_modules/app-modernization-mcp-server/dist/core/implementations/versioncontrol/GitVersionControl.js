"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitVersionControl = void 0;
const simple_git_1 = __importDefault(require("simple-git"));
const tsyringe_1 = require("tsyringe");
const types_1 = require("../../../types");
/**
 * Git implementation of the version control interface
 */
class GitVersionControl {
    constructor() {
        this.logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
    }
    /**
     * Check if a git remote URL belongs to github.com domain
     * @param url The remote URL to check
     * @returns true if the URL is from github.com, false otherwise
     */
    isGithubDomain(url) {
        try {
            // Match both https and git@ formats strictly
            return url.startsWith('https://github.com/') || url.startsWith('git@github.com:');
        }
        catch (error) {
            this.logger.error(`Error checking GitHub domain: ${error}`);
            return false;
        }
    }
    /**
     * Get the type of version control system
     */
    getType() {
        return 'git';
    }
    /**
     * Create a simple git instance for the workspace
     * @param workspacePath The workspace path
     */
    getGit(workspacePath) {
        return (0, simple_git_1.default)({
            baseDir: workspacePath,
            binary: 'git',
            maxConcurrentProcesses: 6,
        });
    }
    /**
     * Check if git is available in the workspace
     * @param workspacePath The workspace path
     */
    async isAvailable(workspacePath) {
        try {
            const git = this.getGit(workspacePath);
            await git.checkIsRepo();
            return true;
        }
        catch (error) {
            this.logger.error(`Git is not available in workspace ${workspacePath}: ${error}`);
            return false;
        }
    }
    /**
     * Validates if the workspace is a git repository and returns appropriate error response if not
     * @param workspacePath The workspace path
     * @returns Either null if valid repository or an error ToolResponse if not
     */
    async validateRepository(workspacePath) {
        try {
            const git = this.getGit(workspacePath);
            const isRepo = await git.checkIsRepo();
            if (!isRepo) {
                return {
                    success: false,
                    message: 'Not a git repository - do not initialize repository.',
                    details: {
                        output: 'Not a git repository - do not initialize repository.',
                        versionControlAvailable: false,
                    },
                };
            }
            return null; // No error, repository is valid
        }
        catch (error) {
            this.logger.error(`Error validating git repository: ${error}`);
            return {
                success: false,
                message: `Error validating git repository: ${error}`,
                details: {
                    output: `Error validating git repository: ${error}`,
                    versionControlAvailable: false,
                    error: error instanceof Error ? error.message : String(error),
                },
            };
        }
    }
    /**
     * Check the status of the repository
     * @param workspacePath The workspace path
     */
    async checkStatus(workspacePath) {
        try {
            // Validate repository
            const repoError = await this.validateRepository(workspacePath);
            if (repoError) {
                return repoError;
            }
            // Repository is valid, proceed with operation
            const git = this.getGit(workspacePath);
            const status = await git.status();
            return {
                success: true,
                message: 'Repository status retrieved successfully',
                details: {
                    output: 'Repository status retrieved successfully',
                    versionControlAvailable: true,
                    status: status, // Include structured status object directly
                },
            };
        }
        catch (error) {
            this.logger.error(`Failed to check status: ${error}`);
            return {
                success: false,
                message: `Failed to check status: ${error}`,
                details: {
                    output: `Failed to check status: ${error}`,
                    versionControlAvailable: true,
                    error: error instanceof Error ? error.message : String(error),
                },
            };
        }
    }
    /**
     * Create a new branch
     * @param workspacePath The workspace path
     * @param branchName The name of the branch to create
     */
    async createBranch(workspacePath, branchName) {
        try {
            // Validate branch name parameter
            if (!branchName) {
                return {
                    success: false,
                    message: 'Branch name is required',
                    details: {
                        error: 'Missing branchName parameter',
                        versionControlAvailable: true,
                    },
                };
            }
            // Validate repository
            const repoError = await this.validateRepository(workspacePath);
            if (repoError) {
                return repoError;
            }
            // Repository is valid, proceed with operation
            const git = this.getGit(workspacePath);
            await git.checkoutLocalBranch(branchName);
            return {
                success: true,
                message: `Branch '${branchName}' created successfully`,
                details: {
                    output: `Branch '${branchName}' created successfully`,
                    versionControlAvailable: true,
                },
            };
        }
        catch (error) {
            this.logger.error(`Failed to create branch: ${error}`);
            return {
                success: false,
                message: `Failed to create branch: ${error}`,
                details: {
                    output: `Failed to create branch: ${error}`,
                    versionControlAvailable: true,
                    error: error instanceof Error ? error.message : String(error),
                },
            };
        }
    }
    /**
     * Commit changes
     * @param workspacePath The workspace path
     * @param commitMessage The commit message
     * @param context Optional MCP context for telemetry
     */
    async commitChanges(workspacePath, commitMessage, context) {
        try {
            // Validate commit message parameter
            if (!commitMessage) {
                return {
                    success: false,
                    message: 'Commit message is required',
                    details: {
                        error: 'Missing commitMessage parameter',
                        versionControlAvailable: true,
                    },
                };
            }
            // Validate repository
            const repoError = await this.validateRepository(workspacePath);
            if (repoError) {
                return repoError;
            }
            // Repository is valid, proceed with operation
            const git = this.getGit(workspacePath);
            await git.add('.');
            const commitResult = await git.commit(commitMessage);
            // Extract the commit ID
            let commitId = '';
            if (commitResult && commitResult.commit) {
                commitId = typeof commitResult.commit === 'string' ? commitResult.commit : '';
            }
            // Send telemetry with commit ID if available
            if (commitId) {
                const eventEmitter = tsyringe_1.container.resolve(types_1.Beans.McpEventEmitter);
                // Check if all remotes are github.com
                let isGithubcom = true;
                try {
                    // Get list of remotes
                    const remotes = await git.getRemotes(true); // true to get verbose output with URLs
                    this.logger.debug(`Git remotes: ${JSON.stringify(remotes, null, 2)}`);
                    // Check if all remotes are github.com
                    if (remotes && remotes.length > 0) {
                        for (const remote of remotes) {
                            // Get the URL from each remote
                            const urls = remote.refs
                                ? [remote.refs.fetch, remote.refs.push].filter(Boolean)
                                : [];
                            // Check if any URL is not from github.com
                            for (const url of urls) {
                                if (url && !this.isGithubDomain(url)) {
                                    isGithubcom = false;
                                    break;
                                }
                            }
                            if (!isGithubcom) {
                                break;
                            }
                        }
                    }
                    else {
                        // No remotes found
                        isGithubcom = false;
                    }
                }
                catch (error) {
                    this.logger.error(`Failed to check remotes: ${error}`);
                    isGithubcom = false;
                }
                this.logger.info(`Recording telemetry for commit: ${commitId}, isGithubcom: ${isGithubcom}`);
                eventEmitter.emit('version_control_commit', {
                    versionControlSystem: 'git',
                    commitId: commitId,
                    workspacePath: workspacePath,
                    isGithubcom: isGithubcom,
                }, context);
            }
            return {
                success: true,
                message: 'Changes committed successfully',
                details: {
                    output: `Changes committed successfully (ID: ${commitId})`,
                    versionControlAvailable: true,
                    commit: commitResult, // Include structured commit result object directly
                    commitId: commitId, // Add commit ID to response for clients to use
                },
            };
        }
        catch (error) {
            this.logger.error(`Failed to commit changes: ${error}`);
            return {
                success: false,
                message: `Failed to commit changes: ${error}`,
                details: {
                    output: `Failed to commit changes: ${error}`,
                    versionControlAvailable: true,
                    error: error instanceof Error ? error.message : String(error),
                },
            };
        }
    }
    /**
     * Stash changes
     * @param workspacePath The workspace path
     * @param stashMessage The stash message (optional)
     */
    async stashChanges(workspacePath, stashMessage) {
        try {
            // Note: stashMessage is completely optional, no validation needed
            // Validate repository
            const repoError = await this.validateRepository(workspacePath);
            if (repoError) {
                return repoError;
            }
            // Repository is valid, proceed with operation
            const git = this.getGit(workspacePath);
            const stashCommand = ['push'];
            if (stashMessage) {
                stashCommand.push('-m', stashMessage);
            }
            const stashResult = await git.stash(stashCommand);
            return {
                success: true,
                message: 'Changes stashed successfully',
                details: {
                    output: 'Changes stashed successfully',
                    versionControlAvailable: true,
                    stashResult: stashResult, // Include structured stash result directly
                },
            };
        }
        catch (error) {
            this.logger.error(`Failed to stash changes: ${error}`);
            return {
                success: false,
                message: `Failed to stash changes: ${error}`,
                details: {
                    output: `Failed to stash changes: ${error}`,
                    versionControlAvailable: true,
                    error: error instanceof Error ? error.message : String(error),
                },
            };
        }
    }
    /**
     * Discard changes
     * @param workspacePath The workspace path
     */
    async discardChanges(workspacePath) {
        try {
            // No additional parameters to validate
            // Validate repository
            const repoError = await this.validateRepository(workspacePath);
            if (repoError) {
                return repoError;
            }
            // Repository is valid, proceed with operation
            const git = this.getGit(workspacePath);
            await git.reset(['--hard', 'HEAD']);
            // Also clean untracked files
            await git.clean('f', ['-d']);
            return {
                success: true,
                message: 'Changes discarded successfully',
                details: {
                    output: 'Changes discarded successfully',
                    versionControlAvailable: true,
                },
            };
        }
        catch (error) {
            this.logger.error(`Failed to discard changes: ${error}`);
            return {
                success: false,
                message: `Failed to discard changes: ${error}`,
                details: {
                    output: `Failed to discard changes: ${error}`,
                    versionControlAvailable: true,
                    error: error instanceof Error ? error.message : String(error),
                },
            };
        }
    }
    /**
     * Check for uncommitted changes
     * @param workspacePath The workspace path
     */
    async checkForUncommittedChanges(workspacePath) {
        try {
            // No additional parameters to validate
            // Validate repository
            const repoError = await this.validateRepository(workspacePath);
            if (repoError) {
                return repoError;
            }
            // Repository is valid, proceed with operation
            const git = this.getGit(workspacePath);
            const status = await git.status();
            const hasChanges = !status.isClean();
            return {
                success: true,
                message: hasChanges ? 'Uncommitted changes detected' : 'No uncommitted changes',
                details: {
                    output: hasChanges ? 'Uncommitted changes detected' : 'No uncommitted changes',
                    versionControlAvailable: true,
                    hasChanges: hasChanges,
                    files: status.files, // Include structured file status directly
                    status: status, // Include complete status information
                },
            };
        }
        catch (error) {
            this.logger.error(`Failed to check for uncommitted changes: ${error}`);
            return {
                success: false,
                message: `Failed to check for uncommitted changes: ${error}`,
                details: {
                    output: `Failed to check for uncommitted changes: ${error}`,
                    versionControlAvailable: true,
                    error: error instanceof Error ? error.message : String(error),
                },
            };
        }
    }
    /**
     * Execute a version control operation based on the request
     * @param request The version control request
     * @param context Optional MCP context for telemetry
     */
    async execute(request, context) {
        const { workspacePath, action, branchName, commitMessage, stashMessage } = request;
        // Note: workspacePath and action are validated by zod schema, no need to check again
        // First check if git is available in the workspace
        const isAvailable = await this.isAvailable(workspacePath);
        if (!isAvailable) {
            return {
                success: false,
                message: 'No version control system detected',
                details: {
                    output: 'No version control detected',
                    versionControlAvailable: false,
                },
            };
        }
        // Validate action-specific required parameters and execute corresponding methods
        switch (action) {
            case 'checkStatus':
                return this.checkStatus(workspacePath);
            case 'createBranch':
                if (!branchName) {
                    return {
                        success: false,
                        message: 'Branch name is required for createBranch action',
                        details: {
                            output: 'Branch name is required',
                            versionControlAvailable: true,
                            error: 'Missing branchName parameter',
                        },
                    };
                }
                return this.createBranch(workspacePath, branchName);
            case 'commitChanges':
                if (!commitMessage) {
                    return {
                        success: false,
                        message: 'Commit message is required for commitChanges action',
                        details: {
                            output: 'Commit message is required',
                            versionControlAvailable: true,
                            error: 'Missing commitMessage parameter',
                        },
                    };
                }
                return this.commitChanges(workspacePath, commitMessage, context);
            case 'stashChanges':
                // stashMessage is optional, so we pass it directly
                return this.stashChanges(workspacePath, stashMessage);
            case 'discardChanges':
                // No additional parameters needed
                return this.discardChanges(workspacePath);
            case 'checkForUncommittedChanges':
                // No additional parameters needed
                return this.checkForUncommittedChanges(workspacePath);
            default:
                return {
                    success: false,
                    message: `Unsupported action: ${action}`,
                    details: {
                        output: `Unsupported action: ${action}`,
                        versionControlAvailable: true,
                        error: `Invalid action parameter: ${action}`,
                    },
                };
        }
    }
}
exports.GitVersionControl = GitVersionControl;
//# sourceMappingURL=GitVersionControl.js.map