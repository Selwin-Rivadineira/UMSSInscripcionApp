"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JavaRunTestToolImpl = void 0;
const tsyringe_1 = require("tsyringe");
const JavaBuildTool_utils_1 = require("../../javabuild/JavaBuildTool.utils");
const ToolNames_1 = require("../../tools/ToolNames");
const types_1 = require("../../types");
const environmentService_1 = require("../../utils/environmentService");
const javaBuild_1 = require("../../utils/javaBuild");
const mcpLoggerAdapter_1 = require("../../utils/mcpLoggerAdapter");
const testUtils_1 = require("../../utils/testUtils");
const Tool_1 = require("../Tool");
const toolDescription_1 = require("../toolDescription");
class JavaRunTestToolImpl extends Tool_1.BaseTool {
    constructor() {
        super(...arguments);
        this.name = ToolNames_1.McpToolNames.JAVA_RUN_TEST;
        this.toolReferenceName = ToolNames_1.McpToolNames.JAVA_RUN_TEST;
        this.displayName = 'Run Java Tests';
        this.description = toolDescription_1.ToolDescriptions.JAVA_RUN_TEST;
    }
    async execute(request, context) {
        const eventEmitter = tsyringe_1.container.resolve(types_1.Beans.McpEventEmitter);
        const mcpLoggerAdapter = (0, testUtils_1.isBenchmarkTest)()
            ? new mcpLoggerAdapter_1.McpLoggerAdapter(tsyringe_1.container.resolve(types_1.Beans.Logger))
            : undefined;
        const workspaceBasePath = request.workspacePath;
        try {
            const workspaceBasePath = request.workspacePath;
            const buildEnvironment = await (0, javaBuild_1.detectBuildEnvInRepo)(workspaceBasePath, environmentService_1.defaultEnvService, request.javaHome, request.mavenHome, context, 'JavaRunTestToolImpl');
            const checkMessage = await (0, javaBuild_1.checkEnvironment)(buildEnvironment);
            if (checkMessage && checkMessage.length > 0) {
                return this.createSuccessResponse(checkMessage.join('\n'));
            }
            const buildTool = (0, JavaBuildTool_utils_1.createBuildTool)(workspaceBasePath, buildEnvironment, undefined, mcpLoggerAdapter, context.signal);
            const testResult = await buildTool.test();
            const summary = testResult.summary;
            const compileErrors = testResult.compileErrors;
            // Check if there are any compilation errors and report them
            if (compileErrors && compileErrors.length > 0) {
                const message = `Tests failed with compile errors:
${compileErrors
                    .map((error) => {
                    // Replace any HTML entities and normalize line breaks
                    const cleanErrorMessage = error.errorMessage
                        ? error.errorMessage
                            .replace(/&#10;/g, ' ') // Replace HTML newline entities with spaces
                            .replace(/\n/g, ' ') // Replace literal newlines with spaces
                            .trim()
                        : '';
                    return `\n\n- ${cleanErrorMessage}\n    \`\`\`\n${addIndent(error.raw, '  ')}\n    \`\`\``;
                })
                    .join('')}`;
                eventEmitter.emit('test_fail', {
                    error: new Error('Tests failed with compile errors'),
                    numberOfTestErrors: compileErrors.length,
                    workspacePath: workspaceBasePath,
                }, context);
                return this.createSuccessResponse(message);
            }
            if ((summary === null || summary === void 0 ? void 0 : summary.errors) || (summary === null || summary === void 0 ? void 0 : summary.failures)) {
                const toFix = [...testResult.errors, ...testResult.failures];
                const message = `Tests failed with ${summary.errors} errors and ${summary.failures} failures:${toFix
                    .map((error) => {
                    // Replace any HTML entities and normalize line breaks
                    const cleanErrorMessage = error.errorMessage
                        ? error.errorMessage
                            .replace(/&#10;/g, ' ') // Replace HTML newline entities with spaces
                            .replace(/\n/g, ' ') // Replace literal newlines with spaces
                            .trim()
                        : '';
                    return `\n\n- ${cleanErrorMessage}\n    \`\`\`\n${addIndent(error.raw, '  ')}\n    \`\`\``;
                })
                    .join('')}`;
                eventEmitter.emit('test_fail', {
                    error: new Error('Tests failed with errors or failures'),
                    numberOfTestErrors: summary.errors + summary.failures,
                    workspacePath: workspaceBasePath,
                }, context);
                return this.createSuccessResponse(message);
            }
            else {
                eventEmitter.emit('test_success', {
                    numberOfTestErrors: 0,
                    workspacePath: workspaceBasePath,
                }, context);
                return this.createSuccessResponse('All tests passed successfully.');
            }
        }
        catch (error) {
            eventEmitter.emit('test_fail', {
                error: new Error('An error occurred during test execution: ' + error.message),
                numberOfTestErrors: 0,
                workspacePath: workspaceBasePath,
            }, context);
            return this.createErrorResponse(`Error during run tests: ${error}`);
        }
    }
}
exports.JavaRunTestToolImpl = JavaRunTestToolImpl;
function addIndent(text, indent) {
    if (!text) {
        return '';
    }
    const lines = text.split('\n');
    const indentedLines = lines.map((line) => `${indent}${line}`);
    return indentedLines.join('\n');
}
//# sourceMappingURL=JavaRunTestToolImpl.js.map