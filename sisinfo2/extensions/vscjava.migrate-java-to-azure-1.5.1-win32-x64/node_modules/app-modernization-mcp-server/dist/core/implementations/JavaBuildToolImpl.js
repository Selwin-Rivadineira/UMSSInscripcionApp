"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JavaBuildToolImpl = void 0;
const tsyringe_1 = require("tsyringe");
const JavaBuildTool_utils_1 = require("../../javabuild/JavaBuildTool.utils");
const ToolNames_1 = require("../../tools/ToolNames");
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const environmentService_1 = require("../../utils/environmentService");
const javaBuild_1 = require("../../utils/javaBuild");
const mcpLoggerAdapter_1 = require("../../utils/mcpLoggerAdapter");
const testUtils_1 = require("../../utils/testUtils");
const Tool_1 = require("../Tool");
const toolDescription_1 = require("../toolDescription");
class JavaBuildToolImpl extends Tool_1.BaseTool {
    constructor() {
        super(...arguments);
        this.name = ToolNames_1.McpToolNames.JAVA_BUILD;
        this.toolReferenceName = ToolNames_1.McpToolNames.JAVA_BUILD;
        this.displayName = 'Build Java Project';
        this.description = toolDescription_1.ToolDescriptions.JAVA_BUILD;
    }
    async execute(request, context) {
        const eventEmitter = tsyringe_1.container.resolve(types_1.Beans.McpEventEmitter);
        const logger = tsyringe_1.container.resolve(types_1.Beans.Logger);
        const mcpLoggerAdapter = (0, testUtils_1.isBenchmarkTest)()
            ? new mcpLoggerAdapter_1.McpLoggerAdapter(tsyringe_1.container.resolve(types_1.Beans.Logger))
            : undefined;
        const workspacePath = request.workspacePath;
        try {
            const buildEnvironment = await (0, javaBuild_1.detectBuildEnvInRepo)(workspacePath, environmentService_1.defaultEnvService, request.javaHome, request.mavenHome, context, 'JavaBuildToolImpl');
            const checkMessage = await (0, javaBuild_1.checkEnvironment)(buildEnvironment);
            if (checkMessage && checkMessage.length > 0) {
                return this.createSuccessResponse(checkMessage.join('\n'));
            }
            const buildTool = (0, JavaBuildTool_utils_1.createBuildTool)(workspacePath, buildEnvironment, undefined, mcpLoggerAdapter, context.signal);
            const result = await buildTool.compile();
            const errors = result.details || [];
            if (errors.length === 0) {
                eventEmitter.emit('build_success', { workspacePath }, context);
                return this.createSuccessResponse('No build errors found.');
            }
            else {
                const errorMessages = errors
                    .map((e) => `- ${(0, utils_1.toMarkdown)(e)}`)
                    .join('\n')
                    .trim();
                logger.error(`Build errors found:\n${JSON.stringify(errors, null, 2)}`);
                eventEmitter.emit('build_fail', {
                    moduleBuildStatuses: result.moduleBuildStatuses,
                    error: new Error('Build errors found'),
                    workspacePath,
                }, context);
                return this.createSuccessResponse(`Build errors found:\n\n${errorMessages}`);
            }
        }
        catch (error) {
            eventEmitter.emit('build_fail', {
                error: error,
                workspacePath,
            }, context);
            return this.createErrorResponse(`Error during build: ${error}`);
        }
    }
}
exports.JavaBuildToolImpl = JavaBuildToolImpl;
//# sourceMappingURL=JavaBuildToolImpl.js.map