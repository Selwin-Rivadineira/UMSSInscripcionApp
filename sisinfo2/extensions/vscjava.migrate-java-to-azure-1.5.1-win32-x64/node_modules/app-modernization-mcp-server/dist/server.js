"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupJavaMigrationMcpServer = setupJavaMigrationMcpServer;
require("reflect-metadata");
require("./ioc");
const mcp_js_1 = require("@modelcontextprotocol/sdk/server/mcp.js");
const stdio_js_1 = require("@modelcontextprotocol/sdk/server/stdio.js");
const types_1 = require("@modelcontextprotocol/sdk/types");
const tsyringe_1 = require("tsyringe");
const uuid4_1 = __importDefault(require("uuid4"));
const core_1 = require("./core");
const toolDescription_1 = require("./core/toolDescription");
const kbAssessmentTool_1 = require("./tools/kbAssessmentTool");
const mcpTools_1 = require("./tools/mcpTools");
const runInTerminalTool_1 = require("./tools/runInTerminalTool");
const ToolNames_1 = require("./tools/ToolNames");
const types_2 = require("./types");
const utils_1 = require("./utils");
const testUtils_1 = require("./utils/testUtils");
function setupJavaMigrationMcpServer() {
    const toolsConfig = tsyringe_1.container.resolve(types_2.Beans.ToolsConfig);
    const logger = tsyringe_1.container.resolve(types_2.Beans.Logger);
    const eventEmitter = tsyringe_1.container.resolve(types_2.Beans.McpEventEmitter);
    const settings = tsyringe_1.container.resolve(types_2.Beans.Settings);
    const server = new mcp_js_1.McpServer({
        name: settings.getServerName(),
        version: settings.getServerVersion(),
    }, {
        capabilities: {
            logging: {},
        },
    });
    registerTool(ToolNames_1.McpToolNames.CONSISTENCY_VALIDATE, toolDescription_1.ToolDescriptions.CONSISTENCY_VALIDATE, core_1.consistencyValidationToolSchema.shape, mcpTools_1.getConsistencyValidationTool, { readOnlyHint: true });
    registerTool(ToolNames_1.McpToolNames.COMPLETENESS_VALIDATE, toolDescription_1.ToolDescriptions.COMPLETENESS_VALIDATE, core_1.completenessValidationToolSchema.shape, mcpTools_1.getCompletenessValidationTool, { readOnlyHint: true });
    registerTool(ToolNames_1.McpToolNames.JAVA_BUILD, toolDescription_1.ToolDescriptions.JAVA_BUILD, core_1.javaBuildToolSchema.shape, mcpTools_1.getJavaBuildTool);
    registerTool(ToolNames_1.McpToolNames.JAVA_RUN_TEST, toolDescription_1.ToolDescriptions.JAVA_RUN_TEST, core_1.javaBuildToolSchema.shape, mcpTools_1.getJavaRunTestTool);
    registerTool(ToolNames_1.McpToolNames.JAVA_FIX_TEST, toolDescription_1.ToolDescriptions.JAVA_FIX_TEST, core_1.javaTestFixToolSchema.shape, mcpTools_1.getJavaTestFixTool, { readOnlyHint: true });
    registerTool(ToolNames_1.McpToolNames.INSTALL_APPCAT, toolDescription_1.ToolDescriptions.INSTALL_APPCAT, core_1.installAppCatToolSchema.shape, mcpTools_1.getInstallAppCatTool);
    registerTool(ToolNames_1.McpToolNames.PRECHECK_ASSESSMENT, toolDescription_1.ToolDescriptions.PRECHECK_ASSESSMENT, core_1.precheckAssessmentToolSchema.shape, mcpTools_1.getPrecheckAssessmentTool, { readOnlyHint: true });
    registerTool(ToolNames_1.McpToolNames.RUN_ASSESSMENT, toolDescription_1.ToolDescriptions.RUN_ASSESSMENT, core_1.runAssessmentToolSchema.shape, mcpTools_1.getRunAssessmentTool, { readOnlyHint: true });
    registerTool(ToolNames_1.McpToolNames.KB_ASSESSMENT, toolDescription_1.ToolDescriptions.KB_ASSESSMENT, kbAssessmentTool_1.kbAssessmentToolSchema, kbAssessmentTool_1.getKbAssessmentTool, { readOnlyHint: true });
    registerTool(ToolNames_1.McpToolNames.SEARCH_KB, toolDescription_1.ToolDescriptions.SEARCH_KB, core_1.searchKbToolSchema.shape, mcpTools_1.searchKbTool, { readOnlyHint: true });
    registerTool(ToolNames_1.McpToolNames.SEARCH_FILE, toolDescription_1.ToolDescriptions.SEARCH_FILE, core_1.searchFileToolSchema.shape, mcpTools_1.searchFileTool, { readOnlyHint: true });
    registerTool(ToolNames_1.McpToolNames.GET_KB, toolDescription_1.ToolDescriptions.GET_KB, core_1.getKbToolSchema.shape, mcpTools_1.getKbTool, {
        readOnlyHint: true,
    });
    registerTool(ToolNames_1.McpToolNames.MIGRATION_SUMMARY, toolDescription_1.ToolDescriptions.MIGRATION_SUMMARY, core_1.migrationSummarySchema.shape, mcpTools_1.getMigrationSummary, { readOnlyHint: true });
    registerTool(ToolNames_1.McpToolNames.RUN_TASK, toolDescription_1.ToolDescriptions.RUN_TASK, core_1.runTaskSchema.shape, mcpTools_1.runTaskTool, { readOnlyHint: true }, core_1.runTaskResponseSchema.shape, true);
    // Register the Version Control tool
    registerTool(ToolNames_1.McpToolNames.VERSION_CONTROL, toolDescription_1.ToolDescriptions.VERSION_CONTROL, core_1.VersionControlRequestSchema.shape, mcpTools_1.getVersionControlTool, { readOnlyHint: true });
    function registerTool(name, description, inputSchema, handler, annotations = {}, outputSchema, forceNewSession = false) {
        var _a;
        if ((_a = toolsConfig.enablement) === null || _a === void 0 ? void 0 : _a[name]) {
            server.registerTool(name, {
                description,
                inputSchema,
                outputSchema,
                annotations,
            }, async (...args) => {
                const start = Date.now();
                const correlationAware = getOrCreateContext(args, forceNewSession);
                const requestExtraFromParam = (0, utils_1.findParamByTypeWithIndex)(args, types_2.TypeTest.isRequestHandlerExtra);
                const context = createMcpContext(correlationAware, requestExtraFromParam === null || requestExtraFromParam === void 0 ? void 0 : requestExtraFromParam.value);
                logger.debug(`Invoking tool: ${name} with correlationId: ${context.correlationId}`);
                try {
                    // replace the last RequestHandlerExtra to MCPContext
                    const result = handler(...args.slice(0, args.length - 1), context);
                    logger.debug(`Tool ${name} invoke succeeded in ${Date.now() - start}ms`);
                    eventEmitter.emit('tool_invoke_success', {
                        invokedToolId: name,
                        duration: Date.now() - start,
                    }, context);
                    return result;
                }
                catch (error) {
                    logger.error(`Tool ${name} with correlationId: ${context.correlationId} failed after ${Date.now() - start}ms:`, error);
                    eventEmitter.emit('tool_invoke_fail', {
                        invokedToolId: name,
                        duration: Date.now() - start,
                        error: error,
                    }, context);
                    throw error;
                }
            });
        }
    }
    function getOrCreateContext(args, forceNew = false) {
        const contextFromArgs = (0, utils_1.findParamByTypeWithIndex)(args, types_2.TypeTest.isContextAware);
        return (contextFromArgs === null || contextFromArgs === void 0 ? void 0 : contextFromArgs.value) || { sessionId: forceNew ? (0, uuid4_1.default)() : '' };
    }
    function createMcpContext(obj, extra) {
        return {
            correlationId: (typeof obj === 'string' ? obj : obj.sessionId) || '',
            requestId: (0, uuid4_1.default)(),
            signal: extra === null || extra === void 0 ? void 0 : extra.signal,
            sendMessage: async (message, details) => {
                if (!(extra === null || extra === void 0 ? void 0 : extra.sendNotification)) {
                    return;
                }
                await (extra === null || extra === void 0 ? void 0 : extra.sendNotification({
                    method: 'notifications/message',
                    params: {
                        level: 'info',
                        data: {
                            message: message,
                            details,
                        },
                    },
                }));
            },
            reportProgress: async (message, progress) => {
                var _a;
                if (!(extra === null || extra === void 0 ? void 0 : extra.sendNotification)) {
                    return;
                }
                await (extra === null || extra === void 0 ? void 0 : extra.sendNotification({
                    method: 'notifications/progress',
                    params: {
                        progressToken: (_a = extra === null || extra === void 0 ? void 0 : extra._meta) === null || _a === void 0 ? void 0 : _a.progressToken,
                        message: message,
                        progress: progress,
                    },
                }));
            },
            sendRequest: async (systemMessage, userMessage, options) => {
                const response = await (extra === null || extra === void 0 ? void 0 : extra.sendRequest({
                    method: 'sampling/createMessage',
                    params: {
                        messages: [
                            {
                                role: 'user',
                                content: {
                                    type: 'text',
                                    text: userMessage,
                                },
                            },
                        ],
                        systemPrompt: systemMessage,
                        includeContext: (options === null || options === void 0 ? void 0 : options.includeContext) || 'none',
                        maxTokens: (options === null || options === void 0 ? void 0 : options.maxTokens) || 8192,
                        temperature: (options === null || options === void 0 ? void 0 : options.temperature) || 0,
                    },
                }, types_1.CreateMessageResultSchema));
                return response === null || response === void 0 ? void 0 : response.content.text;
            },
        };
    }
    if ((0, testUtils_1.isBenchmarkTest)()) {
        server.tool(ToolNames_1.MsbenchToolNames.RunInTerminal, toolDescription_1.ToolDescriptions.RUN_IN_TERMINAL, runInTerminalTool_1.runInTerminalSchema.shape, runInTerminalTool_1.runInTerminalTool);
    }
    process.on('uncaughtException', (err) => {
        logger.error(`Uncaught Exception: ${err}`);
        // Don't exit, just log
    });
    process.on('unhandledRejection', (reason, promise) => {
        logger.error(`Unhandled Rejection: ${reason}, Promise: ${promise}`);
        // Don't exit, just log
    });
    const transport = new stdio_js_1.StdioServerTransport();
    server
        .connect(transport)
        .then(async () => {
        logger.info('MCP server connected successfully.');
    })
        .catch((error) => {
        logger.error('Error occurred while connect to MCP server:', error);
    })
        .finally(() => {
        logger.info('MCP server is running. Press Ctrl+C to exit.');
    });
}
//# sourceMappingURL=server.js.map