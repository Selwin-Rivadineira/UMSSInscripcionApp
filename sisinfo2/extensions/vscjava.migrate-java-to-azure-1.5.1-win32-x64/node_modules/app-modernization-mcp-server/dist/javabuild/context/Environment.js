"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Environment = exports.pathExecutable = exports.localExecutable = void 0;
exports.checkCommandExist = checkCommandExist;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const os_1 = require("../common/os");
const shell_1 = require("../common/shell");
const localExecutable = (command) => ({
    name: command,
    path: '',
    version: '',
});
exports.localExecutable = localExecutable;
const pathExecutable = (command, commandPath) => {
    if (!commandPath || commandPath.trim().length > 0) {
        let normalizedPath = path_1.default.resolve(commandPath);
        if (checkCommandExist(command, normalizedPath)) {
            return {
                name: command,
                path: normalizedPath,
                version: '',
            };
        }
        if (!normalizedPath.endsWith('bin')) {
            normalizedPath = path_1.default.join(normalizedPath, 'bin');
            if (checkCommandExist(command, normalizedPath)) {
                return {
                    name: command,
                    path: normalizedPath,
                    version: '',
                };
            }
        }
    }
    return {
        name: command,
        path: '',
        version: '',
    };
};
exports.pathExecutable = pathExecutable;
function checkCommandExist(command, commandPath) {
    if (!commandPath || commandPath.trim().length === 0) {
        return false;
    }
    // Normalize the path
    commandPath = path_1.default.resolve(commandPath);
    // Check if the directory exists first
    if (!fs_1.default.existsSync(commandPath)) {
        return false;
    }
    // Define possible file extensions based on the platform
    const isWindows = process.platform === 'win32';
    const possibleExtensions = isWindows ? ['', '.exe', '.cmd', '.bat'] : [''];
    // Check if any variant of the command exists
    const exist = possibleExtensions.some((ext) => {
        const executablePath = path_1.default.join(commandPath, `${command}${ext}`);
        return fs_1.default.existsSync(executablePath);
    });
    if (!exist) {
        return false;
    }
    // For Linux and macOS, ensure the file is executable
    if (process.platform !== 'win32' && (command === 'mvnw' || command === 'gradlew')) {
        // Non-Windows platforms don't use extensions for executables
        const executablePath = path_1.default.join(commandPath, command);
        if (fs_1.default.existsSync(executablePath)) {
            try {
                // Add executable permission for user
                const stats = fs_1.default.statSync(executablePath);
                if (!(stats.mode & fs_1.default.constants.S_IXUSR)) {
                    fs_1.default.chmodSync(executablePath, fs_1.default.constants.S_IXUSR | stats.mode);
                }
            }
            catch (error) {
                throw new Error(`Permission error: Could not make ${executablePath} executable: ${error.message || String(error)}`);
            }
        }
    }
    return exist;
}
// creates an environment with a name, executables and environment variables
class Environment {
    constructor(name, executables, envVars) {
        this.name = name;
        this.executables = [];
        this.envVars = {};
        this.executables = executables;
        this.envVars = {
            ...this.getPathEnvVariable(),
            ...envVars,
        };
    }
    getExecutableNames() {
        return this.executables.map((exe) => exe.name);
    }
    getFullCmdArgs(command, args) {
        var _a;
        const cmdCustomizedArgs = ((_a = this.executables.find((exe) => exe.name === command)) === null || _a === void 0 ? void 0 : _a.args) || [];
        return [...args, ...cmdCustomizedArgs];
    }
    // runs a command in the environment
    async runCommand(workDir, command, args, runOptions = {}) {
        // uf the command is in our list of executables, use the path to the executable
        const exe = this.executables.find((e) => e.name === command);
        const pathToCommand = path_1.default.join((exe === null || exe === void 0 ? void 0 : exe.path) || '', command);
        return (0, shell_1.runCommand)(workDir, pathToCommand, args, {
            ...runOptions,
            env: { ...runOptions.env, ...this.envVars },
        });
    }
    getPathEnvVariable() {
        if (this.executables.length === 0) {
            return {};
        }
        const { name: pathName, separator: pathSeparator } = (0, os_1.getPathEnvVarInfo)();
        const envPath = this.executables
            .filter((exe) => exe.includeInPath) // only include executables that should be in the path
            .map((exe) => { var _a; return (_a = exe.path) === null || _a === void 0 ? void 0 : _a.trim(); })
            .filter((path) => (path === null || path === void 0 ? void 0 : path.length) > 0) // remove empty paths
            .join(pathSeparator);
        const vars = {};
        vars[pathName] = `${envPath}${pathSeparator}${process.env.PATH}`;
        return vars;
    }
}
exports.Environment = Environment;
// default local environment for the process
Environment.Local = new Environment('local', [
    (0, exports.localExecutable)('java'),
    (0, exports.localExecutable)('mvn'),
    (0, exports.localExecutable)('gradle'),
]);
Environment.Maven = new Environment('maven', [
    (0, exports.localExecutable)('java'),
    (0, exports.localExecutable)('mvn'),
]);
Environment.Gradle = new Environment('gradle', [
    (0, exports.localExecutable)('java'),
    (0, exports.localExecutable)('gradle'),
]);
//# sourceMappingURL=Environment.js.map