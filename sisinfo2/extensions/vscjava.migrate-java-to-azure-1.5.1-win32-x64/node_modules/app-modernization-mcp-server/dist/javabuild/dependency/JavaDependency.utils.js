"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseJavaDepCoord = parseJavaDepCoord;
exports.parseJavaDepCoordFromGradle = parseJavaDepCoordFromGradle;
exports.getJavaDepChanges = getJavaDepChanges;
exports.getJavaProjDepChanges = getJavaProjDepChanges;
exports.filterDeps = filterDeps;
exports.filterDepsByGroupId = filterDepsByGroupId;
const JavaDependency_1 = require("./JavaDependency");
/**
 * Parses a Maven dependency coordinate string and returns an `IJavaDep` object.
 *
 * The Maven dependency coordinate string should follow the format:
 * `groupId:artifactId:type[:classifier]:version[:scope]`.
 *
 * @param id - The Maven dependency coordinate string to parse.
 * @returns An `IJavaDep` object if the coordinate string is valid, otherwise `undefined`.
 *
 * @example
 *
 * Input: com.example:library:jar:classifier:1.0.0:compile
 *
 * Output:
 *  | Group | Value      | Description                        | Example     |
 *  |-------|------------|------------------------------------|-------------|
 *  | 1     | groupId    | Matches the group ID.              | com.example |
 *  | 2     | artifactId | Matches the artifact ID.           | library     |
 *  | 3     | type       | Matches the type.                  | jar         |
 *  | 5     | classifier | (Optional) Matches the classifier. | classifier  |
 *  | 6     | version    | Matches the version.               | 1.0.0       |
 *  | 8     | scope      | (Optinal) Matches the scope.       | compile     |
 */
function parseJavaDepCoord(id) {
    const match = id.match(/([a-zA-Z0-9\\._\\-]+):([a-zA-Z0-9\\._\\-]+):([a-zA-Z0-9\\.\\-]+)(:([a-zA-Z0-9_\\-]+))?:([a-zA-Z0-9\\._\\-]+)+(:([a-zA-Z0-9\\.\\-]+))?/);
    if (match) {
        const [coordinate, groupId, artifactId, type, , classifier, version, , scope] = match;
        return new JavaDependency_1.JavaDep({ coordinate, groupId, artifactId, type, classifier, version, scope });
    }
    return;
}
function parseJavaDepCoordFromGradle(id) {
    // Match direct dependencies (those with \--- or +--- prefix)
    // Gradle format: group:name:version
    //org.apache.jmeter:ApacheJMeter_components:4.0 (*)
    const depMatch = id.match(/^\+---\s+([^:\s]+):([^:\s]+)\s*(->|:)\s*([^:\s]+)/);
    if (depMatch) {
        const [, groupId, artifactId, , version] = depMatch;
        const dependency = new JavaDependency_1.JavaDep({
            coordinate: `${groupId}:${artifactId}:${version}`,
            groupId: groupId,
            artifactId: artifactId,
            version: version,
        });
        return dependency;
    }
    return undefined;
}
function getJavaDepChanges(original, updated) {
    const additions = [];
    const removals = [];
    const updates = [];
    let count = 0;
    const originalDepsMap = new Map();
    // Create a map for quick lookup of original dependencies
    for (const dep of original) {
        originalDepsMap.set(dep.key, dep);
    }
    // Compare new dependencies with original dependencies
    for (const newDep of updated) {
        const originalDep = originalDepsMap.get(newDep.key);
        if (!originalDep) {
            // JavaDep is new
            additions.push(newDep);
            count++;
        }
        else {
            const propDiff = [];
            // const properties = ['type', 'classifier', 'version', 'scope'] as const;
            // Only compare version
            const properties = ['version'];
            properties.forEach((prop) => {
                if (newDep[prop] !== originalDep[prop]) {
                    propDiff.push(prop);
                }
            });
            // If any properties differ, add to updates
            if (propDiff.length > 0) {
                updates.push({
                    original: originalDep,
                    updated: newDep,
                    propDiff,
                });
                count++;
            }
        }
    }
    // Check for removed dependencies
    for (const originalDep of original) {
        if (!updated.some((dep) => dep.key === originalDep.key)) {
            removals.push(originalDep);
            count++;
        }
    }
    return { additions, removals, updates, count };
}
function getJavaProjDepChanges(oProjDeps, uProjDeps) {
    let numDepChanges = 0;
    const projects = [];
    for (const uProj of Object.keys(uProjDeps)) {
        const oDeps = oProjDeps[uProj];
        const uDeps = uProjDeps[uProj];
        if (!oDeps) {
            const changes = getJavaDepChanges([], uDeps);
            // All dependencies are new
            projects.push({
                name: uProj,
                changes,
            });
            numDepChanges += changes.count;
        }
        else {
            const changes = getJavaDepChanges(oDeps, uDeps);
            // Look for additions, removal or updates in the subproject dependencies
            projects.push({
                name: uProj,
                changes,
            });
            numDepChanges += changes.count;
        }
    }
    // Check for removed dependencies
    for (const oProj of Object.keys(oProjDeps)) {
        const oDeps = oProjDeps[oProj];
        if (!Object.keys(uProjDeps).some((project) => project === oProj)) {
            const changes = getJavaDepChanges(oDeps, []);
            projects.push({
                name: oProj,
                changes,
            });
            numDepChanges += changes.count;
        }
    }
    return { numDepChanges, projects };
}
function filterDeps(projectDeps, filter) {
    const result = {};
    for (const project in projectDeps) {
        const deps = projectDeps[project].filter(filter);
        if (deps.length > 0) {
            result[project] = deps;
        }
    }
    return result;
}
function filterDepsByGroupId(projectDeps, groupId) {
    return filterDeps(projectDeps, (dep) => dep.groupId === groupId);
}
//# sourceMappingURL=JavaDependency.utils.js.map