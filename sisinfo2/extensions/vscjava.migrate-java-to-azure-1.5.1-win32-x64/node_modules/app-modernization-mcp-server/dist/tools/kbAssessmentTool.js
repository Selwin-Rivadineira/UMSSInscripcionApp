"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getKbAssessmentTool = exports.kbAssessmentToolSchema = void 0;
const types_1 = require("@modelcontextprotocol/sdk/types");
const path_1 = __importDefault(require("path"));
const tsyringe_1 = require("tsyringe");
const zod_1 = require("zod");
const core_1 = require("../core");
const types_2 = require("../types");
const utils_1 = require("../utils");
const ToolNames_1 = require("./ToolNames");
const ASSESSMENT_DIR = path_1.default.join(core_1.APPMOD_DIR, 'assessment');
const progressFile = 'assessment-progress.md';
const resultFile = 'assessment-result.json';
exports.kbAssessmentToolSchema = {
    workspacePath: zod_1.z.string().describe('The workspace path of the Java project to assess'),
};
const getKbAssessmentTool = async (request, extra) => {
    const logger = tsyringe_1.container.resolve(types_2.Beans.Logger);
    const workspacePath = request.workspacePath;
    const kbSummaries = await listMarkdownKbSummaries();
    logger.debug(`Knowledge Base Summaries:\n${kbSummaries}`);
    const techMappings = await getTechMappingsFromKbSummaries(kbSummaries, extra);
    const message = getResponseMessage(workspacePath, techMappings);
    return utils_1.MCPOutput.success(message);
};
exports.getKbAssessmentTool = getKbAssessmentTool;
async function listMarkdownKbSummaries() {
    //const kbStore = container.resolve<IKBStore>(Beans.KBStore);
    //const allKbs = await kbStore.listKbs();
    // Filter markdown kbs
    //const markdownKbs = allKbs.filter((kb) => MetadataGetter.getSource(kb).endsWith('.md'));
    //return allKbs.map((kb) => `- **${kb.title}**: ${kb.description}`).join('\n');
    return [
        '**Ant to Maven**: Migrate Ant Project to Maven Project',
        '**Eclipse to Maven**: Migrate Eclipse Project to Maven Project',
        '**Eclipse to Gradle**: Migrate Eclipse Project to Gradle Project',
    ].join('\n');
}
async function getTechMappingsFromKbSummaries(kbSummaries, extra) {
    const response = await extra.sendRequest({
        method: 'sampling/createMessage',
        params: {
            messages: [
                {
                    role: 'user',
                    content: {
                        type: 'text',
                        text: kbSummaries,
                    },
                },
            ],
            systemPrompt: `You are an expert in analyzing technology migration documentation. 
Given a list of knowledge base (KB) summaries, your task is to extract and clearly identify the source and target technologies involved in each KB.

For each KB summary, provide a table of clearly stated technology migration pairs:
    - Source Technology: The original tool, framework, or platform being migrated from.
    - Target Technology: The new tool, framework, or platform being adopted.

Return a single Markdown table like this:
\`\`\`markdown
| Source Technology | Target Technology |
| - | - |
\`\`\`

Additional instructions:
1. **Avoid Duplicates**
    - Only keep unique source-to-target pairs.
    - Ignore rows where both source and target are already listed previously.
2. **Normalize Similar Names**
    - Normalize variations of similar technologies
    - Likewise, standardize target names
3. **Strict Extraction**
    - Only extract technologies that are explicitly or clearly implied in the summary.
    - Do not infer technologies beyond what is stated.
4. **One Row per Distinct Migration Path**
    - If a KB discusses multiple migrations, list each pair in its own row.
5. **Skip if Unclear**
    - If the source or target technology is not clearly identifiable, skip that KB entry.
`,
            includeContext: 'thisServer',
            maxTokens: 100,
            temperature: 0,
        },
    }, types_1.CreateMessageResultSchema);
    return response.content.text;
}
function getResponseMessage(workspacePath, techMappings) {
    return `
You are tasked with executing Java application assessment to identify the technology usage **based on a provided knowledge base of source-to-target technology mappings** for Azure cloud migration.

Your goal is to:
- Understand the list of source technologies defined in the knowledge base and its common usage pattern.
- Analyze the application's source code, configuration files, and build scripts to find the usages of each source technology.
- For each detected technology, provide evidence: file name, file path, line numbers.
- Produce a structured result that can be used to guide modernization and migration efforts.

## Input Information

- **Project Codebase**: ${workspacePath}
- **Knowledge Base of source-to-target Technology Mappings**: [Listed in the Section 'Knowledge Base of source-to-target Technology Mappings' below]

## Knowledge Base of source-to-target Technology Mappings

${techMappings}

## Execution Process

Step 1: Preparation and Understanding

1. Load the knowledge base containing source-to-target technology mappings.
2. Understand the list of source technologies and summarize its common usage patterns.
3. Identify and collect all the relevant file types in the application for analysis:
    - Java source files: \`.java\`
    - Build files: \`pom.xml\`, \`build.gradle\`, \`build.xml\`
    - Config files: \`.properties\`, \`.yaml\`, \`.yml\`, \`.xml\`

Step 2: Static Code Analysis

1. Iterate through each **source technology** defined in the knowledge base.
2. For each source technology:
    - Summarize its common usage patterns, including:
        - Java API classes and methods
        - Dependency imports and build declarations
        - Configuration keys and property names
        - Annotations or XML tags
    - Scan the relevant files in the project **until the first valid usage of the source technology is found**:
        - build files
        - configuration files
        - Java source files
    - For each match, collect:
        - Category: Source Technology Name (from the knowledge base)
        - Solution: Target Technology Name (from the knowledge base)
        - Issues:
            - Title: Specific Technology Usage for Source Technology
            - Code Impact: 1 (indicating a valid usage)
            - Files:
                - File path
                - File name
                - Line numbers (if available)

Step 3: Generate Structured Results

1. For each detected source technology, report:
    - Source technology
    - Specific technology usage identified
    - Target technology
    - Source file path, file name and (if applicable) line numbers

## Success Criteria

A successful Java application assessment using the technology mapping knowledge base must meet the following criteria:

1. Complete Coverage of Source Technologies
    - All source technologies defined in the knowledge base have been individually evaluated.
    - No technology has been skipped, ignored, or partially assessed.
    - Treat all source technologies as equally important, regardless of complexity.

2. Efficient File Analysis per Technology
    - For each source technology in the knowledge base:
        - You MUST begin scanning all applicable file types (\`.java\`, \`.xml\`, \`.yml\`, \`.properties\`, \`pom.xml\`, etc.)
        - **Once a confirmed usage is found**, you may stop scanning further files for that technology to improve efficiency.
        - If a match is found in any one file (Java/config/build), no need to continue scanning the rest for that technology.
        - If no usage is found in any file, report it as not detected in the ${progressFile}.
    - The goal is to **ensure detection is possible without unnecessary overhead**, while still maintaining full coverage of all source technologies.

3. Accurate and Evidence-Based Detection
    - All reported detections are backed by:
        - File path and (if applicable) line numbers
    - False positives and speculative detections are avoided.

4. Clear and Structured Output
    - Results are grouped by Domain.
    - Do NOT include those source technologies that not detected in the output.
    - Each detection includes:
        - Category (source technology)
        - Criticality
        - Solution (target technology from the knowledge base)
        - Issues (file path, file name, line numbers)
    - Output format is clean, structured, and easy to interpret (structured JSON).

## Output Format

For each detected source technology, 
    - Assign an appropriate Domain: Azure Readiness | Cloud Native | Java Modernization
        - Azure Readiness: Technologies that need to be migrated or adapted to work seamlessly with Azure-specific services and infrastructure (e.g., databases, messaging, storage, authentication)
        - Cloud Native: Technologies that should be modernized to follow cloud-native principles such as scalability, resilience, observability, and distributed architecture patterns
        - Java Modernization: Technologies that need to be updated to use supported Java versions, modern APIs, and secure practices while removing deprecated or vulnerable components
    - Assign an appropriate Criticality: mandatory | optional | potential
        - mandatory: Critical dependencies that will prevent the application from functioning correctly in Azure if not migrated or updated
        - optional: Non-critical technologies that can be migrated for improved performance, security, maintainability, or cost optimization
        - potential: Technologies where migration necessity cannot be definitively determined without additional analysis or runtime testing
    - Assign the appropriate Containerization: boolean
        - true: If the technology is containerized or can be containerized
        - false: If the technology is not containerized or cannot be containerized

Please provide the assessment result file \`${resultFile}\` with the following format, in the folder \`${ASSESSMENT_DIR}\`:
\`\`\`json
{
    "azureReadiness": [
        {
            "category": "Source Technology Name",
            "containerization": boolean,
            "solutions": [
                "Target Technology Name",
            ],
            "issues": [
                {
                    "title": "Specific Technology Usage",
                    "criticality": "mandatory | optional | potential",
                    "codeImpact": 1,
                    "files":[
                        {
                            "filePath": "src/main/java/CacheSettings.java",
                            "fileName": "CacheSettings.java",
                            "lineNumber": [
                                23,
                                34,
                            ],
                        },
                        //....
                    ]
                }
            ]
        },
        //...
    ],
    "cloudNative": [
        // similar as above
    ],
    "javaModernization": [
        // similar as above
    ]
}
\`\`\`

Make sure that the output format strictly follows the TypeScript interface definition:
\`\`\`typescript
interface AssessmentResult {
    azureReadiness: [
        category: string;
        containerization: boolean;
        solutions: string[];  // If a source technology has multiple target technologies for migration, list them all
        issues: [
            title: string;
            criticality: string;
            codeImpact: number;
            files: [
                fileName: string;
                filePath: string;
                lineNumbers?: number[];
            ];
        ];
    ];
    cloudNative: [
        // same as above
    ];
    javaModernization: [
        // same as above
    ];
}
\`\`\`

## Progress Tracking

Create and maintain a \`${progressFile}\` in the folder \`${ASSESSMENT_DIR}\`. This file will serve as a running log to track the assessment progress of each source technology defined in the knowledge base.

1. **Initialize \`${progressFile}\`** at the start of the assessment.
   - List all source technologies from the knowledge base.
   - Mark each as \`Unchecked\`.

2. **Update \`${progressFile}\`** after you analyze each source technology:
   - Move status from \`Unchecked\` -> \`Checked\`.
   - For \`Checked\` items, include:
     - Detected or Not
     - Files location and line number

3. **Format Example:**

\`\`\`markdown
# Assessment Progress Tracking

| Source Technology | Status | Detected or Not | File & Line                  |
|-------------------|--------|----------   ----|------------------------------|
| MySQL             | [x]    | [x]             | DatabaseSettings.java:14,69; |
| PostgreSQL        | [x]    | [ ]             | -                            |
| Local File System | [ ]    | [ ]             | -                            |
\`\`\`

4. Keep \`${progressFile}\` updated in real-time as you proceed each source technology through the analysis.

5. Never remove or overwrite progress for previously completed items - always append and update progressively.

## Execution Behavior Requirement

You MUST perform the **entire assessment in one uninterrupted execution cycle**. This is a **non-interactive**, batch-mode task.

- **DO NOT stop or wait for user confirmation** after analyzing a single technology or partial progress.
- **DO NOT prompt for continuation, restart, or refinement during the task.**
- **DO NOT ask the user to cancel or confirm before proceeding further.**
- **DO NOT terminate early due to processing time â€” continue until all source technologies in the knowledge base have been assessed completely.**
- Treat this as a **fully autonomous operation**, not a multi-step interaction.

## Important Guideline

To ensure accurate and complete assessment of the Java application, you MUST strictly follow the guidelines below:

1. **Exclude Non-Code Documentation Files**
    - DO NOT analyze documentation-only files such as:
        - \`.md\`, \`.txt\`, \`.rst\`, \`.pdf\`, \`.docx\`
    - These files are not part of the application's executable, configuration, or build logic and should be ignored entirely.
    - Ignore code examples or configuration snippets inside such documents.
    - **DO NOT analyze or match content inside comments** (e.g., Java \`//\`, \`/* */\`, XML \`<!-- -->\`, YAML \`#\`, etc.)

2. **MUST never modify the project during assessment**:
    - Do not rewrite, restructure, reformat, or remove any files.
    - Only read, analyze, and report detections.

3. - DO perform the entire assessment across **all source technologies** defined in the knowledge base **in a single uninterrupted execution cycle**.
    - DO NOT stop, pause, or wait for user input after processing each technology.
    - DO NOT require confirmation before continuing to the next source technology.
    - Automatically continue iterating through the list of technologies until all have been fully assessed.
    - Only generate the final report and progress updates once all analysis is complete.

## Next Step

Once the technology usage assessment is complete (the ${progressFile} is fully updated, and the ${resultFile} is written successfully), 
Automatically use tool \`#${ToolNames_1.VscodeToolNames.OpenAssessmentReport}\` to open the assessment report webview interface to display detailed migration assessment results, including identified issues, recommendations, and Azure readiness analysis. No user confirmation is required - proceed to open the report directly.
`;
}
//# sourceMappingURL=kbAssessmentTool.js.map