# Github Copilot App Modernization for Java -  MCP Server

## Overview
The MCP server is a Node.js application that implements the Model Context Protocol (MCP) to provide tools for Java application modernization. It allows clients to interact with the server to perform various tasks such as building Java projects, running tests, and fixing test failures, also providing knowledge base (KB) search and retrieval functionalities.

## Prerequisites
- Node.js (v18 or later)
- npm (Node Package Manager)
- Visual Studio Code (1.101 or later) for development and debugging
- JDK (optional, for Java-related tools)

## Build

```
npm install
```
Installs all dependencies required for the project.

> **NOTE**: Due to a few code in `mcp-server` is still relying on the code from VSCode extension, you need to install the dependencies in the VSCode extension as well and build for once.
```
cd ../
npm install
npm run build
```

Then run the build command in the `mcp-server` directory:
```
npm run build
```
This will compile the TypeScript code into JavaScript and place the output in the `dist` directory.

## Package

```
npm run package
```
This will run the linter and then package the application using Webpack in production mode.

MCP server will be bunddled into a single executable binary file, `mcp-server` (`mcp-server.exe` for Windows), in the `dist/bins` directory.

#### Plaftform and Architecture
By default, the binary file is packaged by your current platform and architecture, such as `darwin-x64`, `linux-x64`, or `win32-x64`. 

You can specify the target platform and architecture by setting the `MCP_PACKAGE_PLATFORM` environment variables. For example, to package for Linux x64, you can run:
```
MCP_PACKAGE_PLATFORM=linux-x64 npm run package
```

> **NOTE**: Although cross-platform packaging is supported, but there might be some issues with native modules. It's better to run the packaging command on the target platform to ensure compatibility.

## Run

```
npm start
```
Starts the server using the compiled JavaScript in the `dist` directory.

#### Run with VSCode extension
Just run the extension, and MCP server will start automatically. 
Refer to [extension.ts](../src/extension.ts#L115) for how the MCP server runs with the VSCode extension.

#### Run for other server types
You can also run the MCP server for other server types by specifying the `--serverType` argument. For example, to run the server for the "code2cloud" type, you can use the following command:
```
node dist/index.js --serverType code2cloud
```

Same to the dotnet migration:
```
node dist/index.js --serverType dotnetMigration
```

Refer to [index.ts](src/index.ts#L4) for more details on how to run the MCP server.

#### Debug in inspector

Instead every time running the MCP server from extension, you can run it in debug mode using the Model Context Protocol Inspector.
```
npm run inspector
```
Open browser and navigate to http://127.0.0.1:6274 to debug the server using the Model Context Protocol Inspector.

## Linting

```
npm run lint
```
Checks the code for linting errors.
Refer to the [eslint.config.js](eslint.config.js) file for the ESLint configuration.
Refer to the [ESLint documentation](https://eslint.org/docs/latest/user-guide/getting-started) for more details on how to configure and use ESLint.

#### Fixing Linting Errors
To automatically fix linting errors where possible, you can run:

```
npm run lint:fix
```

#### Formatting

```
npm run prettier
```
Formats the code using Prettier.
Refer to the [prettier.config.js](prettier.config.js) file for the Prettier configuration.

## Development

#### Understanding the MCP server
You would need to understand basic concepts of the MCP server, such as how it provides tools to MCP clients

**Useful links**:
- [Model Context Protocol](https://modelcontextprotocol.io)
- [For Server Developers](https://modelcontextprotocol.io/quickstart/server#node)
- [Official Samples](https://github.com/modelcontextprotocol/servers/tree/main/src/everything)

#### Structure of src directory
The `src` directory contains the source code for the MCP server. The main entry point is [src/index.ts](src/index.ts). The directory is structured as follows:
```
src/
├── kb/                # KB load, search and get functionality
├── telemetry          # Telemetry collection and reporting
├── tools/             # MCP tools
├── utils/             # Utility functions and helpers
├── codetocloud.ts     # Main entry point for the Code to Cloud MCP server
├── index.ts           # Main entry point for the MCP server (code migration + Code to Cloud)
├── ioc.ts             # Inversion of Control container for dependency injection
├── types.ts           # Type definitions for the MCP server
├── server.ts          # Main entry point for the code migration MCP server
├── setting.ts         # Configuration settings for the MCP server
└── logger.ts          # Logging utility
```

#### Inversion of Control (IoC)
The MCP server uses uses the [tsyringe](https://www.npmjs.com/package/tsyringe) library for dependency injection. The IoC container is defined in the [src/ioc.ts](src/ioc.ts) file.

You can register your own services in the IoC container, for example:
```typescript
import { container } from './ioc';
import { MyService } from './my-service';
container.register(MyService, { useClass: MyService });
```

Injecting services is done using the `@injectable` decorator and the `@inject` decorator from the `tsyringe` library. For example:
```typescript
import { injectable, inject } from 'tsyringe';
import { MyService } from './my-service';
@injectable()
export class OtherService {
  constructor(@inject(Beans.MyService) private myService: MyService) {}
  public async myMethod() {
    const result = await this.myService.doSomething();
    return result;
  }
}
```

#### Settings
The MCP server uses a settings file to configure various aspects of the server. 

The settings are defined in the [src/settings.ts](src/settings.ts) file. You can change the settings by passing the desired values from environment variables.

##### Supported Environment Variables

| Variable Name                        | Default Value / Description                                      |
|--------------------------------------|-----------------------------------------------------------------|
| APPMOD_DISABLE_TELEMETRY        | true (disable telemetry collection)                            |
| APPMOD_DEBUG_TELEMETRY          | false (enable debug logging for telemetry)                      |
| APPMOD_CUSTOM_KB_PATH           | '~/.ghcp-appmod/custom-kb' (custom knowledge base path)                                 |
| APPMOD_MSFT_KB_PATHS            | './rag,./kb' (comma-separated Microsoft KB paths)                |
| APPMOD_LOG_LEVEL                | 'info' (logging level)                                         |
| APPMOD_LOG_FILE_PATH            | '~/.ghcp-appmod/logs' (log file directory)                 |
| APPMOD_ENABLE_MODEL_REMOTE_DOWNLOAD | false (enable remote model download)                      |
| APPMOD_MODEL_PATH               | '../models' (model directory path)                              |
| APPMOD_EMBEDDING_MODEL_NAME     | 'sentence-transformers/all-MiniLM-L6-v2' (embedding model name) |
| APPMOD_VECTOR_STORE_TYPE        | 'in-memory' (vector store type) - only in-memory store is supported for now |
| APPMOD_SIMILARITY_THRESHOLD     | 0.4 (similarity threshold, depends on model)             |
| APPMOD_RERANKING_ENABLED        | true (enable reranking)                                        |
| APPMOD_RERANKING_THRESHOLD      | 0.7 (reranking threshold)                                      |
| APPMOD_RERANKING_MODEL_NAME     | 'cross-encoder/ms-marco-MiniLM-L6-v2' (reranking model name)    |
| APPMOD_CALLER_MACHINE_ID        | '' (caller machine ID) - for telemetry                                       |
| APPMOD_CALLER_SESSION_ID               | '' (caller session ID) - for telemetry                                                |
| APPMOD_CALLER_ID                | '' (caller ID) - for telemetry                                                 |
| APPMOD_CALLER_VERSION                | '' (caller version) - for telemetry                                               |
| APPMOD_CALLER_TYPE              | '' (caller type) - for telemetry                                               |

#### Logging
The MCP server uses the [winston](https://www.npmjs.com/package/winston) library for logging. The logging configuration is defined in the [src/logger.ts](src/logger.ts) file. 

###### Usage
You can inject the logger into your services using the `@inject` decorator from the `tsyringe` library. For example:
```typescript
import { injectable, inject } from 'tsyringe';
import { MCPLogger } from './logger';
@injectable()
export class MyService {
  constructor(@inject(Beans.Logger) private logger: MCPLogger) {}
  public myMethod() {
    this.logger.info('This is an info message');
    this.logger.error('This is an error message');
  }
}
```

###### Use environment variables to change logging settings
You can change the logging level by setting the `APPMOD_LOG_LEVEL` environment variable.

Also, you can change the log file location by setting the `APPMOD_LOG_FILE_PATH` environment variable. 
> By default, the log file is located in the **`~/.ghcp-appmod/logs`** directory.

#### Telemetry
The MCP server collects telemetry data to help improve the service. The telemetry events and implementations are defined in the [src/telemetry/telemetry.ts](src/telemetry/telemetry.ts) file.

###### Usage
You can modify the `McpServerPropertyMap` interface in the `src/telemetry/telemetry.ts` file. You can define new events and their properties, for example:
```typescript
export interface McpServerPropertyMap {
    'my/custom/event': {
        properties: {
            customProperty: string;
        };
        measurements: {
            duration: number;
        };
    };
}
```

Then, you can send telemetry events using the `TelemetryService` class, which is injected into your services using the `@inject` decorator from the `tsyringe` library. For example:
```typescript
import { injectable, inject } from 'tsyringe';
import { TelemetryService } from './telemetry/telemetry';
@injectable()
export class MyService {
  constructor(@inject(Beans.TelemetryService) private telemetryService: TelemetryService) {}
  public async myMethod() {
    // Your logic here
    await this.telemetryService.sendEvent('my/custom/event', {
      properties: {
        customProperty: 'value',
      },
      measurements: {
        duration: 100,
      },
    });
  }
}
```

###### Use environment variables to change telemetry settings
You can disable telemetry by setting the `APPMOD_DISABLE_TELEMETRY` environment variable to `true`.

Also, you can set the `APPMOD_DEBUG_TELEMETRY` environment variable to `true` to enable debug logging for telemetry, and the telemetry data will be sent to the log, for example:
```
[21108] 2025-07-09 13:09:29.651 [telemetry] Telemetry Event: java/migrateassistant/kb/get {"properties":{"result":"success","kbId":"Change pom xml files for spring boot logback logging","serverVersion":"1.0.0"},"measurements":{"duration":1,"hit":1}}
```

##### Sending Telemetry Data
If `APPMOD_DEBUG_TELEMETRY` is set to `false` and `APPMOD_DISABLE_TELEMETRY` is set to `false`, the telemetry data will be sent to application insights. Refer to the [package.json](../package.json#L8) file for the application insights instrumentation key.

> **NOTE**: In the development mode, the telemetry data will be sent to a application insights which is used for development purposes. [migrate-java-vscode-extension-ai](https://ms.portal.azure.com/#@microsoft.onmicrosoft.com/resource/subscriptions/bf85658b-2e17-4390-8a60-1772d27ff80d/resourceGroups/migrate-java-vscode-extension/providers/microsoft.insights/components/migrate-java-vscode-extension-ai/overview)
> In the production mode, the telemetry data will be sent to a devdiv application insights instance. The logs will be available [here](https://dataexplorer.azure.com/clusters/ddtelfiltered.centralus/databases/Copilot?query=H4sIAAAAAAAAAwtKLHctS80rKQ4pSkxOLQYAfHm7ww8AAAA%3D).

## Testing

### Runs the test suite
```
npm test
```
> Both unit tests and integration tests are run when you run the `npm test` command.

### Writing Tests
Tests are written using the [jest](https://jestjs.io/) framework. 

#### Unit Tests
The unit test files are located alongside the source files in the `src` directory. For example, if you have a module `my-module.ts`, you can create a test file `my-module.test.ts` in the same directory, write your tests using the `describe` and `it` functions provided by Jest. For example:
```typescript
import { myFunction } from './my-module';

describe('myFunction', () => {
  it('should return the correct result', () => {
    const result = myFunction();
    expect(result).toBe('expected result');
  });
});
```

#### Integration Tests
The integration test are aim to test the MCP server and its tools by interacting with a running instance of the MCP server. 
You can create a new tests in the [tests/integration.test.ts](tests/integration.test.ts) file. For example:
```typescript
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';

describe('My MCP Tool', () => {
  let client: Client;

  beforeAll(() => {
    const transport = new StdioClientTransport(
      {
        command: './dist/bins/mcp-server', // Path to the MCP server binary
        args: ['arg1', 'arg2'], // Arguments to pass to the MCP server
      }
    );
    client = new Client(transport);
  });

  it('should invoke my tool and return the expected result', async () => {
    const result = await client.invokeTool('my-tool-id', { arguments: { param1: 'value1'} });
    // Refer to the integration.test.ts file for more examples on how to verify the result
  });
});
```
> **NOTE**: Due to we're testing the bundled MCP server binary from `dist/bins`, you need ensure your code is built and packaged (`npm run package`) when you run the integration test from IDE.
> And, if you run `npm run test:integration` from terminal, it will automatically package the binary before running the tests.

> Mock data for the integration tests is located in the `tests/mock-data` directory. You can create your own mock data files to simulate the behavior of the MCP server and its tools.

#### Change settings for MCP server in tests
You can change the settings for the MCP server in the tests by modifying the [src/settings.ts](src/settings.ts) file. For example, you can change the env `APPMOD_MSFT_KB_PATHS` to point to a different Microsoft knowledge base directory:
```typescript
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';

describe('My MCP Tool', () => {
  let client: Client;

  beforeAll(() => {
    const transport = new StdioClientTransport(
      {
        command: process.execPath,
        args: ['./dist/index.js'],
        env: {
          APPMOD_MSFT_KB_PATHS: '/path/to/your/mock/kb',
        },
      }
    );
    client = new Client(transport);
  });

  ... the rest of your test code ...
});
```

#### Check server logs for tests
Check the logs in the `tests/logs` directory to see the MCP server logs during tests.

## Tools

#### Java Build Tool

This tool (ID: `appmod-build-project`) uses Maven or Gradle to build your Java project and report any detected errors. It accepts a `workspacePath` parameter and returns build results. Use this tool to verify your code after making changes and to identify any build errors that need to be fixed.

#### Java Run Test Tool

This tool (ID: `appmod-run-test`) runs tests in the Java project and reports any detected errors or test failures. It accepts a `workspacePath` parameter and returns test execution results with details about failures and errors encountered.

#### Java Fix Test Tool

This tool (ID: `appmod-fix-test`) generates a plan to guide you in fixing unit test failures in the Java project after migration. It accepts a `workspacePath` parameter and an optional `maxIterations` parameter to control the maximum number of fix attempts. The tool provides a step-by-step approach to fixing test issues.

#### Changing tools enablement
Toggle the enablement of tools in the MCP server, you can modify the [tools.json](tools.json) file located in the `mcp-server` directory. This file contains a list of tools and their enablement status. You can set the value to `true` or `false` to enable or disable a tool.

> **NOTE**: When the value is set to `false` or even the entry is not present, a tool will not be registered into the MCP server.

> **NOTE**: There is a `tools.dotnet.json` file in the `mcp-server` directory, which is used for the .NET version of the MCP server. You can ignore this file if you are only working with the Java version.